[{"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\index.tsx":"1","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\reportWebVitals.ts":"2","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\MainController.tsx":"3","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\StartController.tsx":"4","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ReferringController.tsx":"5","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\AIController.tsx":"6","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Facade.tsx":"7","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Language.tsx":"8","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\index.tsx":"9","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\SensorData.tsx":"10","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\index.tsx":"11","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DataCollectionController.tsx":"12","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\SensorManager.tsx":"13","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DeliveryController.tsx":"14","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\VisualizationController.tsx":"15","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DatabaseConnector.tsx":"16","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIDistributor.tsx":"17","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIBuilder.tsx":"18","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\index.tsx":"19","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\User.tsx":"20","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\index.tsx":"21","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\State.tsx":"22","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\State.tsx":"23","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeliveryFormat.tsx":"24","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeviceData.tsx":"25","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\State.tsx":"26","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Project.tsx":"27","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\State.tsx":"28","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\FinishController.tsx":"29","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ModelCreationController.tsx":"30","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\index.tsx":"31","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\index.tsx":"32","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\State.tsx":"33","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\NewProjectButton\\index.tsx":"34","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataSet.tsx":"35","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIModel.tsx":"36","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Session.tsx":"37","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Countdown\\index.tsx":"38","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Title\\index.tsx":"39","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Title\\index.tsx":"40","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Diagram\\index.tsx":"41","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Input\\index.tsx":"42","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Input\\Labelling\\index.tsx":"43","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Title\\index.tsx":"44","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoadModelButton\\index.tsx":"45","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ConstantsText\\index.tsx":"46","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoginWindow\\index.tsx":"47","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\State.tsx":"48","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\State.tsx":"49","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Diagram\\index.jsx":"50","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\index.tsx":"51","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataRow.tsx":"52","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Label.tsx":"53","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\FinishButton\\index.tsx":"54","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\DownloadButton\\index.tsx":"55","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\EmailList\\index.tsx":"56","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\State.tsx":"57","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\DiagramList\\index.jsx":"58","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LinkText\\index.tsx":"59","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\QRImage\\index.tsx":"60","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ChangeToVisuBtn\\index.tsx":"61","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataPoint.tsx":"62","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\TimeSpan.tsx":"63","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ProjectList\\index.tsx":"64","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ModelCreationComponents\\Train\\index.tsx":"65","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ModelList\\index.tsx":"66"},{"size":419,"mtime":1613977999233,"results":"67","hashOfConfig":"68"},{"size":440,"mtime":1613146123200,"results":"69","hashOfConfig":"68"},{"size":3740,"mtime":1617719373892,"results":"70","hashOfConfig":"68"},{"size":3568,"mtime":1617719373895,"results":"71","hashOfConfig":"68"},{"size":9040,"mtime":1617719373894,"results":"72","hashOfConfig":"68"},{"size":4819,"mtime":1617721893712,"results":"73","hashOfConfig":"68"},{"size":18024,"mtime":1617721146210,"results":"74","hashOfConfig":"68"},{"size":1656,"mtime":1616080014535,"results":"75","hashOfConfig":"68"},{"size":3362,"mtime":1616594917990,"results":"76","hashOfConfig":"68"},{"size":1639,"mtime":1616515465217,"results":"77","hashOfConfig":"68"},{"size":3556,"mtime":1616515796161,"results":"78","hashOfConfig":"68"},{"size":2388,"mtime":1617721893713,"results":"79","hashOfConfig":"68"},{"size":9144,"mtime":1617719373895,"results":"80","hashOfConfig":"68"},{"size":2681,"mtime":1617721893713,"results":"81","hashOfConfig":"68"},{"size":7141,"mtime":1617721893716,"results":"82","hashOfConfig":"68"},{"size":11383,"mtime":1617727125311,"results":"83","hashOfConfig":"68"},{"size":4746,"mtime":1617719373900,"results":"84","hashOfConfig":"68"},{"size":4422,"mtime":1617719373899,"results":"85","hashOfConfig":"68"},{"size":3243,"mtime":1616594917995,"results":"86","hashOfConfig":"68"},{"size":14164,"mtime":1617008232089,"results":"87","hashOfConfig":"68"},{"size":7561,"mtime":1617721893723,"results":"88","hashOfConfig":"68"},{"size":5051,"mtime":1617719373910,"results":"89","hashOfConfig":"68"},{"size":967,"mtime":1616515796154,"results":"90","hashOfConfig":"68"},{"size":214,"mtime":1613280191746,"results":"91","hashOfConfig":"68"},{"size":2972,"mtime":1616594823036,"results":"92","hashOfConfig":"68"},{"size":581,"mtime":1616594917995,"results":"93","hashOfConfig":"68"},{"size":7569,"mtime":1616661814407,"results":"94","hashOfConfig":"68"},{"size":586,"mtime":1617719373909,"results":"95","hashOfConfig":"68"},{"size":4061,"mtime":1617721893714,"results":"96","hashOfConfig":"68"},{"size":2983,"mtime":1617721893715,"results":"97","hashOfConfig":"68"},{"size":2105,"mtime":1617721893725,"results":"98","hashOfConfig":"68"},{"size":1867,"mtime":1616999845242,"results":"99","hashOfConfig":"68"},{"size":846,"mtime":1617721893722,"results":"100","hashOfConfig":"68"},{"size":1346,"mtime":1616515796136,"results":"101","hashOfConfig":"68"},{"size":6212,"mtime":1616661660020,"results":"102","hashOfConfig":"68"},{"size":485,"mtime":1616514481828,"results":"103","hashOfConfig":"68"},{"size":1817,"mtime":1616592578281,"results":"104","hashOfConfig":"68"},{"size":1199,"mtime":1616920424425,"results":"105","hashOfConfig":"68"},{"size":452,"mtime":1616920424426,"results":"106","hashOfConfig":"68"},{"size":452,"mtime":1616920424432,"results":"107","hashOfConfig":"68"},{"size":4510,"mtime":1617721893721,"results":"108","hashOfConfig":"68"},{"size":4335,"mtime":1616920424432,"results":"109","hashOfConfig":"68"},{"size":3567,"mtime":1616999845240,"results":"110","hashOfConfig":"68"},{"size":452,"mtime":1616920424427,"results":"111","hashOfConfig":"68"},{"size":1395,"mtime":1617719373906,"results":"112","hashOfConfig":"68"},{"size":465,"mtime":1616920424429,"results":"113","hashOfConfig":"68"},{"size":2526,"mtime":1616920424430,"results":"114","hashOfConfig":"68"},{"size":276,"mtime":1613662337789,"results":"115","hashOfConfig":"68"},{"size":600,"mtime":1617721893724,"results":"116","hashOfConfig":"68"},{"size":4419,"mtime":1616594917983,"results":"117","hashOfConfig":"68"},{"size":2008,"mtime":1616999845242,"results":"118","hashOfConfig":"68"},{"size":3435,"mtime":1616589905949,"results":"119","hashOfConfig":"68"},{"size":1816,"mtime":1616661630268,"results":"120","hashOfConfig":"68"},{"size":469,"mtime":1616515796151,"results":"121","hashOfConfig":"68"},{"size":450,"mtime":1616515796118,"results":"122","hashOfConfig":"68"},{"size":6378,"mtime":1616920424427,"results":"123","hashOfConfig":"68"},{"size":698,"mtime":1616515796157,"results":"124","hashOfConfig":"68"},{"size":5982,"mtime":1616920424433,"results":"125","hashOfConfig":"68"},{"size":483,"mtime":1616920424429,"results":"126","hashOfConfig":"68"},{"size":312,"mtime":1616920424431,"results":"127","hashOfConfig":"68"},{"size":742,"mtime":1616920424428,"results":"128","hashOfConfig":"68"},{"size":931,"mtime":1615729730372,"results":"129","hashOfConfig":"68"},{"size":1409,"mtime":1615731483884,"results":"130","hashOfConfig":"68"},{"size":3994,"mtime":1617719373907,"results":"131","hashOfConfig":"68"},{"size":12840,"mtime":1617719373906,"results":"132","hashOfConfig":"68"},{"size":1450,"mtime":1616920424430,"results":"133","hashOfConfig":"68"},{"filePath":"134","messages":"135","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"fl9nei",{"filePath":"136","messages":"137","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"138","messages":"139","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"140"},{"filePath":"141","messages":"142","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"143","messages":"144","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"145","messages":"146","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"147"},{"filePath":"148","messages":"149","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"150"},{"filePath":"151","messages":"152","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"153","messages":"154","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"155"},{"filePath":"156","messages":"157","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"158","messages":"159","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"160","messages":"161","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"162","messages":"163","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"164"},{"filePath":"165","messages":"166","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"167","messages":"168","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"169","messages":"170","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"171","messages":"172","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"173"},{"filePath":"174","messages":"175","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"176","messages":"177","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"178","messages":"179","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"180"},{"filePath":"181","messages":"182","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"183","messages":"184","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"185","messages":"186","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"187","messages":"188","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"189","messages":"190","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"191"},{"filePath":"192","messages":"193","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"194","messages":"195","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"196"},{"filePath":"197","messages":"198","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"199","messages":"200","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"201","messages":"202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"203","messages":"204","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"205","messages":"206","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"207"},{"filePath":"208","messages":"209","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"210","messages":"211","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"212","messages":"213","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"214"},{"filePath":"215","messages":"216","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"217","messages":"218","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"219"},{"filePath":"220","messages":"221","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"222"},{"filePath":"223","messages":"224","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"225","messages":"226","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"227","messages":"228","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"229"},{"filePath":"230","messages":"231","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"232"},{"filePath":"233","messages":"234","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"235","messages":"236","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"237","messages":"238","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"239","messages":"240","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"241"},{"filePath":"242","messages":"243","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"244","messages":"245","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"246","messages":"247","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"248","messages":"249","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"250"},{"filePath":"251","messages":"252","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"253"},{"filePath":"254","messages":"255","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"256"},{"filePath":"257","messages":"258","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"259","messages":"260","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"261","messages":"262","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"263","messages":"264","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"265"},{"filePath":"266","messages":"267","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"268","messages":"269","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"270","messages":"271","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"272","messages":"273","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"274","messages":"275","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"276","messages":"277","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"278","messages":"279","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"280"},{"filePath":"281","messages":"282","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"283"},{"filePath":"284","messages":"285","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"286"},{"filePath":"287","messages":"288","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"289"},"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\reportWebVitals.ts",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\MainController.tsx",["290","291","292","293"],"import { PageController } from \"./PageController\";\r\nimport { RefferingController } from \"./ReferringController\";\r\nimport { MainControllerInterface } from \"./MainControllerInterface\";\r\nimport { States } from \"../view/pages/State\";\r\nimport { Facade } from \"../model/Facade\";\r\nimport { StartController } from \"./StartController\";\r\n\r\nimport dataDE from '../model/language/de.json';\r\nimport { AIController } from \"./AIController\";\r\n\r\n/**\r\n* Hauptverwalter der Anwendung. Enthält momentane Seite, die Fassade und verwaltet die Sprache.\r\n*/\r\nexport class MainController implements MainControllerInterface {\r\n  /**\r\n  * Fassade des Models\r\n  */\r\n  private facade: Facade;\r\n\r\n  /**\r\n  * Nach dem Singelton Muster enthält sich der Maincontroller genau einmal selber.\r\n  */\r\n  private static mainController: MainController;\r\n\r\n  /**\r\n  * Der momentane Seitencontroller\r\n  */\r\n  private currentPageController: PageController | undefined;\r\n\r\n  /**\r\n   * Konstruktor des MainControllers. Holt sich die Fassade.\r\n   */\r\n  constructor () {\r\n    this.facade = new Facade( \"de-de\" );\r\n  }\r\n\r\n  private languageCode: string = \"de-de\";\r\n\r\n  /**\r\n   * Gibt sich selber zurück und sorgt dafür das nur ein MainController besteht.\r\n   * @returns MainController\r\n   */\r\n  static getInstance () {\r\n    if ( this.mainController === undefined ) {\r\n      this.mainController = new MainController();\r\n      return this.mainController;\r\n    }\r\n    return this.mainController;\r\n  }\r\n\r\n\r\n  /**\r\n   * Prüft ob der Benutzer angemeldet ist.\r\n   * @returns Gibt true zurück falls der Benutzer angemeldet ist, sonst wird false zurück gegeben.\r\n   */\r\n  checkLoginStatus () {\r\n    return false;//this.facade.checkLogin();\r\n  }\r\n\r\n  /**\r\n   * Setzt den momentanen Seitenverwalter neu\r\n   * @param destinationPageController Der neue Seitenverwalter\r\n   */\r\n  changeTo ( destinationPageController: PageController ) {\r\n    this.currentPageController = destinationPageController;\r\n  }\r\n\r\n  /**\r\n   * Andwendungstart, entscheidet durch die URL ob es sich um Desktop oder Smartphone handelt\r\n   */\r\n  startApp () {\r\n    const queryString = window.location.search;\r\n    let urlParams = new URLSearchParams( queryString );\r\n    if ( urlParams.get( \"isMiner\" ) === \"true\" ) {\r\n      this.currentPageController = new StartController();\r\n    }\r\n    if ( urlParams.get( \"deliverModel\" ) === \"true\" ) {\r\n      let modelID: number = +urlParams.get( \"modelID\" )!;\r\n      this.currentPageController = new AIController( modelID );\r\n    }\r\n    else {\r\n      this.currentPageController = new RefferingController();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns Gibt die Fassade zurück\r\n   */\r\n  getFacade () {\r\n    return this.facade;\r\n  }\r\n\r\n  /**\r\n   * @param ids Alle ids, zu denen man die Texte möchte.\r\n   * @returns Gibt alle texte zu den übergebenen ids zurück.\r\n   */\r\n  getMessage ( messages: { text: string, id: number; }[] ) {\r\n    return [ { text: \"null\", id: -1 } ];\r\n    let messageIDs: number[] = [];\r\n    for ( let index = 0; index < messages.length; index++ ) {\r\n      messageIDs.push( messages[ index ].id );\r\n    }\r\n    let texts: string[] = [];\r\n    for ( let index = 0; index < messages.length; index++ ) {\r\n      messages[ index ].text = texts[ index ];\r\n      return messages;\r\n    }\r\n  }\r\n\r\n  getText () {\r\n    switch ( this.languageCode ) {\r\n      case \"de-de\":\r\n        return dataDE;\r\n        break;\r\n\r\n      default:\r\n        return dataDE;\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param languageCode Das Sprachkürzel als string.\r\n   * @returns Gibt true zurück falls der wechsel erfolgt ist, sonst false.\r\n   */\r\n  setLanguage ( languageCode: string ) {\r\n    this.languageCode = languageCode;\r\n  }\r\n\r\n  getLanguageCode () {\r\n    return this.languageCode;\r\n  }\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\StartController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ReferringController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\AIController.tsx",["294"],"import { Page } from \"../view/pages/PageInterface\";\r\nimport { StartPage } from \"../view/pages/StartPage\";\r\nimport { DataCollectionPage } from \"../view/pages/DataCollectionPage/index\";\r\nimport { FinishPage } from \"../view/pages/FinishPage/index\";\r\nimport { IState, States } from \"../view/pages/State\";\r\nimport { PageController } from \"./PageController\";\r\nimport { SensorManager } from \"./SensorManager\";\r\nimport { MainController } from \"./MainController\";\r\n\r\n\r\n/**\r\n* Controller welcher für die Klassifizierung verantworlich ist.\r\n*/\r\nexport class AIController implements PageController {\r\n    private modelID: number = -1;\r\n    /**\r\n    * Für die Verwaltung der Sensoren verantwortlich\r\n    */\r\n    private sensorManager: SensorManager;\r\n    /**\r\n    * Seite welche gerade von dem Controller verwaltet wird\r\n    */\r\n    private page: Page = new StartPage( \"Willkomen!\" );\r\n    /**\r\n    * Status der Seite\r\n    */\r\n    private state: IState;\r\n    /**\r\n    * Die Attribute welche aus der URL genommen werden. Sollten aiID und Sensor Typen beinhalten\r\n    */\r\n    private urlParams: URLSearchParams;\r\n\r\n    /**\r\n    * Der Constructor des Controllers verarbeitet die URL bereitet den Sensormanager vor und setzt die startpage auf.\r\n    */\r\n    constructor ( modelID: number ) {\r\n        const queryString = window.location.search;\r\n        this.urlParams = new URLSearchParams( queryString );\r\n        this.sensorManager = new SensorManager();\r\n        this.page.attach( this );\r\n        this.state = this.page.getState();\r\n        //TODO Beim Registrieren des AIModelUsers sollte der Name weg oder eine Möglichkeit bestehen den Namen zu beziehen\r\n        MainController.getInstance().getFacade().registerAIModelUser( \"Gustav\", +this.urlParams.get( \"aiID\" )! );\r\n        this.modelID = modelID;\r\n    }\r\n\r\n    /**\r\n     * Die Update Methode des Seitenverwalters.\r\n     */\r\n    update () {\r\n        this.state = this.page.getState();\r\n        switch ( this.state.currentState ) {\r\n            case States.StartDataRead:\r\n                this.start();\r\n                break;\r\n            case States.SetLanguage:\r\n                this.page.setState( MainController.getInstance().setLanguage( this.state.languageCode ) );\r\n                break;\r\n            case States.NeedMessage:\r\n                this.state.messages = MainController.getInstance().getMessage( this.state.messages )!;\r\n                this.state.currentState = States.waitForDB;\r\n                this.page.setState( this.state );\r\n                break;\r\n            case States.StartDataRead:\r\n                this.sensorManager.readData( this.page );\r\n                this.changeToFinish();\r\n                break;\r\n            case States.ClassifyResult:\r\n                this.classifyResult();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Holt sich alle wichtigen Daten für die Datenaufnahme aus der momentanen Seite. Darauf wird mit dem Sensormanager\r\n     * die Datenaufnahme initialisiert. Zum Schluss wird der Seitenwechsel zur Erfassungseite durchgeführt. \r\n     */\r\n    private start () {\r\n        let sensorTypes: number[] = this.urlParams.get( \"sensorTypes\" )!.split( \",\" ).map( x => +x );\r\n        let dataSetName: string = \"Undefined\";\r\n        let waitTime = this.state.recordingSettings!.waitTime;\r\n        let readTime = this.state.recordingSettings!.readTime;\r\n        this.sensorManager.setUpDataRead( sensorTypes, dataSetName, waitTime, readTime, false );\r\n        this.page = new DataCollectionPage();\r\n        this.page.attach( this );\r\n        this.state = this.page.getState();\r\n    }\r\n\r\n    /**\r\n     * Wechselt nach der Aufnahme des Datensatzes zur FinishPage.\r\n     */\r\n    //TODO Seite sollte für den AIModelUser noch angepasst werden. Hier wird ja nur Klassifiziert.\r\n    private changeToFinish () {\r\n        this.page = new FinishPage();\r\n        this.page.attach( this );\r\n        this.state = this.page.getState();\r\n        this.state.dataRows! = MainController.getInstance().getFacade().getCurrentDataRows()!.dataRows!;\r\n        this.page.setState( this.state );\r\n    }\r\n\r\n    /**\r\n     * Klassifiziert den Datensatz.\r\n     */\r\n    private classifyResult () {\r\n        let id: number = MainController.getInstance().getFacade().getDataSetMetas()[ 0 ].dataSetID;\r\n        MainController.getInstance().getFacade().classify( +this.urlParams.get( \"aiID\" )!, id, this.callback );\r\n    }\r\n\r\n    /**\r\n     * Die Methode wird durch das Model aufgerufen falls ein Ergebnis der Klassifiziereung vorhanden ist.\r\n     */\r\n    public callback ( prediction: any, ) {\r\n        this.state.aiUserData!.result = prediction;\r\n        this.state.currentState = States.ClassifyResult;\r\n        this.page.setState( this.state );\r\n        let R: any;\r\n        return R;\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Facade.tsx",["295","296"],"import { DeliveryFormat } from \"./DeliveryFormat\";\r\nimport { DatabaseConnector } from \"./DatabaseConnector\";\r\nimport { Language } from \"./Language\";\r\nimport { Admin, Dataminer, AIModelUser, User } from \"./User\";\r\nimport { AIBuilder } from \"./AIBuilder\";\r\nimport { AIDistributor } from \"./AIDistributor\";\r\nimport { AccelerometerData, GyroscopeData, SensorData } from \"./SensorData\";\r\nimport { isBreakStatement } from \"typescript\";\r\n\r\ninterface FacadeInterface {\r\n  createDataSet(sensorTypes: string[], dataSetName: string): boolean;\r\n  sendDataPoint(dataRowID: number, value: number[]): boolean;\r\n  readDataPoint(dataRowID: number): object;\r\n  loadProject(projectID: number): boolean;\r\n  getProjectMetas(): string[];\r\n  getDataSetMeta(): string[];\r\n  getSessionID(): number;\r\n  getDataRows(dataSetID: number): number[][][];\r\n  getCurrentDataRows(): { value: number, relativeTime: number; }[];\r\n  getMessage(messageID: number): string;\r\n  setLanguage(languageCode: string): boolean;\r\n  getLanguageMetas(): object[];\r\n  getEmail(): string;\r\n  deleteDataSet(dataSetID: number): boolean;\r\n  registerAdmin(adminName: string, email: string, password: string): boolean;\r\n  registerDataminer(dataminerName: string, sessionID: number): boolean;\r\n  registerAIModelUser(aiModelUserName: string): boolean;\r\n  loginAdmin(email: string, password: string): boolean;\r\n  logoutAdmin(): boolean;\r\n  createProject(projectName: string): boolean;\r\n  setLabel(labelID: number, start: number, end: number): boolean;\r\n  createLabel(): number; //labelid von datenbank\r\n  getLabels(): object[];\r\n  checkLogin(): boolean;\r\n  classify(aiId: number, dataSetId: number, callBack: Function): void;\r\n  getAIModel(format: DeliveryFormat): object;\r\n  applyModel(modeldata: object): void;\r\n} export type { FacadeInterface };\r\n\r\n/**\r\n * Die Facade stellt alle interaktionen mit dem Model zur Verfügung\r\n */\r\nexport class Facade {\r\n  private language?: Language; //Alle Nachrichten, in der geladenen Sprache\r\n  private dbCon: DatabaseConnector; //Die Verbindung zur Datenbank\r\n  private user?: User; //Der Benutzer, entweder Admin, Datenerfasser oder AIModelUser\r\n\r\n\r\n  /**\r\n   * Erstellt die Facade\r\n   * @param languageCode der Sprachcode von der Sprache, die geladen werden soll\r\n   */\r\n  constructor(languageCode: string) {\r\n    this.dbCon = new DatabaseConnector();\r\n    this.dbCon.loadLanguage({ languageCode }).then((language: string[]) => { this.language = new Language(language); });\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein Datensatz\r\n   * @param sensorTypeID muss der Sensor Typ ID von einem Sensor des Gerätes übereinstimmen\r\n   * @param dataSetName Name des Datensatzes\r\n   * @returns true, wenn der Datensatz erstellt wurde. Dies ist der Fall, wenn ein Benutzer existiert welcher in einer Session ist und alle Sensortypen existieren.\r\n   */\r\n  async createDataSet(sensorTypeID: number[], dataSetName: string, datarowNames?: string[]): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let sessionID: number = this.getSessionID();\r\n      if (sessionID >= 0) {\r\n        let projectID: number = this.user.getCurrentProjectID();\r\n        let userID: number = this.user.getID();\r\n        let dataRow: { sensorID: number, datarowName?: string; }[] = [];\r\n        for (let i = 0; i < sensorTypeID.length; i++) {\r\n          let sensorID = sensorTypeID[i];\r\n          if (datarowNames != null && datarowNames.length >= i) {\r\n            dataRow.push({ sensorID, datarowName: datarowNames[i] });\r\n          } else {\r\n            dataRow.push({ sensorID });\r\n          }\r\n        }\r\n        let dataSetID: number = await this.dbCon.createDataSet({ sessionID, projectID, userID, dataSetName, dataRow });\r\n        if (dataSetID >= 0) {\r\n          ///////////////////////////////DUMMY\r\n          var sensoren: SensorData[] = [];\r\n          for (let i = 0; i < sensorTypeID.length; i++) {\r\n            switch (sensorTypeID[i]) {\r\n              case 2:\r\n                sensoren.push(new AccelerometerData(-1, \"\", \"\"));\r\n                break;\r\n              case 3:\r\n                sensoren.push(new GyroscopeData(-1, \"\", \"\"));\r\n                break;\r\n            }\r\n          }\r\n          return this.user.createDataSet(sensoren, dataSetID, dataSetName);\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Sendet den Datenpunkt an die Datenbank ////////////////////////////////////////////////////////////////////////////////////////////Daten noch in Model speichern\r\n   * @param dataRowID die ID der aktuellen Datenreihe des eingelesenen Datenpunkts\r\n   * @param value der SensorWert\r\n   * @param relativeTime die relative Zeit zum Aufnahmestart in Millisekunden\r\n   * @return true, wenn der Datenpunkt erfolgreich an die Datenbank gesendet wurde\r\n   */\r\n  async sendDataPoint(dataRowID: number, datapoint: { value: number[], relativeTime: number; }): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let sessionID: number = this.getSessionID();\r\n      let userID: number = this.user.getID();\r\n      let dataSetID: number = this.user.getCurrentDataSetID();\r\n      this.user.addDatapoint(dataRowID, datapoint);\r\n      return this.dbCon.sendDataPoint({ sessionID, userID, dataSetID, dataRowID, datapoint });\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Lädt aus der Datenbank das Projekt mit der übergebenen ID, hierfür muss der Admin angemeldet sein\r\n   * @param projectID die Projekt ID oder keine falls das aktuelle Projekt neu geladen werden soll\r\n   * @returns true, wenn das Projekt erfolgreich geladen wurde dies tritt nur ein, wenn eine Verbindung zur Datenbank besteht,\r\n   *          die Projekt ID existiert und der Admin dafür angemeldet ist\r\n   */\r\n  async loadProject(projectID?: number): Promise<boolean> {\r\n    if (this.user != null && this.user instanceof Admin) {\r\n      if (projectID == null) {\r\n        projectID = this.user?.getCurrentProjectID();\r\n      }\r\n      let adminEmail: string = this.user.getEmail();\r\n      let userID: number = this.user.getID();\r\n      return this.user.loadProject(await this.dbCon.loadProject({ userID, adminEmail, projectID }));\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Lädt vom aktuell angemeldeten Admin von seinen Projekten den Namen und die die Projekt ID\r\n   * @returns Von allen Projekten des Admins Projekt ID und Projektname\r\n   */\r\n  async getProjectMetas(): Promise<{ projectID: number, projectName: string, AIModelID: number[]; }[]> {\r\n    if (this.user != null) {\r\n      let userID: number = this.user.getID();\r\n      return await this.dbCon.getProjectMetas({ userID, adminEmail: this.getAdminEmail() });\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt von allen Datensätzen die Datensatz ID und der Datensatz Name zurück\r\n   */\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[] {\r\n    if (this.user != null) {\r\n      return this.user.getDataSetMetas();\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID des aktuellen Projekts zurück, -1 falls kein aktuelles Projekt existiert\r\n   */\r\n  getSessionID(): number {\r\n    if (this.user != null) {\r\n      return this.user.getSessionID();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getDataRows(dataSetID);\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen des aktuellen Datensatzes zurück\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getCurrentDataRows();\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt aus der geladenen Sprache die Nachrichten die über die IDs angegeben werden\r\n   * @param messageID alle IDs, von denen die Sprachnachricht geladen werden soll\r\n   * @returns alle Nachrichten, in der gleichen Reihenfolge wie angefordert\r\n   */\r\n  getMessage(messageID: number[]): { messageID: number, message: string; }[] {\r\n    if (this.language != null) {\r\n      return this.language.getMessage(messageID);\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Gibt die auswählbaren Sensoren als ID mit ihrer Art in der Passenden Sprache zurück\r\n  \r\n  getAvailableSensors(): { sensorTypID: number, sensorType: string; }[] {\r\n    if (this.user != null && this.language != null) {\r\n      var sensors: { sensorTypID: number, sensorType: string; }[] = [];\r\n      let message: { messageID: number, message: string; }[] = this.language.getMessage(this.user.getAvailableSensors());\r\n      for (let i = 0; i < message.length; i++) {\r\n        sensors.push({ sensorTypID: message[i].messageID, sensorType: message[i].message });\r\n      }\r\n      return sensors;\r\n    }\r\n    return [];\r\n  }\r\n */\r\n  /**\r\n   * Lädt die Sprache aus der Datenbank mit dem übergebenen Sprachcode\r\n   * @param languageCode Sprachcode\r\n   * @returns true, falls die Sprache erfolgreich geladen wurde\r\n   */\r\n  async setLanguage(languageCode: string): Promise<boolean> {\r\n    if (this.language == null) {\r\n      const language: string[] = await this.dbCon.loadLanguage({ languageCode });\r\n      this.language = new Language(language);\r\n      return true;\r\n    } else if (languageCode != this.language.getLanguageCode()) {\r\n      const language: string[] = await this.dbCon.loadLanguage({ languageCode });\r\n      return this.language.setLanguage(language);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gibt von allen in der Datenbank verfügbaren Sprachen den Sprachcode sowie den Sprachennamen zurück\r\n   */\r\n  getLanguageMetas(): Promise<{ languageCode: number, languageName: string; }[]> {\r\n    return this.dbCon.getLanguageMetas();\r\n  };\r\n\r\n  /**\r\n   * Gibt die Email vom Admin zurück, diese kann leer sein falls kein Admin angemeldet ist\r\n   */\r\n  getAdminEmail(): string {\r\n    if (this.user instanceof Admin) {\r\n      return this.user.getEmail();\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Löscht den Datensatz mit der übergebenen Datensatz ID\r\n   * @param dataSetID die Datensatz ID\r\n   * @returns true, wenn das löschen erfolgreich ist\r\n   */\r\n  async deleteDataSet(dataSetID: number): Promise<boolean> {\r\n    if (this.user != null && this.user.deleteDataSet(dataSetID)) {\r\n      let projectID: number = this.user.getCurrentProjectID();\r\n      if (projectID >= 0) {\r\n        let adminEmail: string = this.getAdminEmail();\r\n        let userID = this.user.getID();\r\n        return this.dbCon.deleteDataSet({ userID, adminEmail, projectID, dataSetID });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  //wann Device erstellen ??? + constructor in User anpassen mit neuem Device parameter \r\n  async registerAdmin(adminName: string, adminEmail: string, password: string): Promise<boolean> {\r\n    //TODO Device\r\n    let device: { deviceID?: number, deviceName: string, deviceType: string, firmware: string, generation: string, MACADRESS: string, sensorInformation: { sensorTypeID: number, sensorName: string, sensorUniqueID: number; }[]; } = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let IDs: { adminID: number, device: { deviceID: number, sensorID: number[]; }; } = await this.dbCon.registerAdmin({ adminName, adminEmail, password, device });\r\n    if (IDs.adminID >= 0) {\r\n      this.user = new Admin(IDs.adminID, IDs.device.deviceID, adminName, adminEmail);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async registerDataminer(dataminerName: string, sessionID: number): Promise<boolean> {\r\n    //TODO Device\r\n    let device: { deviceID?: number, deviceName: string, deviceType: string, firmware: string, generation: string, MACADRESS: string, sensorInformation: { sensorTypeID: number, sensorName: string, sensorUniqueID: number; }[]; } = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let dataminer: { dataminerID: number, device: { deviceID: number, sensorID: number[]; }, project: { projectID: number, projectName: string, sessionID: number; }; } = await this.dbCon.registerDataminer({ dataminerName, sessionID, device });\r\n    if (dataminer.dataminerID >= 0 && dataminer.device.deviceID >= 0) {\r\n      this.user = new Dataminer(dataminer.dataminerID, dataminer.device.deviceID, dataminerName);\r\n      this.user.loadProject(dataminer.project);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param aiModelUserName \r\n   */\r\n  async registerAIModelUser(aiModelUserName: string, modelID: number): Promise<boolean> {\r\n    //TODO Device\r\n    let device: { deviceID?: number, deviceName: string, deviceType: string, firmware: string, generation: string, MACADRESS: string, sensorInformation: { sensorTypeID: number, sensorName: string, sensorUniqueID: number; }[]; } = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let aiModelUser: { aiModelUserID: number, device: { deviceID: number, sensorID: number[]; }, project: { projectID: number, projectName: string, sessionID: -1; }; } = await this.dbCon.registerAIModelUser({ aiModelUserName, modelID, device });\r\n    if (aiModelUser.aiModelUserID >= 0 && aiModelUser.device.deviceID >= 0) {\r\n      this.user = new AIModelUser(aiModelUser.aiModelUserID, aiModelUser.device.deviceID, aiModelUserName);\r\n      this.user.loadProject(aiModelUser.project);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //TODO Device\r\n  async loginAdmin(adminEmail: string, password: string): Promise<boolean> {\r\n    if (this.user == null) {\r\n      let adminData: { admin: { adminID: number, deviceID: number, adminName: string, email: string, device: { deviceID?: number, deviceName: string, deviceType: string, firmware: string, generation: string, MACADRESS: string, sensorInformation: { sensorTypeID: number, sensorName: string, sensorUniqueID: number; }[]; }; }; } = await this.dbCon.loginAdmin({ adminEmail, password });\r\n      if (adminData.admin != null && adminData.admin.adminID !== -1) {\r\n        let admin = adminData.admin;\r\n        this.user = new Admin(admin.adminID, admin.deviceID, admin.adminName, admin.email, admin.device);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /* eventuell implementieren\r\n    logoutAdmin(): boolean {\r\n      if (this.user != null) {\r\n        let logout = this.dbCon.logoutAdmin(this.getAdminEmail());\r\n        if (logout) {\r\n          delete this.user;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    */\r\n\r\n  async createProject(projectName: string): Promise<boolean> {\r\n    if (this.user instanceof Admin) {\r\n      let userID = this.user.getID();\r\n      let adminEmail = this.getAdminEmail();\r\n      let project: { projectID: number, sessionID: number; } = await this.dbCon.createProject({ userID, adminEmail, projectName });\r\n      return this.user.createProject(project.projectID, project.sessionID, projectName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async createLabel(span: { start: number, end: number; }, labelName: string): Promise<number> {\r\n    if (this.user != null) {\r\n      let sessionID: number = this.getSessionID();\r\n      let userID: number = this.user.getID();\r\n      let datasetID: number = this.user.getCurrentDataSetID();\r\n      let labelID: number = await this.dbCon.createLabel({ sessionID, userID, datasetID, label: { span, labelName } });\r\n      if (labelID >= 0) {\r\n        let created: boolean = this.user.createLabel(labelID, span, labelName);\r\n        if (created) {\r\n          return labelID;\r\n        }\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  async setLabel(labelID: number, span: { start: number, end: number; }, labelName?: string): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let setted: boolean = this.user.setLabel(labelID, span, labelName);\r\n      if (setted) {\r\n        let sessionID: number = this.getSessionID();\r\n        let userID: number = this.user.getID();\r\n        let datasetID: number = this.user.getCurrentDataSetID();\r\n        return this.dbCon.setLabel({ sessionID, userID, datasetID, label: { labelID, span, labelName } });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async deleteLabel(labelID: number): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let deleted: boolean = this.user.deleteLabel(labelID);\r\n      if (deleted) {\r\n        let sessionID: number = this.getSessionID();\r\n        let userID: number = this.user.getID();\r\n        let dataSetID: number = this.user.getCurrentDataSetID();\r\n        return this.dbCon.deleteLabel({ sessionID, userID, dataSetID, labelID });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  getLabels(): { labels: { name: string, labelID: number, start: number, end: number; }[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getLabels();\r\n    }\r\n    return { labels: [] };\r\n  }\r\n\r\n  classify(aiId: number, dataSetId: number, callBack: <R = unknown>(prediction: string | object) => R): void {\r\n    let aiBuilder = new AIBuilder(aiId);\r\n    aiBuilder.classify(dataSetId, callBack);\r\n  };\r\n\r\n  getAIModel(id: number, format: DeliveryFormat): object {\r\n    let aiDist = new AIDistributor(id, format);\r\n    return aiDist.getAIModel();\r\n  }\r\n\r\n  applyModel(trainingParameter: { dataSets: number[], imputator: string, classifier: string, scaler: string, features: string[], trainingDataPercentage?: number, slidingWindowSize?: number, slidingWindowStep?: number; }): void {\r\n    let aiBuilder = new AIBuilder(-1);\r\n    aiBuilder.applyModel(trainingParameter);\r\n  }\r\n\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Language.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\index.tsx",["297","298"],"import Title from '../../components/DataCollectionComponents/Title';\r\nimport Countdown from '../../components/DataCollectionComponents/Countdown';\r\nimport Diagram from '../../components/DataCollectionComponents/Diagram';\r\nimport { Page } from \"../PageInterface\";\r\nimport { PageController } from \"../../../controller/PageController\";\r\nimport { State } from \"./State\";\r\nimport ReactDOM from 'react-dom';\r\nimport { States } from '../State';\r\nimport { NotificationContainer, NotificationManager } from 'react-notifications';\r\nimport 'react-notifications/lib/notifications.css';\r\n\r\n/**\r\n * Darstellungsseite der Datenerfassungsseite\r\n */\r\nexport class DataCollectionPage implements Page {\r\n    state = new State;\r\n    observers: PageController[] = [];\r\n\r\n    /**\r\n    * Konstruktor der Darstellungsseite.\r\n    */\r\n    constructor () {\r\n        this.state = new State();\r\n    }\r\n\r\n    /**\r\n    * Update Methode der Darstellungsseite. Diese Methode wird nach jeder Änderung, die kein Seitenwechsel ist, aufgerufen. \r\n    * Die Methode enthält den Aufbau der Seite und wird von ihr gerendert.\r\n    * Es werden durch notify() alle controller über ein Update informiert und alle Seiten Elemente werden aktualisiert und erneut gerendert. \r\n    */\r\n    private update () {\r\n        this.notify();\r\n        const VDOM = (\r\n            <div>\r\n                <Title />\r\n                <Countdown countdownNumber={ this.state.recordingSettings?.waitTime! } chosenSensors={ this.state.recordingSettings?.usedSensorTypes! } />\r\n                <Diagram dataRows={ this.state.dataRows! } pageChangeToFinish={ this.changeToFinish.bind( this ) } />\r\n                <NotificationContainer />\r\n            </div>\r\n        );\r\n        if (document.getElementById( 'root' ) !== null) {\r\n            ReactDOM.render( VDOM, document.getElementById( 'root' ) );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wechsel der Seite zur Fertigungsseite.\r\n     */\r\n    private changeToFinish () {\r\n        this.state.currentState = States.ChangeToFinish;\r\n        this.notify(); // Kein Update, da sonst die Seite neu rendert und der Seitenwechsel fehlschlägt\r\n    }\r\n\r\n    /**\r\n    * Durch diese Methode kann sich ein Controller als Beobachter anmelden.\r\n    * @param oberver neuer Beobachter\r\n    */\r\n    attach ( observer: PageController ) {\r\n        this.observers.push( observer );\r\n    }\r\n\r\n    /**\r\n    * Durch diese Methode kann sich ein Controller als Beobachter abmelden.\r\n    * @param oberver Beobachter der zu entfernen ist\r\n    */\r\n    detach ( observer: PageController ) {\r\n        const index = this.observers.indexOf( observer, 0 );\r\n        if ( index > -1 ) {\r\n            this.observers.splice( index, 1 );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Durch diese Methode werden alle Beobachter über eine Änderung auf der Seite informiert.\r\n    */\r\n    notify () {\r\n        for ( let index = 0; index < this.observers.length; index++ ) {\r\n            const element = this.observers[ index ];\r\n            element.update();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Gibt den Status der Seite zurück\r\n    */\r\n    setState ( state: any ) {\r\n        this.state = state;\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Setzt einen neuen Zustand für die Seite und aktualisiert sie\r\n     * @param state neuer Zustand für die Seite\r\n     */\r\n    getState () {\r\n        return this.state;\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\SensorData.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DataCollectionController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\SensorManager.tsx",["299"],"import { MainController } from \"./MainController\";\r\nimport { Page } from \"../view/pages/PageInterface\";\r\nimport { IState, States } from \"../view/pages/State\";\r\nimport { Facade } from \"../model/Facade\";\r\n\r\nexport class SensorManager {\r\n    private currentSensors: Sensor[] = [];\r\n    //private currentSensorIDs: number[] = [];\r\n    private facade: Facade = MainController.getInstance().getFacade();\r\n    private waitTime: number = 5;\r\n    private readTime: number = 10;\r\n    private startTime: number = 10;\r\n    private saving: boolean = true;\r\n    private page: Page | undefined = undefined;\r\n    private sensorTypes: number[] = [];\r\n    private dataPoints: { rowId: number, sensorType: number, value: number[]; relativeTime: number; }[] = [];\r\n    private dataRows: { sensorType: number, datapoint: { value: number[]; relativeTime: number; }[]; }[] = [];\r\n\r\n    /**\r\n    * Erzeugt eine neue Datenreihe und setzt diese damit als momentan benutzte Datenreihe. \r\n    * @param sensorTypes Die Angabe der zu benutzenden Sensoren. Die position im Array bestimmt die DataRow ID jedes Sensors.\r\n    * @returns Gibt true für ein erfolgreiches Erstellen eines Dataensatzes zurück, gibt sonst false zurück.\r\n    */\r\n    setUpDataRead ( sensorTypes: number[], dataSetName: string, waitTime: number, readTime: number, saving: boolean ) {\r\n        //this.currentSensorIDs = sensorTypes;\r\n        // this.waitTime = waitTime * this.TO_SECOND;\r\n        //this.readTime = readTime * this.TO_SECOND;\r\n        //this.startTime = readTime * this.TO_SECOND;\r\n        this.waitTime = waitTime;\r\n        this.readTime = readTime;\r\n        this.saving = saving;\r\n        this.sensorTypes = sensorTypes;\r\n        for ( let index = 0; index < sensorTypes.length; index++ ) {\r\n            switch ( sensorTypes[ index ] ) {\r\n                case 2:\r\n                    let accSensor = new Accelerometer( { frequency: 60 } );\r\n                    this.currentSensors.push( accSensor );\r\n                    accSensor.addEventListener( 'reading', e => {\r\n                        this.getData( accSensor, index, sensorTypes[ index ] );\r\n                    } );\r\n                    accSensor.addEventListener( 'error', event => {\r\n                        console.log( event.error.name, event.error.message );\r\n                    } );\r\n                    break;\r\n                case 3:\r\n                    let gyroSensor = new Gyroscope( { frequency: 60 } );\r\n                    this.currentSensors.push( gyroSensor );\r\n                    gyroSensor.addEventListener( 'reading', e => {\r\n                        this.getData( gyroSensor, index, sensorTypes[ index ] );\r\n                    } );\r\n                    gyroSensor.addEventListener( 'error', event => {\r\n                        console.log( event.error.name, event.error.message );\r\n                    } );\r\n                    break;\r\n                case 4:\r\n                    let magSensor = new Magnetometer( { frequency: 60 } );\r\n                    this.currentSensors.push( magSensor );\r\n                    magSensor.addEventListener( 'reading', e => {\r\n                        this.getData( magSensor, index, sensorTypes[ index ] );\r\n                    } );\r\n                    magSensor.addEventListener( 'error', event => {\r\n                        console.log( event.error.name, event.error.message );\r\n                    } );\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        return ( this.facade.createDataSet( sensorTypes, dataSetName ) );\r\n    }\r\n\r\n    /**\r\n    * Erfasst für den momentanene Datensatz Daten und sendet diese an die Explorer Datenbank.\r\n    * Wartet zuerst für die angegebene Wartezeit und nimmt dann für die angegeben Lesezeit daten auf.\r\n    */\r\n    readData ( page: Page ) {\r\n        this.page = page;\r\n        let state: IState = page.getState();\r\n        state.recordingSettings!.usedSensorTypes = this.sensorTypes;\r\n        state.currentState = States.waitForDB;\r\n        page.setState( state );\r\n        //Warte für waitTime und update dabei die Seite\r\n        let intervalId1 = setInterval( () => {\r\n            this.waitTime = this.waitTime - 1;\r\n            state.recordingSettings!.waitTime = this.waitTime;\r\n            //state.currentState = States.SetWaitTime;\r\n            page.setState( state );\r\n            if ( this.waitTime === 0 ) {\r\n                clearInterval( intervalId1 );\r\n                this.startTime = new Date().getTime();\r\n                for ( let index = 0; index < this.currentSensors.length; index++ ) {\r\n                    this.currentSensors[ index ].start();\r\n                }\r\n                //Nimm Daten auf verteile sie an die Seite und das Modell. Erneuere dabei die aufnahmezeit auf der Seite\r\n                let intervalId2 = setInterval( () => {\r\n                    this.readTime = this.readTime - 1;\r\n                    while ( this.dataPoints.length > 0 ) {\r\n                        let newDataPoint = this.dataPoints.shift()!;\r\n                        state.dataPoints!.push( newDataPoint );\r\n                        MainController.getInstance().getFacade().sendDataPoint( newDataPoint.rowId, { value: newDataPoint.value, relativeTime: newDataPoint.relativeTime } );\r\n                        page.setState( state );\r\n                    }\r\n                    if ( this.readTime === 0 ) {\r\n                        clearInterval( intervalId2 );\r\n                        for ( let index = 0; index < this.currentSensors.length; index++ ) {\r\n                            this.currentSensors[ index ].stop();\r\n                        }\r\n                    }\r\n                }, 1000 );\r\n            }\r\n        }, 1000 );\r\n    }\r\n\r\n    private saveDatapointinRow ( dataPoint: { rowId: number, sensorType: number, value: number[]; relativeTime: number; } ) {\r\n        while ( this.dataRows.length - 1 < dataPoint.rowId ) {\r\n            this.dataRows.push( { sensorType: -1, datapoint: [] } );\r\n        }\r\n        this.dataRows[ dataPoint.rowId ].sensorType = dataPoint.sensorType;\r\n        this.dataRows[ dataPoint.rowId ].datapoint.push( { value: dataPoint.value, relativeTime: dataPoint.relativeTime } );\r\n\r\n        if ( this.page != undefined ) {\r\n            let state = this.page.getState();\r\n            state.dataRows = this.dataRows;\r\n            this.page.setState( state );\r\n        }\r\n\r\n        //PubSub.publish( 'startDiagram', this.dataRows );\r\n        //PubSub.publish( 'finishDiagram', this.dataRows );\r\n    }\r\n\r\n    /**\r\n     * @returns Gibt als Zahl die Zeit in Sekunden zurück, für welche vor der Aufnahme gewartet wird. \r\n     */\r\n    getWaitTime () {\r\n        return this.waitTime;\r\n    }\r\n\r\n    /**\r\n     * @returns Gibt als Zahl die Zeit in Sekunden zurück, für welche die Aufnahme läuft. \r\n     */\r\n    getReadTime () {\r\n        return this.readTime;\r\n    }\r\n\r\n    /**\r\n    * Holt die Sensordaten für einen Sensor\r\n    * @param sensor der Sensor von dem die Daten gelsen werden\r\n    * @param sensorType Die ID des Sensortypes\r\n    */\r\n    private getData ( sensor: Magnetometer | Gyroscope | Accelerometer, rowId: number, sensorType: number ) {\r\n        const point = { rowId, sensorType, value: [ sensor.x!, sensor.y!, sensor.z! ], relativeTime: ( new Date().getTime() - this.startTime ) / 1000 };\r\n        this.dataPoints.push( point );\r\n        this.saveDatapointinRow( point );\r\n    }\r\n\r\n    /**\r\n    * Prüft welche Sensoren verfügbar sind.\r\n    * @returns ein Array welches alle SensorTypeIDs enthält die verfügbar sind\r\n    */\r\n    async getAvailableSensors (): Promise<{ sensorTypID: number; sensorType: string; }[]> {\r\n        let sensors: { sensorTypID: number; sensorType: string; }[] = [];\r\n\r\n\r\n        // sensors.push({ sensorTypID: 2, sensorType: \"Accelerometer\" }); //Nur test\r\n        // return sensors;//Nur test\r\n\r\n\r\n        let accelerometer = new Accelerometer( { frequency: 60 } );\r\n        let accelerometerExist = this.existSensor( accelerometer );\r\n        let gyroscope = new Gyroscope( { frequency: 60 } );\r\n        let gyroscopeExist = this.existSensor( gyroscope );\r\n        /*let magnetometer = new Magnetometer();            Nicht definiert?\r\n        let magnetometerExist = this.test(magnetometer);*/\r\n\r\n        if ( await accelerometerExist ) {\r\n            sensors.push( { sensorTypID: 2, sensorType: \"Accelerometer\" } );\r\n        }\r\n        if ( await gyroscopeExist ) {\r\n            sensors.push( { sensorTypID: 3, sensorType: \"Gyroscope\" } );\r\n        }\r\n\r\n        /*if (await magnetometerExist) {\r\n            sensors.push({ sensorTypID: 4, sensorType: \"Magnetometer\" });\r\n        }*/\r\n        return sensors;\r\n    }\r\n\r\n    private async existSensor ( sensor: Sensor ): Promise<boolean> {\r\n        var finish = false;\r\n        sensor.addEventListener( 'reading', e => {\r\n            finish = true;\r\n            sensor.stop();\r\n        } );\r\n        sensor.start();\r\n        await this.wait( 1000 );\r\n        sensor.stop();\r\n        return finish;\r\n    }\r\n    private async wait ( ms: number ) {\r\n        return new Promise( resolve => setTimeout( resolve, ms ) );\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DeliveryController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\VisualizationController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DatabaseConnector.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIDistributor.tsx",["300"],"import { DeliveryFormat } from './DeliveryFormat';\r\n\r\n/**\r\n * Diese Klasse verwaltet die Auslieferungsformalitäten für trainierte KI-Modelle.\r\n */\r\nexport class AIDistributor {\r\n    private static readonly url: string = \"../deliverance/\";\r\n    private static readonly headers = { 'ContentType': 'application/json' };\r\n    private format: DeliveryFormat;\r\n    private id: number;\r\n\r\n    /**\r\n     * Dieser Konstruktor erzeugt das Objekt in Abhängigkeit vom gewählten Auslieferungsformat. \r\n     * Dieses sorgt an verschiedenen Stellen im Programmablauf für unterschiedliche Vorgehensweisen.\r\n     * @param format Das Auslieferungsformat.\r\n     */\r\n    constructor(id: number, format: DeliveryFormat) {\r\n        this.format = format;\r\n        this.id = id;\r\n    }\r\n\r\n    /**\r\n     * Gibt in Abhängigkeit vom Auslieferungsformat entweder das fertige KI-Modell als \r\n     * ausführbare Datei zurück, oder sämtliche Daten, die nötig sind, um das KI-Modell \r\n     * später als Web-Anwendung auszuführen.\r\n     * \r\n     * Der Return-Typ ist einzig aus dem Grund \"any\", weil sich so das Problem löst, dass\r\n     * man von einem blanken Objekt keine spezifischen Eigenschaften erwarten kann.\r\n     */\r\n    getAIModel(): any {\r\n        let data = this.sendRequest({ \"id\": this.id, \"format\": this.format, \"job\": \"get\" });\r\n        let success : boolean;\r\n        try {\r\n            success = Object.keys(data).includes(\"url\");\r\n        }\r\n        catch (e) {\r\n            success = false;\r\n        }\r\n        if (!success) {\r\n            throw new Error(\"Connection issue: \" + data.status + \": \" + data.statusText);\r\n        }\r\n        switch (this.format) {\r\n            case DeliveryFormat.EXE:\r\n                throw new Error(\"Not implemented.\")\r\n                //location.href = data.url;\r\n                //return dataX;\r\n            case DeliveryFormat.WEB_APP:\r\n                return {\"url\": data.url};\r\n            default:\r\n                throw new Error(\"Illegal delivery format.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Diese Methode reicht die übergebenen E-Mail-Adressen an den Server weiter, damit dieser \r\n     * einen Link zum KI-Modell, dessen laufende Nummer im Objekt hinterlegt ist, \r\n     * an sämtliche dieser Adressen versendet.\r\n     * \r\n     * @param emailList Die E-Mail-Adressen, an die der Server den Nutzungslink zum Modell versenden soll.\r\n     * @returns True, wenn die Anfrage an den Server erfolgreich war, False andernfalls.\r\n     */\r\n    sendAIModel(... emailList: string[]): boolean {\r\n        let recipients: {\"email\": string}[] = [];\r\n        emailList.forEach((address) => recipients[recipients.length] = {\"email\": address});\r\n        let data = this.sendRequest({\"recipients\": JSON.stringify(recipients), \"id\": this.id, \"job\": \"send\"});\r\n        let success : boolean;\r\n        try {\r\n            success = Object.keys(data).includes(\"result\");\r\n        }\r\n        catch (e) {\r\n            success = false;\r\n        }\r\n        if (success) {\r\n            return data.result;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Diese Methode schickt die Anfrage an den Server raus.\r\n     * \r\n     * @param data Die Daten, die mit der Anfrage zu versenden sind.\r\n     */\r\n    private sendRequest(data: object): any {\r\n        return new Promise(function(resolve, reject){\r\n            let xhr = new XMLHttpRequest(); // XHR ist kurz für XmlHttpRequest\r\n            xhr.open(\"POST\", AIDistributor.url, true);\r\n            xhr.onreadystatechange = () => {\r\n                if (xhr.readyState === 4) {\r\n                    if (xhr.status === 200) {\r\n                        resolve(JSON.parse(xhr.responseText))\r\n                    }\r\n                    reject({\r\n                        status: xhr.status, \r\n                        statusText: xhr.statusText\r\n                    });\r\n                }\r\n            }\r\n            xhr.onerror = function () {\r\n                reject({\r\n                    status: this.status,\r\n                    statusText: xhr.statusText\r\n                });\r\n            };\r\n            for (const [header, content] of Object.entries(AIDistributor.headers)) {\r\n                xhr.setRequestHeader(header, content);\r\n            }\r\n            xhr.send(JSON.stringify(data));\r\n        }).then((resolve) => resolve, (reject) => reject);\r\n    }\r\n\r\n    /**\r\n     * Diese Methode wird verwendet, um aus einem aus der Datenbank geladenen \r\n     * KI-Modell (Scaler und Classifier) eine gebrauchsfertige Anwendung zu erstellen.\r\n     * \r\n     * Diese Methode ist sinnlos, da eine Datei auf dem Server liegen muss, um heruntergeladen werden zu können.\r\n     */\r\n    private buildExecutable(): boolean {\r\n        throw new Error(\"Not Implemented\");\r\n    }\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIBuilder.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\User.tsx",["301","302"],"import { DeviceData } from \"./DeviceData\";\r\nimport { Project } from \"./Project\";\r\nimport { SensorData } from \"./SensorData\";\r\n\r\n/**\r\n * Die Vorlage für alle existierenden Benutzer\r\n */\r\nexport abstract class User {\r\n  protected id: number; //Die eindeutige User ID\r\n  protected name: string; //Der Name des Users\r\n  protected device: DeviceData; //Das Benutzergerät des Benutzers\r\n  protected currentProject?: Project;\r\n\r\n  /**\r\n   * Erstellt einen Benutzer\r\n   * @param id eindeutige Benutzer ID\r\n   * @param name Name des Benutzer\r\n   */\r\n  constructor(id: number, device: DeviceData, name?: string) {\r\n    if (id < 0) {\r\n      this.id = -1;\r\n    } else {\r\n      this.id = id;\r\n    }\r\n    this.device = device;\r\n    if (name != null) {\r\n      this.name = name;\r\n    } else {\r\n      this.name = this.device.getName();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die aktuelle Datensatz ID zurück, falls diese nicht existiert wird -1 zurück gegeben.\r\n   */\r\n  getCurrentDataSetID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getCurrentDataSetID();\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  getCurrentProjectID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getID();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  addDatapoint(dataRowID: number, datapoint: { value: number[], relativeTime: number; }): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.addDatapoint(dataRowID, datapoint);\r\n    }\r\n    return false;\r\n\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getDataRows(dataSetID);\r\n    } else {\r\n      return { dataRows: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen des aktuellen Datensatzes zurück\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getCurrentDataRows();\r\n    } else {\r\n      return { dataRows: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID des aktuellen Projekts zurück, -1 falls kein aktuelles Projekt existiert\r\n   */\r\n  getSessionID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getSessionID();\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  /**\r\n     * Erstellt für das aktuelle Projekt einen neuen Datensatz und setzt diesen als aktuellen Datensatz.\r\n     * @param dataRowSensors die Sensoren, von denen die Daten ausgelesen werden\r\n     * @param dataSetID die eindeutige Datensatz ID\r\n     * @param dataSetName der Datensatznamen\r\n     * @param generateDate die Erstellungszeit von dem Datensatz\r\n     * @returns false, falls kein aktuelles Prokekt existiert\r\n     */\r\n  createDataSet(dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate?: number): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.createDataSet(dataRowSensors, dataSetID, dataSetName, generateDate);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Löscht vom aktuellen Projekt den Datensatz, mit der übergebenen Datensatz ID\r\n   * @param dataSetID die Datensatz ID\r\n   * @returns gibt die ProjektID zurück, zu dem der Datensatz gehörte, -1 falls der Datensatz nicht existiert hat\r\n   */\r\n  deleteDataSet(dataSetID: number): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.deleteDataSet(dataSetID);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Erstellt für das aktuelle Projekt und dem aktuellen Datensatz ein Label mit den übergebeben Parametern\r\n   * @param labelID Ist die eindeutige Label ID des Labels.\r\n   * @param start Ist die Startzeit des Labels.\r\n   * @param end Ist die Endzeit des Labels.\r\n   * @returns false, falls kein aktueller Datensatz existiert oder die LabelID für diesen Datensatz nicht eindeutig ist\r\n   */\r\n  createLabel(labelID: number, span: { start: number, end: number; }, labelName: string): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.createLabel(labelID, span, labelName);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setzt beim aktuellen Datensatz dem Label mit der LabelID die neu übergebenen Daten\r\n   * @param labelID \r\n   * @param start startzeit des Labels in Millisekunden\r\n   * @param end endzeit des Labels in Millisekunden\r\n   */\r\n  setLabel(labelID: number, span: { start: number, end: number; }, labelName?: string): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.setLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht von dem aktuellen Projekt und dem aktuellen Datensatz das Label mit der Label ID\r\n   * @param labelID die Label ID\r\n   * @returns false, falls kein aktueller Datensatz existiert oder kein Label mit der Label ID existiert\r\n   */\r\n  deleteLabel(labelID: number): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.deleteLabel(labelID);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln vom aktuellen Datensatz zurück.\r\n   * @returns leer, falls kein aktueller Datensatz existiert\r\n   */\r\n  getLabels(): { labels: { name: string, labelID: number, start: number, end: number; }[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getLabels();\r\n    }\r\n    return { labels: [] };\r\n  }\r\n\r\n  /**\r\n  * Lädt ein bestehendes Projekt in das Model\r\n  * @param project die Projektdaten\r\n  * @returns false, falls die Projekt ID schon existiert\r\n  */\r\n  abstract loadProject(project: {\r\n    projectID: number, sessionID: number, projectName: string, projectData?: {\r\n      aiModelID?: number[],\r\n      dataSet?: {\r\n        dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n        dataRows: {\r\n          dataRowID: number,\r\n          dataRow: { value: number[], relativeTime: number; }[];\r\n        }[],\r\n        label: { name: string, labelID: number, start: number, end: number; }[];\r\n      }[];\r\n    };\r\n  }): boolean;\r\n\r\n  /**\r\n   * Gibt alle Sensoren aus, die das Benutzergerät und das Programm unterstützt\r\n  \r\n  getDeviceSensors(sensorTypeID: number[]): SensorData[] {\r\n    return this.device.getSensors(sensorTypeID);\r\n  }\r\n\r\n  /**\r\n   * Gibt die SensorTypID der auswählbaren Sensoren zurück\r\n  getAvailableSensors(): number[] {\r\n    return this.device.getAvailableSensors();\r\n  } */\r\n\r\n  /**\r\n   * Gibt von allen Datensätzen vom aktuellen Projekt Informationen zurück\r\n   * @returns dataSetID ist die DatensatzID und dataSetName ist der Datensatzname\r\n   */\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[] {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getDataSetMetas();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setzt einen neuen Benutzernamen\r\n   * @param name der neue Benutzername\r\n   */\r\n  setName(name: string): void {\r\n    this.name = name;\r\n  }\r\n\r\n  /**\r\n   * Gibt den Benutzernamen zurück\r\n   */\r\n  getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  /**\r\n   * Setzt ein neues Benutzergerät\r\n   * @param device das Benutzergerät\r\n   */\r\n  setDevice(device: DeviceData) {\r\n    this.device = device;\r\n  }\r\n\r\n  /**\r\n   * Gibt falls ein Benutzergerät verfügbar ist dieses zurück\r\n   */\r\n  getDevice(): { device?: DeviceData; } {\r\n    return { device: this.device };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Benutzer ID zurück\r\n   */\r\n  getID(): number {\r\n    return this.id;\r\n  }\r\n}\r\n\r\n/**\r\n * Die Klasse Admin dient für einen Benutzer mit einem Account\r\n */\r\nexport class Admin extends User {\r\n  private email: string; //Die eindeutige Admin Email\r\n  private project: Project[] = []; //Alle Projekte, die zu dem Admin gehören\r\n\r\n  /**\r\n   * Zum erstellen eines Admins\r\n   * @param adminID die Admin ID\r\n   * @param deviceID die Geräte ID des Admins\r\n   * @param adminName der Name des Admins\r\n   * @param email die Emailadresse des Admins\r\n   */\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string);\r\n\r\n  /**\r\n   * Für die Implementierung eines Bestehenden Admins\r\n   * @param adminID die Admin ID\r\n   * @param deviceID die Geräte ID\r\n   * @param adminName der Admin Name\r\n   * @param email die Emailadresse des Admins\r\n   * @param device das Gerät des Admins\r\n   */\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string,\r\n    device: { deviceID?: number, deviceName: string, deviceType: string, firmware: string, generation: string, MACADRESS: string, sensorInformation: { sensorTypeID: number, sensorName: string, sensorUniqueID: number; }[]; });\r\n  ////////////////////////////////////////TODO\r\n\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string,\r\n    device?: { MACADRESS: string, deviceName: string, firmware: string, generation: string, deviceType: string; }) {\r\n    super(adminID, DeviceData.loadDevice(deviceID, device), adminName);\r\n    this.email = email;\r\n  }\r\n\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: {\r\n    projectID: number, sessionID: number, projectName: string, projectData?: {\r\n      aiModelID?: number[],\r\n      dataSet: {\r\n        dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n        dataRows: {\r\n          dataRowID: number,\r\n          dataRow: { value: number[], relativeTime: number; }[];\r\n        }[],\r\n        label: { name: string, labelID: number, start: number, end: number; }[];\r\n      }[];\r\n    };\r\n  }): boolean {\r\n    var id = this.existProject(project.projectID);\r\n    var newProject: Project = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    this.currentProject = newProject;\r\n    if (id == -1) {\r\n      this.project.push(newProject);\r\n    } else {\r\n      this.project[id] = newProject;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Fügt ein neues Projekt mit den übergebenen Parametern hinzu und setzt dieses Projekt als aktuelles Projekt\r\n   * @param projectID die Projekt ID, diese muss für den Admin eindeutig sein\r\n   * @param sessionID die Session ID, diese muss global eindeutig sein\r\n   * @param projectName der Name des Projektes\r\n   * @returns Bei angabe einer Project ID, die schon existiert wird false zurück gegeben\r\n   */\r\n  createProject(projectID: number, sessionID: number, projectName: string): boolean {\r\n    if (this.existProject(projectID) === -1) {\r\n      var newproject: Project = new Project(projectID, sessionID, projectName);\r\n      this.project.push(newproject);\r\n      this.currentProject = newproject;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param projectID \r\n   * @returns -1 falls das Projekt nicht existiert oder die Array Position des Projekts\r\n   */\r\n  private existProject(projectID: number): number {\r\n    for (let i = 0; i < this.project.length; i++) {\r\n      if (this.project[i].getID() == projectID) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Admin Emailadresse zurück\r\n   */\r\n  getEmail(): string {\r\n    return this.email;\r\n  }\r\n}\r\n\r\n/**\r\n * Dataminer ist die Klasse, um Datensammler mit ihren Geräte Sensoren zu spreichern\r\n */\r\nexport class Dataminer extends User {\r\n  /**\r\n   * Erstellt einen Datensammler\r\n   * @param id die Benutzer ID\r\n   * @param name der Benutzername\r\n   * @param deviceID die Geräte ID\r\n   */\r\n  constructor(id: number, deviceID: number, name?: string) {\r\n    super(id, DeviceData.loadDevice(deviceID), name);\r\n  }\r\n\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: {\r\n    projectID: number, sessionID: number, projectName: string, projectData?: {\r\n      aiModelID?: number[],\r\n      dataSet: {\r\n        dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n        dataRows: {\r\n          dataRowID: number,\r\n          dataRow: { value: number[], relativeTime: number; }[];\r\n        }[],\r\n        label: { name: string, labelID: number, start: number, end: number; }[];\r\n      }[];\r\n    };\r\n  }): boolean {\r\n    this.currentProject = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * AIModelUser ist die Klasse, um KI-Modell Benutzer zu speichern\r\n */\r\nexport class AIModelUser extends User {\r\n  /**\r\n   * Erstellt einen KI-Modell Benutzer, wenn Name \"\" gesetzt ist und eine Geräte ID gesetzt ist wird als Name der Geräte Name gewählt\r\n   * @param id die eindeutige Benutzer ID\r\n   * @param name der Benutzername\r\n   * @param deviceID die Geräte ID\r\n   */\r\n  constructor(id: number, deviceID: number, name?: string) {\r\n    super(id, DeviceData.loadDevice(deviceID), name);\r\n  }\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: {\r\n    projectID: number, sessionID: number, projectName: string, projectData?: {\r\n      aiModelID?: number[],\r\n      dataSet: {\r\n        dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n        dataRows: {\r\n          dataRowID: number,\r\n          dataRow: { value: number[], relativeTime: number; }[];\r\n        }[],\r\n        label: { name: string, labelID: number, start: number, end: number; }[];\r\n      }[];\r\n    };\r\n  }): boolean {\r\n    this.currentProject = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    return true;\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeliveryFormat.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeviceData.tsx",["303","304","305","306","307"],"import { AccelerometerData, SensorData } from \"./SensorData\";\r\n\r\nexport abstract class DeviceData {\r\n  private id: number;\r\n  private MACADDRESS: string;\r\n  private name: string;\r\n  private firmware: string;\r\n  private generation: string;\r\n  protected abstract deviceType: string;\r\n  //private availableSensors: SensorData[] = [];\r\n\r\n  protected constructor(deviceID: number, MACADRESS: string, deviceName: string, firmware: string, generation: string) {\r\n    if (deviceID < 0) {\r\n      this.id = -1;\r\n    } else {\r\n      this.id = deviceID;\r\n    }\r\n    this.MACADDRESS = MACADRESS;\r\n    this.name = deviceName;\r\n    this.firmware = firmware;\r\n    this.generation = generation;\r\n  }\r\n\r\n  /**\r\n   * Setzt nur die DeviceID falls beim erstellen des Gerätes die ID -1 übergeben wurde\r\n   * @param deviceID \r\n   */\r\n  setDeviceID(deviceID: number): boolean {\r\n\r\n    if (this.id == -1 && deviceID >= 0) {\r\n      this.id = deviceID;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getID(): number {\r\n    return this.id;\r\n  }\r\n\r\n  getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  getMACADDRESS(): string {\r\n    return this.MACADDRESS;\r\n  }\r\n\r\n  getFirmware(): string {\r\n    return this.firmware;\r\n  }\r\n\r\n  getGeneration(): string {\r\n    return this.generation;\r\n  }\r\n\r\n  /*getSensors(sensorTypeID: number[]): SensorData[] {\r\n    return [];\r\n  }\r\n  getSensor(id: number): SensorData {\r\n    return new AccelerometerData(this.id, this.MACADDRESS, this.name);\r\n  }*/\r\n\r\n  /**\r\n   * Gibt alle Sensoren aus, die das Benutzergerät und das Programm unterstützt\r\n   *\r\n  getAvailableSensors(): number[] {\r\n    return [];\r\n  }*/\r\n\r\n  /**\r\n   * Prüft welches Gerät aktuell benutzt wird\r\n   */\r\n  static loadDevice(deviceID: number, device?: { MACADRESS: string, deviceName: string, firmware: string, generation: string, deviceType: string; }): DeviceData {\r\n    ////////////////////////////////////////////////////\r\n    //Noch herrausfinden Smartphone oder anderes Gerät//\r\n    ////////////////////////////////////////////////////\r\n    if (device != null) {\r\n      if (device.deviceType == \"Smartphone\") {\r\n        return new Smartphone(deviceID, device.MACADRESS, device.deviceName, device.firmware, device.generation);\r\n      } else if (device.deviceType == \"Desktop\") {\r\n        return new Desktop(deviceID, device.MACADRESS, device.deviceName, device.firmware, device.generation);\r\n      } else {\r\n        return new Smartphone(deviceID, device.MACADRESS, device.deviceName, device.firmware, device.generation);\r\n      }\r\n    } else {\r\n      //NUR DUMMY MUSS NOCH GEFÜLLT WERDEN\r\n      return new Smartphone(deviceID, \"\", \"\", \"\", \"\");\r\n    }\r\n  }\r\n  //protected abstract searchSensor(): void;\r\n}\r\n\r\nexport class Smartphone extends DeviceData {\r\n  protected deviceType: string = \"Smartphone\";\r\n  //protected searchSensor(): void { }\r\n}\r\n\r\nexport class Desktop extends DeviceData {\r\n  protected deviceType: string = \"Desktop\";\r\n  //protected searchSensor(): void { }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Project.tsx",["308","309","310"],"import { AIModel } from \"./AIModel\";\r\nimport { DataSet } from \"./DataSet\";\r\nimport { SensorData } from \"./SensorData\";\r\nimport { Session } from \"./Session\";\r\n\r\n/**\r\n * Diese Klasse speichert alle Informationen zu einem Projekt.\r\n * Ein Projekt beinhaltet aufgezeichnete Datensätze (DataSet) sowie Informationen zu den Datensätzen.\r\n */\r\nexport class Project {\r\n  private id: number; //Die eindeutige Projekt ID\r\n  private name: string; //Der Name des Projektes\r\n  private session: Session; //Die Session in dem das Projekt arbeitet\r\n  private aiModel: AIModel[] = []; //Das AIModel von dem Projekt\r\n  private dataSet: DataSet[] = []; //Die Datensätze, die zu dem Projekt gehören\r\n  private currentDataSet?: DataSet; //Aktueller Datensatz\r\n\r\n  /**\r\n     * Eine bereits existierendes Projekt kann wie folgt in das Model geladen werden.\r\n     * @param projectID Die Projekt ID\r\n     * @param sessionID Die Session ID\r\n     * @param projectName Der Projektnamen\r\n     * @param admin Der Besitzer dieses Projekts für die Session\r\n     * @param aiModelID Die schon existierenden AIModel IDs\r\n     * @param dataSet Die schon existierenden Datensätze\r\n     */\r\n  constructor(projectID: number, sessionID: number, projectName: string, projectData?: {\r\n    aiModelID?: number[],\r\n    dataSet: {\r\n      dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n      dataRows: {\r\n        dataRowID: number,\r\n        dataRow: { value: number[], relativeTime: number; }[];\r\n      }[],\r\n      label: { name: string, labelID: number, start: number, end: number; }[];\r\n    }[];\r\n  }) {\r\n    this.id = projectID;\r\n    this.name = projectName;\r\n    this.session = new Session(sessionID);\r\n    if (projectData != null) {\r\n      if (projectData.aiModelID != null) {\r\n        for (let i = 0; i < projectData.aiModelID.length; i++) {\r\n          this.aiModel.push(new AIModel(projectData.aiModelID[i]));\r\n        }\r\n      }\r\n      for (let i = 0; i < projectData.dataSet.length; i++) {\r\n        this.dataSet.push(new DataSet(projectData.dataSet[i].dataRowSensors, projectData.dataSet[i].dataSetID, projectData.dataSet[i].dataSetName, projectData.dataSet[i].generateDate, projectData.dataSet[i].dataRows, projectData.dataSet[i].label));\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Gibt den Projektnamen zurück\r\n   */\r\n  getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  /**\r\n   * Löscht den Datensatz mit der DatensatzID\r\n   * @param dataSetID die Datensatz ID\r\n   */\r\n  deleteDataSet(dataSetID: number): boolean {\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() === dataSetID) {\r\n        this.dataSet.splice(i, 1);\r\n        if (this.currentDataSet != null && this.currentDataSet.getID() === dataSetID) {\r\n          delete this.currentDataSet;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Projekt ID zurück.\r\n   */\r\n  getID(): number {\r\n    return this.id;\r\n  }\r\n\r\n\r\n  /**\r\n   * Erstellt einen neuen Datensatz und setzt diesen als aktuellen Datensatz.\r\n   * @param dataRowSensors die Sensoren, von denen die Daten ausgelesen werden\r\n   * @param dataSetID die eindeutige Datensatz ID\r\n   * @param dataSetName der Datensatznamen\r\n   * @param generateDate die Erstellungszeit von dem Datensatz\r\n   */\r\n  createDataSet(dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate?: number): boolean {\r\n    if (dataRowSensors.length <= 0 || dataSetID < 0 || dataSetName.length <= 0 || generateDate != null && generateDate < 0) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() == dataSetID) {\r\n        return false;\r\n      }\r\n    }\r\n    var dataSet: DataSet = new DataSet(dataRowSensors, dataSetID, dataSetName, generateDate);\r\n    this.dataSet.push(dataSet);\r\n    this.currentDataSet = dataSet;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gibt die aktuelle Datensatz ID zurück, falls diese nicht existiert wird -1 zurück gegeben\r\n   */\r\n  getCurrentDataSetID(): number {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.getID();\r\n    }\r\n    return -1;\r\n\r\n  }\r\n\r\n  addDatapoint(dataRowID: number, datapoint: { value: number[], relativeTime: number; }): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.addDatapoint(dataRowID, datapoint);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt von allen Datensätzen Informationen zurück\r\n   * @returns dataSetID ist die DatensatzID und dataSetName ist der Datensatzname\r\n   */\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[] {\r\n    var dataSetMetas: { dataSetID: number, dataSetName: string; }[] = [];\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      dataSetMetas.push({ dataSetID: this.dataSet[i].getID(), dataSetName: this.dataSet[i].getName() });\r\n    }\r\n    return dataSetMetas;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[]; } {\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() === dataSetID) {\r\n        this.currentDataSet = this.dataSet[i];\r\n        return { dataRows: this.dataSet[i].getDataRows() };\r\n      }\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datenreihen der aktuellen Datenreihe zurück\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[]; } {\r\n    if (this.currentDataSet != null) {\r\n      return { dataRows: this.currentDataSet.getDataRows() };\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID zurück\r\n   */\r\n  getSessionID(): number {\r\n    return this.session.getId();\r\n  }\r\n\r\n  /**\r\n   * Setzt dem Label mit der übergebenen ID neue Werte.\r\n   * @param start Ist die neue Startzeit des Labels.\r\n   * @param end Ist die neue Endzeit des Labels.\r\n   * @param labelID Die Label ID, welche überarbeitet werden soll.\r\n   * @param labelName Ist bei Angabe der neue Name des Labels.\r\n   * @returns falls das Label nicht existiert oder es kein aktuellen Datensatz gibt wird false zurück gegeben\r\n   */\r\n  createLabel(labelID: number, span: { start: number, end: number; }, labelName: string): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.createLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  setLabel(labelID: number, span: { start: number, end: number; }, labelName?: string): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.setLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  deleteLabel(labelID: number): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.deleteLabel(labelID);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln vom aktuellen Datensatz zurück.\r\n   * @returns leer, falls kein aktueller Datensatz existiert\r\n   */\r\n  getLabels(): { labels: { name: string, labelID: number, start: number, end: number; }[]; } {\r\n    if (this.currentDataSet != null) {\r\n      return { labels: this.currentDataSet.getLabels() };\r\n    }\r\n    return { labels: [] };\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\FinishController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ModelCreationController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\index.tsx",["311","312","313"],"import React from 'react';\r\nimport DownloadButton from '../../components/DeliveryComponents/DownloadButton';\r\nimport EmailList from '../../components/DeliveryComponents/EmailList';\r\nimport { Page } from \"../PageInterface\";\r\nimport { PageController } from \"../../../controller/PageController\";\r\nimport { State } from \"./State\";\r\nimport ReactDOM from 'react-dom';\r\nimport { States } from '../State';\r\nimport { NotificationContainer, NotificationManager } from 'react-notifications';\r\nimport 'react-notifications/lib/notifications.css';\r\nexport class DeliveryPage implements Page {\r\n\r\n\tstate = new State;\r\n\tobservers: PageController[] = [];\r\n\r\n\tconstructor() {\r\n\t\tthis.state = new State()\r\n\t}\r\n\r\n\r\n\tupdate() {\r\n\t\tthis.notify()\r\n\t\tconst VDOM = (\r\n\t\t\t<div>\r\n\t\t\t\t<EmailList delivery={this.delivery.bind(this)} />\r\n\t\t\t\t<DownloadButton download={this.download.bind(this)} />\r\n\t\t\t</div>\r\n\t\t);\r\n\t\tif (document.getElementById('root') !== null) {\r\n\t\t\tReactDOM.render(VDOM, document.getElementById('root'));\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tattach(observer: PageController) {\r\n\t\tthis.observers.push(observer);\r\n\t}\r\n\r\n\tdetach(observer: PageController) {\r\n\t\tconst index = this.observers.indexOf(observer, 0);\r\n\t\tif (index > -1) {\r\n\t\t\tthis.observers.splice(index, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tnotify() {\r\n\t\tfor (let index = 0; index < this.observers.length; index++) {\r\n\t\t\tconst element = this.observers[index];\r\n\t\t\telement.update();\r\n\t\t}\r\n\t}\r\n\r\n\tgetState() {\r\n\t\treturn this.state;\r\n\t}\r\n\r\n\tsetState(state: any) {\r\n\t\tthis.state = state\r\n\t\tthis.update()\r\n\t}\r\n\r\n\tprivate delivery(chosenEmails: string[]) {\r\n\r\n\t\t// eslint-disable-next-line\r\n\t\tthis.state.currentState = States.DeliverWeb\r\n\t\t// eslint-disable-next-line\r\n\t\tthis.state.chosenEmails = chosenEmails\r\n\t\tthis.notify()\r\n\t}\r\n\r\n\tprivate download() {\r\n\r\n\t\t// eslint-disable-next-line\r\n\t\tthis.state.currentState = States.NeedDownload\r\n\t\tthis.notify()\r\n\t}\r\n\r\n\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\NewProjectButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataSet.tsx",["314"],"import { DataRow } from \"./DataRow\";\r\nimport { Label } from \"./Label\";\r\nimport { SensorData } from \"./SensorData\";\r\n\r\n/**\r\n * Die Klasse fasst Datenreihen, welche Sensorwerte und deren relative Zeit besitzen, zu einem Datensatz zusammen.\r\n */\r\nexport class DataSet {\r\n  private generateDate: number; //Dies ist die Erstellungszeit dieses Datensatzes in Millisekunden.\r\n  private id: number; //Dies ist die Datensatz ID.\r\n  private name: string; //Dies ist der Name des Datensatzes.\r\n  private dataRow: DataRow[] = []; //Dies sind die Datenreihen, welche zu dem Datensatz gehören.\r\n  private label: Label[] = []; //Dies sind die existierenden Labels für den Datensatz.\r\n\r\n\r\n  /**\r\n   * Erstellt einen neuen Datensatz.\r\n   * @param dataRowSensors die Sensoren, von denen die Daten ausgelesen werden\r\n   * @param dataSetID die eindeutige Datensatz ID\r\n   * @param dataSetName der Datensatznamen\r\n   * @param generateDate die Erstellungszeit von dem Datensatz\r\n   */\r\n  constructor(dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate?: number);\r\n\r\n  /**\r\n   * Eine bereits existierende Datensatz kann wie folgt in das Model geladen werden.\r\n   * @param dataRowSensors die Sensoren, von denen die Daten ausgelesen werden, \r\n   * die Anzahl muss mit der Anzahl der Datenreihen übereinstimmen. Und der i´te Sensor wird zur i´ten Datenreihe hinzugefügt.\r\n   * @param dataSetID die eindeutige Datensatz ID\r\n   * @param dataSetName der Datensatznamen\r\n   * @param generateDate die Erstellungszeit von dem Datensatz\r\n   * @param dataRows die schon existierenden Datenreihen\r\n   * @param label die schon existierenden Labels\r\n   */\r\n  constructor(dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number, dataRows: { dataRowID: number, dataRow: { value: number[], relativeTime: number; }[]; }[], label: { name: string, labelID: number, start: number, end: number; }[]);\r\n  constructor(dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate?: number, dataRows?: { dataRowID: number, dataRow: { value: number[], relativeTime: number; }[]; }[], label?: { name: string, labelID: number, start: number, end: number; }[]) {\r\n    if (dataRows != null) {\r\n      for (let i = 0; i < dataRows.length && i < dataRowSensors.length; i++) {\r\n        this.dataRow.push(new DataRow(dataRowSensors[i], dataRows[i].dataRowID, dataRows[i].dataRow));\r\n      }\r\n    } else {\r\n      for (let i = 0; i < dataRowSensors.length; i++) {\r\n        this.dataRow.push(new DataRow(dataRowSensors[i], i));\r\n      }\r\n    }\r\n    if (label != null) {\r\n      for (let i = 0; i < label.length; i++) {\r\n        this.label.push(new Label(label[i].name, label[i].labelID, label[i].start, label[i].end));\r\n      }\r\n    }\r\n    if (generateDate != null) {\r\n      this.generateDate = generateDate;\r\n    } else {\r\n      this.generateDate = new Date().getTime();\r\n    }\r\n    this.id = dataSetID;\r\n    this.name = dataSetName;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datensatz ID zurück.\r\n   */\r\n  public getID(): number {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Gibt den Datensatz Namen zurück.\r\n   */\r\n  public getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  addDatapoint(dataRowID: number, datapoint: { value: number[], relativeTime: number; }): boolean {\r\n    for (let i = 0; i < this.dataRow.length; i++) {\r\n      if (this.dataRow[i].getID() === dataRowID) {\r\n        return this.dataRow[i].addDatapoint(datapoint);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Datenreihen zurück.\r\n   * @returns Ein zwei Dimensionales Array, die Erste Dimension wählt die Datenreihe und die zweite Dimension den Datenpunkt.\r\n   */\r\n  public getDataRows(): { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[] {\r\n    var dataRows: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[] = [];\r\n    for (let i = 0; i < this.dataRow.length; i++) {\r\n      dataRows.push(this.dataRow[i].getDataRow());\r\n    }\r\n    return dataRows;\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein Label\r\n   * @param labelID die eindeutige Label ID\r\n   * @param name der Labelname\r\n   * @param start die Startzeit des Zeitfensters in Millisekunden\r\n   * @param end die Endzeit des Zeitfensters in Millisekunden\r\n   * @returns falls das Label mit der ID schon existiert wird false zurück gegeben\r\n   */\r\n  public createLabel(labelID: number, span: { start: number, end: number; }, labelName: string): boolean {\r\n    if (labelID < 0 || span.start < 0 || span.end < span.start) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() === labelID) {\r\n        return false;\r\n      }\r\n    }\r\n    this.label.push(new Label(labelName, labelID, span.start, span.end));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Setzt dem Label mit der übergebenen ID neue Werte.\r\n   * @param span ist die Start- und Endzeit in Millisekunden.\r\n   * @param labelID Die Label ID, welche überarbeitet werden soll.\r\n   * @param labelName Ist bei Angabe der neue Name des Labels.\r\n   * @returns falls das Label nicht existiert wird false zurück gegeben\r\n   */\r\n  public setLabel(labelID: number, span: { start: number, end: number; }, labelName?: string): boolean {\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() === labelID) {\r\n        return this.label[i].setLabel(span, labelName);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht das Label mit der übergebenen LabelID.\r\n   * @param labelID die LabelID\r\n   */\r\n  public deleteLabel(labelID: number): boolean {\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() == labelID) { //keine absolute gleichheit!\r\n        this.label.splice(i, 1);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln zurück.\r\n   */\r\n  public getLabels(): { name: string, labelID: number, start: number, end: number; }[] {\r\n    var labelList: { name: string, labelID: number, start: number, end: number; }[] = [];\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      labelList.push(this.label[i].getLabel());\r\n    }\r\n    return labelList;\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIModel.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Session.tsx",["315"],"import { User } from \"./User\";\r\n\r\n/**\r\n * Diese Klasse Speichert die Session informationen\r\n */\r\nexport class Session {\r\n  private id: number; //Die eindeutige ID der Session\r\n  private connectedUser: User[] = []; //Die User die mit der Projekt der Session interagieren\r\n\r\n  /**\r\n   * Erstellt eine Session\r\n   * @param id Diese ID muss global eindeutig sein\r\n   * @param admin Der Admin, dem diese Session gehört\r\n   */\r\n  constructor(id: number) {\r\n    if (id < 0) {\r\n      this.id = -1;\r\n    } else {\r\n      this.id = id;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fügt eine User als Verbundener User zu der Session hinzu\r\n   * @param user Der User, der hinzugefügt wird\r\n   */\r\n  connectUser(user: User): boolean {\r\n    for (let i = 0; i < this.connectedUser.length; i++) {\r\n      if (this.connectedUser[i].getID() == user.getID()) {\r\n        return false;\r\n      }\r\n    }\r\n    this.connectedUser.push(user);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Meldet einen User von der aktuellen Session ab\r\n   * @param user Der User, der abgemeldet werdern soll\r\n   */\r\n  disconnectUser(userID: number): boolean {\r\n    for (let i = 0; i < this.connectedUser.length; i++) {\r\n      if (this.connectedUser[i].getID() === userID) {\r\n        this.connectedUser.splice(i, 1);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt von allen verbundenen Usern die ID und den Namen zurück\r\n   */\r\n  getConnectedUsers(): { userID: number, userName: string; }[] {\r\n    var users: { userID: number, userName: string; }[] = [];\r\n    for (let i = 0; i < this.connectedUser.length; i++) {\r\n      users.push({ userID: this.connectedUser[i].getID(), userName: this.connectedUser[i].getName() });\r\n    }\r\n    return users;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID zurück\r\n   */\r\n  getId(): number {\r\n    return this.id;\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Countdown\\index.tsx",["316"],"import { Component } from 'react';\r\nimport { NotificationManager } from 'react-notifications';\r\n\r\nexport default class Countdown extends Component {\r\n\r\n    props = {\r\n        countdownNumber: 5, chosenSensors: [1]\r\n    };\r\n\r\n    render() {\r\n        let countdown;\r\n        if (this.props.countdownNumber > 0) {\r\n            countdown = this.props.countdownNumber;\r\n        } else {\r\n            countdown = \"Aufnahme gestartet\";\r\n        }\r\n\r\n        let sensornames: string[] = [];\r\n        for (let sensor in this.props.chosenSensors) {\r\n            switch (sensor) {\r\n                case \"0\":\r\n                    sensornames.push(\"Accelerometer\");\r\n                    break;\r\n                case \"1\":\r\n                    sensornames.push(\"Gyroscope\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return (\r\n            <div>\r\n                <h2>Bereit machen zur Aufnahme!</h2>\r\n                <h2>{countdown}</h2>\r\n                <h2>Verwendete Sensoren:</h2>\r\n                {\r\n                    sensornames.map((x) => {\r\n                        return <h4>{x}</h4>;\r\n                    })\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Diagram\\index.tsx",["317","318","319","320","321","322","323","324","325","326","327"],"import { Component } from 'react';\r\n\r\nexport default class Diagram extends Component {\r\n\r\n    props = {\r\n        dataRows: [{ sensorType: 1, datapoint: [{ value: [5], relativeTime: 5 }] }],\r\n        pageChangeToFinish: function () { }\r\n    };\r\n\r\n    state = {\r\n        diagrammData: {\r\n            lineLabels: [] as any[],\r\n            sensorRow: [] as any[],\r\n            datavalue: [] as any[],\r\n            time: [] as any[],\r\n            showDiagram: false,\r\n            diagram: {},\r\n            diagramLineLabels: {},\r\n            diagramData: {},\r\n            diagramOptions: {},\r\n            color: ['rgba(46,190,87,1)', 'rgba(68,24,232,1)', 'rgba(238,173,14,1)', 'rgba(178,34,34,1)', 'rgba(238, 130, 238,1)', 'rgba(0, 0, 0,1)',\r\n                'rgba(106, 90, 205,1)', 'rgba(238, 118, 0,1)', 'rgba(105, 105, 105,1)'],\r\n            csscolor: ['2EBE57', 'CC00FF', 'EEAD0E', 'B22222', 'EE82EE', '000000',\r\n                '6A5ACD', 'EE7600', '696969'],\r\n        }\r\n    };\r\n\r\n    updateDiagramm() {\r\n        //PubSub.unsubscribe(\"startDiagram\")\r\n        //put each value Array in State\r\n        this.state.diagrammData.lineLabels = [];\r\n        this.state.diagrammData.sensorRow = [];\r\n        this.state.diagrammData.datavalue = [];\r\n        this.state.diagrammData.time = [];\r\n        this.state.diagrammData.showDiagram = true;\r\n\r\n        var datavalues = [];\r\n        for (var i = 0; i < this.props.dataRows.length; i++) {\r\n            this.state.diagrammData.sensorRow.push(this.props.dataRows[i].sensorType);\r\n            for (var dataCoordinate = 0; dataCoordinate < 3; dataCoordinate++) {\r\n                for (var j = 0; j < this.props.dataRows[i].datapoint.length; j++) {\r\n                    datavalues.push(this.props.dataRows[i].datapoint[j].value[dataCoordinate]);\r\n                }\r\n                this.state.diagrammData.datavalue.push(datavalues);\r\n                datavalues = [];\r\n            }\r\n        }\r\n        // eslint-disable-next-line\r\n        for (var j = 0; j < this.props.dataRows[0].datapoint.length; j++) {\r\n            this.state.diagrammData.time.push(this.props.dataRows[0].datapoint[j].relativeTime);\r\n        }\r\n\r\n        var newDatasets = [];\r\n        var lineLabels = [];\r\n        for (var i = 0; i < this.state.diagrammData.sensorRow.length * 3; i++) {\r\n            var coordinate = \".X\";\r\n            var sensor = this.state.diagrammData.sensorRow[(i / 3) | 0];\r\n            var sensorName = '';\r\n            switch (sensor) {\r\n                case 2:\r\n                    sensorName = 'Accelerometer';\r\n                    break;\r\n                case 3:\r\n                    sensorName = 'Gyroscope';\r\n                    break;\r\n                case 4:\r\n                    sensorName = 'Magnetometer';\r\n                    break;\r\n            }\r\n            if (i % 3 == 1) {\r\n                coordinate = \".Y\";\r\n            }\r\n            if (i % 3 == 2) {\r\n                coordinate = \".Z\";\r\n            }\r\n\r\n            lineLabels.push(<span color={this.state.diagrammData.csscolor[i]}>■{sensorName + coordinate}<br /></span>);\r\n            newDatasets.push(\r\n                {\r\n                    label: sensor + coordinate,\r\n                    strokeColor: this.state.diagrammData.color[i],\r\n                    borderWidth: 1,\r\n                    data: this.state.diagrammData.datavalue[i],\r\n                }\r\n            );\r\n        }\r\n        const data = {\r\n            labels: this.state.diagrammData.time,\r\n            datasets: newDatasets\r\n        };\r\n        const options = {\r\n            datasetFill: false,\r\n            pointDotRadius: 2,\r\n            pointHitDetectionRadius: 1,\r\n            offsetGridLines: false,\r\n            pointDot: false\r\n        };\r\n        this.state.diagrammData.diagramData = data;\r\n        this.state.diagrammData.lineLabels = lineLabels;\r\n        this.state.diagrammData.diagramOptions = options;\r\n    }\r\n\r\n    submit = () => {\r\n        this.props.pageChangeToFinish();\r\n    };\r\n\r\n    render() {\r\n        var LineChart = require(\"react-chartjs\").Line;\r\n        this.updateDiagramm();\r\n        console.log(this.state.diagrammData);\r\n        return (\r\n            <div>\r\n                {this.state.diagrammData.lineLabels}\r\n                <LineChart data={this.state.diagrammData.diagramData} options={this.state.diagrammData.diagramOptions} width=\"400\" height=\"200\" redraw />\r\n                <button type=\"button\" onClick={this.submit}>ChangeToFinish</button>\r\n            </div>\r\n        );\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Input\\index.tsx",["328"],"import React, { Component } from \"react\";\r\nimport { NotificationContainer, NotificationManager } from 'react-notifications';\r\nimport './Input.css';\r\n\r\n\r\n/**\r\n * Komponent der Startseite. \r\n */\r\nexport default class Input extends Component {\r\n\r\n  props = {\r\n    pageChangeSettings: function (recordingSettings: {\r\n      newDataSetName: string, usedSensorTypes: number[], waitTime: number, readTime: number,\r\n      availableSensorTypes: { sensorTypID: number, sensorType: string, chosen: boolean; }[];\r\n    }) { },\r\n    availableSensorTypes: [] as { sensorTypID: number, sensorType: string, chosen: boolean; }[]\r\n  };\r\n\r\n  state = {\r\n    name: \"\",\r\n    usedSensorTypes: [] as number[],\r\n    leadTime: \"\",\r\n    collectionTime: \"\",\r\n    //wait: new Promise(resolve => setTimeout(resolve, 1000))\r\n  };\r\n\r\n  changeLeadtime = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    this.setState({\r\n      leadTime: e.target.value,\r\n    });\r\n  };\r\n\r\n  changeCollectionTime = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    this.setState({\r\n      collectionTime: e.target.value,\r\n    });\r\n  };\r\n\r\n\r\n  changeName = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    this.setState({\r\n      name: e.target.value,\r\n    });\r\n  };\r\n\r\n  handleCheckBoxChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    let newAvailableSensorTypes = this.props.availableSensorTypes;\r\n    for (var i = 0; i < newAvailableSensorTypes.length; i++) {\r\n      // eslint-disable-next-line\r\n      if (newAvailableSensorTypes[i].sensorTypID == +e.target.value) {\r\n        newAvailableSensorTypes[i].chosen = !newAvailableSensorTypes[i].chosen;\r\n        this.setState({ availableSensorTypes: newAvailableSensorTypes, });\r\n        return;\r\n      }\r\n    }\r\n  };\r\n\r\n  submit = () => {\r\n    if (\r\n      parseInt(this.state.leadTime) >= 0 &&\r\n      parseInt(this.state.collectionTime) >= 0\r\n    ) {\r\n      let availableSensorTypes = this.props.availableSensorTypes;\r\n      var usedSensorTypes: number[] = [];\r\n      for (var i = 0; i < availableSensorTypes.length; i++) {\r\n        // eslint-disable-next-line\r\n        if (availableSensorTypes[i].chosen == true) {\r\n          usedSensorTypes.push(availableSensorTypes[i].sensorTypID);\r\n        }\r\n      }\r\n      this.setState({ usedSensorTypes: usedSensorTypes });\r\n\r\n      if (isNaN(+this.state.leadTime) || isNaN(+this.state.collectionTime)) {\r\n        NotificationManager.error(\"Die Eingabe der Zeit ist ungültig. Nur Ganze Zahlen sind Erlaubt\");\r\n        return;\r\n      }\r\n\r\n      const newDataSetName = this.state.name;\r\n      const waitTime = +this.state.leadTime;\r\n      const readTime = +this.state.collectionTime;\r\n      this.props.pageChangeSettings({\r\n        newDataSetName: newDataSetName, usedSensorTypes: usedSensorTypes, waitTime: waitTime, readTime: readTime,\r\n        availableSensorTypes: availableSensorTypes\r\n      });\r\n    } else {\r\n      NotificationManager.error(\"Die Eingabe ist ungültig\");\r\n    }\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"input\">\r\n        <form>\r\n          Aufnahmeparameter einstellen\r\n          <br />\r\n          Vorlaufzeit:\r\n          <input\r\n            type=\"leadTime\"\r\n            value={this.state.leadTime}\r\n            onChange={this.changeLeadtime.bind(this)}\r\n          />\r\n          s<br />\r\n          Aufnahmedauer:\r\n          <input\r\n            type=\"collectionTime\"\r\n            value={this.state.collectionTime}\r\n            onChange={this.changeCollectionTime.bind(this)}\r\n          />\r\n          s<br />\r\n          Datenname:\r\n          <input\r\n            type=\"datenname\"\r\n            value={this.state.name}\r\n            onChange={this.changeName.bind(this)}\r\n          /><br />\r\n          Sensoren:\r\n          {\r\n            this.props.availableSensorTypes.map((type: { sensorTypID: number, sensorType: string, chosen: boolean; }) => {\r\n              return (<div>\r\n                <input className='checkbox' type=\"checkbox\" value={type.sensorTypID} checked={type.chosen} onChange={(e: React.ChangeEvent<HTMLInputElement>): void => this.handleCheckBoxChange(e)} />\r\n                {type.sensorType}\r\n              </div>);\r\n            })\r\n          }\r\n\r\n          <br />\r\n          <button type=\"button\" onClick={this.submit} className=\"submit-btn\">\r\n            Start\r\n          </button>\r\n        </form>\r\n      </div>\r\n    );\r\n  }\r\n};\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Input\\Labelling\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoadModelButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ConstantsText\\index.tsx",["329","330"],"import { Method } from '@testing-library/dom'\r\nimport React, { Component } from 'react'\r\nimport { MainController } from '../../../../controller/MainController'\r\nimport './ConstantsText.css'\r\n\r\nexport default class ConstantsText extends React.Component {\r\n    render() {\r\n        console.log(MainController.getInstance().getText()!.title)\r\n        return (\r\n            <h1 className='title'>{MainController.getInstance().getText().title}</h1>\r\n        )\r\n    }\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoginWindow\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Diagram\\index.jsx",["331","332","333","334","335","336","337"],"import { Component } from 'react';\r\nimport PubSub from 'pubsub-js';\r\nimport diagram from './index.module.css';\r\n\r\nexport default class Diagram extends Component {\r\n    props = {\r\n        dataRows: [{ sensorType: 1, datapoint: [{ value: [5], relativeTime: 5 }] }],\r\n    };\r\n\r\n    diagrammData = {\r\n        lineLabels: [],\r\n        sensorRow: [],\r\n        datavalue: [],\r\n        time: [],\r\n        showDiagram: false,\r\n        diagram: {},\r\n        diagramLineLabels: {},\r\n        diagramData: {},\r\n        diagramOptions: {},\r\n        color: ['rgba(46,190,87,1)', 'rgba(68,24,232,1)', 'rgba(238,173,14,1)', 'rgba(178,34,34,1)', 'rgba(238, 130, 238,1)', 'rgba(0, 0, 0,1)',\r\n            'rgba(106, 90, 205,1)', 'rgba(238, 118, 0,1)', 'rgba(105, 105, 105,1)'],\r\n        csscolor: ['2EBE57', 'CC00FF', 'EEAD0E', 'B22222', 'EE82EE', '000000',\r\n            '6A5ACD', 'EE7600', '696969'],\r\n    };\r\n\r\n    updateDiagramm() {\r\n        //put each value Array in State\r\n        this.diagrammData.lineLabels = [];\r\n        this.diagrammData.sensorRow = [];\r\n        this.diagrammData.datavalue = [];\r\n        this.diagrammData.time = [];\r\n        this.diagrammData.showDiagram = true;\r\n\r\n        var datavalues = [];\r\n        if (this.props.dataRows != undefined) {\r\n            for (var i = 0; i < this.props.dataRows.length; i++) {\r\n                this.diagrammData.sensorRow.push(this.props.dataRows[i].sensorType);\r\n                for (var dataCoordinate = 0; dataCoordinate < 3; dataCoordinate++) {\r\n                    for (var j = 0; j < this.props.dataRows[i].datapoint.length; j++) {\r\n                        datavalues.push(this.props.dataRows[i].datapoint[j].value[dataCoordinate]);\r\n                    }\r\n                    this.diagrammData.datavalue.push(datavalues);\r\n                    datavalues = [];\r\n                }\r\n            }\r\n            // eslint-disable-next-line\r\n            for (var j = 0; j < this.props.dataRows[0].datapoint.length; j++) {\r\n                this.diagrammData.time.push(this.props.dataRows[0].datapoint[j].relativeTime);\r\n            }\r\n\r\n            var newDatasets = [];\r\n            var lineLabels = [];\r\n            for (var i = 0; i < this.diagrammData.sensorRow.length * 3; i++) {\r\n                var coordinate = \".X\";\r\n                var sensor = this.diagrammData.sensorRow[parseInt(i / 3)];\r\n                var sensorName = '';\r\n                switch (sensor) {\r\n                    case 2:\r\n                        sensorName = 'Accelerometer';\r\n                        break;\r\n                    case 3:\r\n                        sensorName = 'Gyroscope';\r\n                        break;\r\n                    case 4:\r\n                        sensorName = 'Magnetometer';\r\n                        break;\r\n                }\r\n                if (i % 3 == 1) {\r\n                    coordinate = \".Y\";\r\n                }\r\n                if (i % 3 == 2) {\r\n                    coordinate = \".Z\";\r\n                }\r\n\r\n                lineLabels.push(<font color={this.diagrammData.csscolor[i]}>■{sensorName + coordinate}<br /></font>);\r\n                //this.setState({ lineLabels: lineLabels })\r\n                newDatasets.push(\r\n                    {\r\n                        label: sensor + coordinate,\r\n                        strokeColor: this.diagrammData.color[i],\r\n                        borderWidth: 1,\r\n                        data: this.diagrammData.datavalue[i],\r\n                    }\r\n                );\r\n            }\r\n            const data = {\r\n                labels: this.diagrammData.time,\r\n                datasets: newDatasets\r\n            };\r\n            const options = {\r\n                datasetFill: false,\r\n                pointDotRadius: 2,\r\n                pointHitDetectionRadius: 1,\r\n                offsetGridLines: false,\r\n                pointDot: false\r\n            };\r\n            this.diagrammData.diagramData = data;\r\n            this.diagrammData.lineLabels = lineLabels;\r\n            this.diagrammData.diagramOptions = options;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        var LineChart = require(\"react-chartjs\").Line;\r\n        this.updateDiagramm();\r\n        return (\r\n            <div>\r\n                {this.diagrammData.lineLabels}\r\n                <LineChart data={this.diagrammData.diagramData} options={this.diagrammData.diagramOptions} width=\"400\" height=\"200\" redraw />\r\n            </div>\r\n        );\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\index.tsx",["338","339"],"import React from 'react';\r\nimport { Page } from \"../PageInterface\";\r\nimport { PageController } from \"../../../controller/PageController\";\r\nimport { State } from \"./State\";\r\nimport ReactDOM from 'react-dom';\r\nimport './ModelCreationPage.css';\r\nimport { States } from '../State';\r\nimport Train from '../../components/ModelCreationComponents/Train';\r\nimport { NotificationContainer, NotificationManager } from 'react-notifications';\r\nimport 'react-notifications/lib/notifications.css';\r\n\r\nexport class ModelCreationPage implements Page {\r\n\tstate = new State;\r\n\tobservers: PageController[] = [];\r\n\r\n\tconstructor() {\r\n\t\tthis.state = new State()\r\n\t}\r\n\r\n\tupdate() {\r\n\t\tthis.notify()\r\n\t\tconst VDOM = (\r\n\t\t\t<div>\r\n\t\t\t\t<Train\r\n\t\t\t\t\tdataSetMetas={this.state.dataSetMetas!}\r\n\t\t\t\t\ttrain={this.train.bind(this)}\r\n\t\t\t\t/>\r\n\t\t\t\t<NotificationContainer />\r\n\t\t\t</div>\r\n\t\t);\r\n\t\tif (document.getElementById('root') !== null) {\r\n\t\t\tReactDOM.render(VDOM, document.getElementById('root'));\r\n\t\t}\r\n\t}\r\n\r\n\tattach(observer: PageController) {\r\n\t\tthis.observers.push(observer);\r\n\t}\r\n\r\n\tdetach(observer: PageController) {\r\n\t\tconst index = this.observers.indexOf(observer, 0);\r\n\t\tif (index > -1) {\r\n\t\t\tthis.observers.splice(index, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tnotify() {\r\n\t\tfor (let index = 0; index < this.observers.length; index++) {\r\n\t\t\tconst element = this.observers[index];\r\n\t\t\telement.update();\r\n\t\t}\r\n\t}\r\n\r\n\tgetState() {\r\n\t\treturn this.state;\r\n\t}\r\n\r\n\tsetState(state: any) {\r\n\t\tthis.state = state\r\n\t\tthis.update()\r\n\t}\r\n\r\n\tprivate train(dataSets: number[], imputator: string, classifier: string, scaler: string, features: string[]) {\r\n\t\t// eslint-disable-next-line\r\n\t\tthis.state.currentState = States.NeedKiTraining;\r\n\t\t// eslint-disable-next-line\r\n\t\tthis.state.trainingParameter!.dataSets = dataSets;\r\n\t\tthis.state.trainingParameter!.imputator = imputator;\r\n\t\tthis.state.trainingParameter!.classifier = classifier;\r\n\t\tthis.state.trainingParameter!.scaler = scaler;\r\n\t\tthis.state.trainingParameter!.features = features;\r\n\t\tthis.notify();\r\n\t}\r\n\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataRow.tsx",["340","341","342","343"],"import { relative } from \"node:path\";\r\nimport { useDebugValue } from \"react\";\r\nimport { DataPoint } from \"./DataPoint\";\r\nimport { AccelerometerData, GyroscopeData } from \"./SensorData\";\r\n\r\n/**\r\n * Die Klasse DataRow beschreibt eine Reihe aufgenommener Daten eines Sensors.\r\n */\r\nexport class DataRow {\r\n  private id: number; //Dies ist die DataRow ID, diese ist eindeutig für Datensätze.\r\n  private datapoint: DataPoint[] = []; //Dies ist Datenreihe, eine Reihe von Datenpunkten.\r\n  private sensor: AccelerometerData | GyroscopeData; //Dies ist der Sensor von dem die Daten gelesen wurden.\r\n\r\n  /**\r\n   * Eine neue Datenreihe erstellen.\r\n   * @param sensor Sensor, von dem die Daten gelesen werden.\r\n   * @param dataRowID Eine eindeutige Datenreihen ID.\r\n   */\r\n  constructor(sensor: AccelerometerData | GyroscopeData, dataRowID: number);\r\n\r\n  /**\r\n   * Eine bereits existierende Datenreihe kann wie folgt in das Model geladen werden.\r\n   * @param sensor der Sensor von dem die Daten gelesen wurden\r\n   * @param dataRowID die ID, welche die Datenreihe bei der ersten Erstellung zugeteilt bekommen hat\r\n   * @param dataRow die aufgenommenen Daten\r\n   * @param dataRow.value der Sensor Messwert\r\n   * @param dataRow.relativeTime die relative Zeit zum Aufnahmestart\r\n   */\r\n  constructor(sensor: AccelerometerData | GyroscopeData, dataRowID: number, dataRow: { value: number[], relativeTime: number; }[]);\r\n  constructor(sensor: AccelerometerData | GyroscopeData, dataRowID: number, dataRow?: { value: number[], relativeTime: number; }[]) {\r\n    this.sensor = sensor;\r\n    this.id = dataRowID;\r\n    if (dataRow != null) {\r\n      for (let i = 0; i < dataRow.length; i++) {\r\n        this.datapoint.push(new DataPoint(dataRow[i].value, dataRow[i].relativeTime));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt die DataRow ID zurück.\r\n   */\r\n  public getID(): number {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Fügt den Datenpunkt der Datenreihe hinzu\r\n   * \r\n   */\r\n\r\n  /**\r\n   * Fügt den Datenpunkt der Datenreihe hinzu\r\n   * @param datapoint der Datenpunkt\r\n   * @returns false, falls datapoint.value leer ist oder datapoint.relativeTime < 0\r\n   */\r\n  public addDatapoint(datapoint: { value: number[], relativeTime: number; }): boolean {\r\n    for (let i = 0; i < this.datapoint.length; i++) {\r\n      if (this.datapoint[i].getValue().length != datapoint.value.length || this.datapoint[i].getRelativeTime() === datapoint.relativeTime) {\r\n        return false;\r\n      }\r\n    }\r\n    if (datapoint.value.length == 0 || datapoint.relativeTime < 0) {\r\n      return false;\r\n    } else {\r\n      this.datapoint.push(new DataPoint(datapoint.value, datapoint.relativeTime));\r\n      return true;\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Gibt die Datenreihe zurück.\r\n   * @returns value ist der Messwert und relativeTime die relative Zeit in Millisekunden zum Aufnahmestart.\r\n   */\r\n  public getDataRow(): { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; } {\r\n    var dataRow: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; };\r\n    var datapoint: { value: number[], relativeTime: number; }[] = [];\r\n    for (let i = 0; i < this.datapoint.length; i++) {\r\n      datapoint[i] = { value: this.datapoint[i].getValue(), relativeTime: this.datapoint[i].getRelativeTime() };\r\n    }\r\n    var sensorType: number = this.sensor.SensorTypeID;\r\n    dataRow = { sensorType, datapoint };\r\n    return dataRow;\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Label.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\FinishButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\DownloadButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\EmailList\\index.tsx",["344"],"import React, { Component } from 'react'\r\nimport { nanoid } from 'nanoid';\r\nimport { NotificationContainer, NotificationManager } from 'react-notifications';\r\nimport 'react-notifications/lib/notifications.css';\r\nexport default class EmailList extends Component {\r\n\tprops = {\r\n\t\tdelivery: function (chosenEmails: string[]) { }\r\n\t}\r\n\r\n\tstate = {\r\n\t\tmouse: false,\r\n\t\taddButtonClick: false,\r\n\t\tinputempty: true,\r\n\t\tinputemail: {\r\n\t\t\tid: '',\r\n\t\t\taddress: '',\r\n\t\t\tchosen: false\r\n\t\t},\r\n\t\temails: [{\r\n\t\t\tid: 'example',\r\n\t\t\taddress: 'xxxxx@xxx.xx(Beispiel, nach erstmal Addieren automatisch gelöscht)',\r\n\t\t\tchosen: false\r\n\t\t}]\r\n\t}\r\n\r\n\thandleCreate = () => {\r\n\t\tthis.setState({ addButtonClick: true });\r\n\t};\r\n\r\n\tinputchange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n\t\t// eslint-disable-next-line\r\n\t\tif (e.target.value == '') {\r\n\t\t\tthis.setState({ inputempty: true })\r\n\t\t} else {\r\n\t\t\tthis.setState({ inputemail: { id: nanoid(), address: e.target.value, chosen: false }, inputempty: false })\r\n\t\t}\r\n\r\n\t}\r\n\thandleKeyUp = (e: React.KeyboardEvent<HTMLInputElement>) => {\r\n\t\tthis.deleteEmail('example')\r\n\t\tconst { keyCode } = e;\r\n\t\t//check ENTER-key\r\n\t\tif (keyCode !== 13) return;\r\n\t\t//cant add empty email\r\n\t\tconst { inputemail, inputempty, emails } = this.state\r\n\t\tif (inputempty) {\r\n\t\t\tNotificationManager.error(\"Eingabe darf nicht leer sein!\", \"\", 3000);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet exist = false\r\n\t\temails.map((emailObj) => {\r\n\t\t\t// eslint-disable-next-line\r\n\t\t\tif (emailObj.address == inputemail.address) exist = true\r\n\t\t\treturn emailObj\r\n\t\t})\r\n\t\tif (exist) {\r\n\t\t\tNotificationManager.error(\"Es gibt schon Emailadresse in List!\", \"\", 3000);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar pattern = /^([A-Za-z0-9_\\-.])+@([A-Za-z0-9_\\-.])+\\.([A-Za-z])+$/\r\n\t\tif (pattern.test(inputemail.address)) {\r\n\t\t\tthis.addEmail(inputemail);\r\n\t\t} else {\r\n\t\t\tNotificationManager.error(\"Sie müssen eine Emailadresse eingeben!\", \"\", 3000);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//hide inputbox\r\n\t\tthis.setState({ addButtonClick: false });\r\n\t};\r\n\r\n\t//handle emailItem\r\n\thandleMouse = (flag: boolean) => {\r\n\t\treturn () => {\r\n\t\t\tthis.setState({ mouse: flag });\r\n\t\t};\r\n\t};\r\n\r\n\thandleCheck = (id: string, chosen: boolean) => {\r\n\t\tconst { emails } = this.state\r\n\t\tconst newEmails = emails.map((emailObj) => {\r\n\t\t\t// eslint-disable-next-line\r\n\t\t\tif (emailObj.id == id) return { ...emailObj, chosen };\r\n\t\t\telse return emailObj;\r\n\t\t})\r\n\t\tthis.setState({ emails: newEmails })\r\n\t};\r\n\r\n\thandleDelete = (id: string) => {\r\n\t\tif (window.confirm('Sind Sie sicher, die gewählt Emailadresse zu löschen?')) {\r\n\t\t\tconst { emails } = this.state\r\n\t\t\tconst newEmails = emails.filter((emailObj) => {\r\n\t\t\t\treturn emailObj.id !== id;\r\n\t\t\t});\r\n\t\t\t//update emailList\r\n\t\t\tthis.setState({ emails: newEmails })\r\n\t\t}\r\n\t};\r\n\r\n\t//addEmail for add new Email\r\n\taddEmail = (emailObj: { id: string, address: string, chosen: boolean }) => {\r\n\t\t//add new one\r\n\t\tconst { emails } = this.state\r\n\t\tconst newEmails = [emailObj, ...emails];\r\n\t\t//update emailList\r\n\t\tthis.setState({ emails: newEmails })\r\n\t};\r\n\r\n\t//deleteEmail for delete emailObj\r\n\tdeleteEmail = (id: string) => {\r\n\t\t//get orignal emailList\r\n\t\t//delete emailObj with id\r\n\t\tconst { emails } = this.state\r\n\t\tconst newEmails = emails.filter((emailObj) => {\r\n\t\t\treturn emailObj.id !== id;\r\n\t\t});\r\n\t\t//update emailList\r\n\t\tthis.setState({ emails: newEmails })\r\n\t};\r\n\r\n\t//checkAllEmail for all chosen email\r\n\tchooseAllEmail = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n\t\t//get orignal emailList\r\n\t\tconst chosen = e.target.checked\r\n\t\tconst { emails } = this.state\r\n\t\tconst newEmails = emails.map((emailObj) => {\r\n\t\t\treturn { ...emailObj, chosen };\r\n\t\t});\r\n\t\t//update emailList\r\n\t\tthis.setState({ emails: newEmails })\r\n\t};\r\n\r\n\t//clearAllChosen for delete all emails\r\n\tclearAllChosen = () => {\r\n\t\tif (window.confirm('Sind Sie sicher, alle gewähte Emailadressen zu löschen?')) {\r\n\t\t\t//get orignal emailList\r\n\t\t\tconst { emails } = this.state;\r\n\t\t\t//filter datas\r\n\t\t\tconst newEmails = emails.filter((emailObj) => {\r\n\t\t\t\treturn !emailObj.chosen;\r\n\t\t\t});\r\n\t\t\t//update emailLists\r\n\t\t\tthis.setState({ emails: newEmails })\r\n\t\t}\r\n\t};\r\n\t//sendmethod\r\n\tdelivery = () => {\r\n\t\tconst { emails } = this.state;\r\n\t\tlet emailaddressList: string[] = []\r\n\t\temails.map((emailObj) => {\r\n\t\t\tif (emailObj.chosen) emailaddressList.push(emailObj.address)\r\n\t\t\treturn emailObj\r\n\t\t});\r\n\t\t//console.log(emailaddressList)\r\n\t\tthis.props.delivery(emailaddressList)\r\n\t}\r\n\trender() {\r\n\t\tconst { mouse, emails } = this.state\r\n\t\tconst chosenCount = emails.reduce((pre, email) => pre + (email.chosen ? 1 : 0), 0)\r\n\t\t//total amount\r\n\t\tconst total = emails.length\r\n\t\treturn (\r\n\t\t\t<div className=\"email-main\">\r\n\t\t\t\t<div className=\"addemailbutton\">\r\n\t\t\t\t\t<button onClick={() => this.handleCreate()} className=\"addemail-btn\" >Addieren eine neue Emailadresse!(Addieren Eingaben mit 'Enter'-Taste)</button>\r\n\t\t\t\t\t{this.state.addButtonClick ?\r\n\t\t\t\t\t\t<div className=\"inputbox\">\r\n\t\t\t\t\t\t\t<input value={this.state.inputemail.address} onKeyUp={this.handleKeyUp} onChange={this.inputchange} type=\"text\" placeholder=\"input email address with ENTER-key\" className=\"emailinput\" />\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t: null}\r\n\r\n\t\t\t\t</div>\r\n\r\n\t\t\t\t{emails.map(emailObj => {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\t<li style={{ backgroundColor: mouse ? '#ddd' : 'white' }} onMouseEnter={this.handleMouse(true)} onMouseLeave={this.handleMouse(false)}>\r\n\t\t\t\t\t\t\t<label>\r\n\t\t\t\t\t\t\t\t<input className='emailitemcheck' type=\"checkbox\" checked={emailObj.chosen} onChange={(e: React.ChangeEvent<HTMLInputElement>): void => this.handleCheck(emailObj.id, e.target.checked)} />\r\n\t\t\t\t\t\t\t\t<span>{emailObj.address}</span>\r\n\t\t\t\t\t\t\t</label>\r\n\t\t\t\t\t\t\t<button onClick={() => this.handleDelete(emailObj.id)} className=\"btn-item\" style={{ display: mouse ? 'block' : 'none' }}>Löschen</button>\r\n\t\t\t\t\t\t</li>\r\n\t\t\t\t\t)\r\n\t\t\t\t})}\r\n\r\n\t\t\t\t<div className=\"handleallemail\">\r\n\t\t\t\t\t<label>\r\n\t\t\t\t\t\t<input className='chooseall' type=\"checkbox\" onChange={this.chooseAllEmail} checked={chosenCount === total && total !== 0 ? true : false} />\r\n\t\t\t\t\t</label>\r\n\t\t\t\t\t<span>\r\n\t\t\t\t\t\t<span>Gewählt: {chosenCount}</span> / Insegesamt: {total}\r\n\t\t\t\t\t</span>\r\n\t\t\t\t\t<button onClick={() => this.clearAllChosen()} className=\"btn-clear\">Löschen alle gewählte Emailadressen!</button>\r\n\t\t\t\t</div>\r\n\r\n\t\t\t\t<div className=\"deliverybutton\">\r\n\t\t\t\t\t<button onClick={() => this.delivery()} className=\"delivery-btn\" >Liefern Aus!</button>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t)\r\n\t}\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\DiagramList\\index.jsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LinkText\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\QRImage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ChangeToVisuBtn\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataPoint.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\TimeSpan.tsx",["345"],"import { runInThisContext } from \"node:vm\";\r\n\r\n/**\r\n * Diese Klasse repräsentiert ein Zeitfenster.\r\n * Mit start als Anfang und end als Ende des Zeitfensters.\r\n */\r\nexport class TimeSpan {\r\n  private start: number; //Startpunkt des Zeitfensters in Sekunden.\r\n  private end: number; //Enpunkt des Zeitfensters in Sekunden.\r\n\r\n  /**\r\n   * Erstellt ein Zeitfenster.\r\n   * @param start Startpunkt in Sekunden (start >= 0)\r\n   * @param end Endpunkt in Sekunden (end >= start)\r\n   */\r\n  public constructor(start: number, end: number) {\r\n    if (start >= 0) {\r\n      this.start = start;\r\n    } else {\r\n      this.start = 0;\r\n    }\r\n    if (end >= this.start) {\r\n      this.end = end;\r\n    } else {\r\n      this.end = this.start;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setzt das übergebene Zeitfenster als Zeitfenster, wenn dies den Anforderungen entspricht. (0 <= start <= end)\r\n   * @returns false, falls das Zeitfenster nicht gesetzt wurde\r\n   */\r\n  public setTimeSpan(span: { start: number, end: number; }): boolean {\r\n    if (span.end >= span.start && span.start >= 0) {\r\n      this.start = span.start;\r\n      this.end = span.end;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt den Startpunkt in Sekunden zurück.\r\n   */\r\n  public getStart(): number {\r\n    return this.start;\r\n  }\r\n\r\n  /**\r\n   * Gibt den Enpunkt in Sekunden zurück.\r\n   */\r\n  public getEnd(): number {\r\n    return this.end;\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ProjectList\\index.tsx",["346","347","348","349","350","351","352"],"import React, { Component } from 'react';\r\nimport { NotificationManager } from 'react-notifications';\r\nimport ChangeToVisuBtn from '../ChangeToVisuBtn';\r\nimport ModelList from '../ModelList';\r\nimport QRImage from '../QRImage';\r\nimport './ProjectList.css';\r\n\r\n\r\nexport default class ProjectList extends Component {\r\n\r\n    props = {\r\n        projectData: [ { projectID: -1, projectName: \"null\", AIModelID: [ -1 ], } ],\r\n        pageSetCurrentprojekt: function ( currentProject: { projectID: number; projectName: string; AIModelID: number[]; } ) { },\r\n        pageLoadModel: function ( chosenmodelID: number ) { },\r\n        pageLoadProjekt: function ( currentProject: { projectID: number; projectName: string; AIModelID: number[]; } ) { },\r\n        pageChangeToVisu: function () { },\r\n        qr: ''\r\n    };\r\n\r\n    state = {\r\n        value: null,\r\n        click: false,\r\n        loadclick: false,\r\n        currentProject: { projectID: -1, projectName: \"\", AIModelID: [] }\r\n    };\r\n\r\n    private handleChange = ( e: React.ChangeEvent<HTMLSelectElement> ) => {\r\n        this.setState( {\r\n            value: e.target.value\r\n        } );\r\n    };\r\n\r\n    private handleChoose () {\r\n        if ( this.state.value == null ) {\r\n            NotificationManager.error( \"Sie haben noch kein Projekt gewählt\", \"\", 3000 );\r\n        } else {\r\n            this.props.projectData.map( ( projectObj ) => {\r\n                if ( this.state.value == projectObj.projectID ) {\r\n                    if ( projectObj.AIModelID.length != 0 ) {\r\n                        for ( let index = 0; index < this.props.projectData!.length; index++ ) {\r\n                            if ( projectObj.projectID == this.props.projectData![ index ].projectID ) {\r\n                                ;\r\n                                this.setState( projectObj );\r\n                                this.props.pageSetCurrentprojekt( projectObj );\r\n                                break;\r\n                            }\r\n                        }\r\n                        this.setState( { click: true } );\r\n                    } else {\r\n                        this.setState( { click: false } );\r\n                        NotificationManager.error( 'Es gibt keine Model in diesem Projekt!', \"\", 3000 );\r\n                    }\r\n                }\r\n            } );\r\n        }\r\n    }\r\n\r\n    private handleLoad () {\r\n        if ( this.state.value == null ) {\r\n            NotificationManager.error( \"Sie haben noch kein Projekt gewählt\", \"\", 3000 );\r\n        } else {\r\n            this.props.projectData.map( ( projectObj ) => {\r\n                if ( this.state.value == projectObj.projectID ) {\r\n                    let id: number = projectObj.projectID;\r\n                    this.props.pageLoadProjekt( projectObj );\r\n                    this.setState( { loadclick: true } );\r\n                }\r\n            } );\r\n        }\r\n    }\r\n\r\n    render () {\r\n        return (\r\n            <section className='projectlist'>\r\n                <label>ProjektList</label>\r\n                <select onChange={ this.handleChange }>\r\n                    <option>Projekt Wählen</option>\r\n                    { this.props.projectData.map( ( projectObj ) => {\r\n                        return <option value={ projectObj.projectID } key={ projectObj.projectID }>{ projectObj.projectName }</option>;\r\n                    } ) }\r\n                </select>\r\n                <button onClick={ () => this.handleChoose() } className=\"pl-btn\" type=\"button\" >Modellliste ladent </button>\r\n                <button onClick={ () => this.handleLoad() } className=\"pl-btn\" type=\"button\" >Projekt laden</button>\r\n                {this.state.loadclick ? <div> <QRImage qr={ this.props.qr } /><ChangeToVisuBtn pageChangeToVisu={ this.props.pageChangeToVisu } /></div> : null }\r\n                {this.state.click ? <div> <ModelList pageLoadModel={ this.props.pageLoadModel } currentProject={ this.state.currentProject } /></div> : null }\r\n            </section>\r\n\r\n        );\r\n    }\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ModelCreationComponents\\Train\\index.tsx",["353","354"],"import React, { Component } from 'react';\r\nimport NewWindow from 'react-new-window';\r\nimport { NotificationContainer, NotificationManager } from 'react-notifications';\r\nimport 'react-notifications/lib/notifications.css';\r\nimport './Train.css'\r\nexport default class Train extends Component {\r\n\tprops = {\r\n\t\tdataSetMetas: [] as { dataSetID: number, dataSetName: string }[],\r\n\t\ttrain: function (dataSets: number[], imputator: string, classifier: string, scaler: string, features: string[]) { }\r\n\t}\r\n\tstate = {\r\n\t\tmouse: false,\r\n\t\topenNewWindow: false,\r\n\t\tvalue: '',\r\n\t\tdatabaseList: [] as { dataSetID: number, dataSetName: string, chosen: boolean; }[],\r\n\t\tdatasets: [] as { dataSetID: number, dataSetName: string, chosen: boolean; }[],\r\n\t\timputators: [\r\n\t\t\t{ name: \"Mittel\", checked: true, tag: 'MEAN' },\r\n/*\t\t\tNOT IMPLEMENTED\r\n\t\t\t{ name: \"Letzer Wert fortgeführt\", checked: false, tag: 'FORWARD' },\r\n\t\t\t{ name: \"Bewegter Durchschnitt\", checked: false, tag: 'MOVING' },\r\n\t\t\t{ name: \"Lineare Interpolation\", checked: false, tag: 'LINEAR' },\r\n\t\t\t{ name: \"Spline Interpolation\", checked: false, tag: 'SPLINE' }*/\r\n\t\t],\r\n\t\tscalers: [\r\n\t\t\t{ name: \"Standard Scaler\", checked: false, tag: 'STANDARD' },\r\n\t\t\t{ name: \"Robust Scaler\", checked: false, tag: 'ROBUST' },\r\n\t\t\t{ name: \"Min-Max Scaler\", checked: false, tag: 'MIN_MAX' },\r\n\t\t\t{ name: \"Normalizer\", checked: false, tag: 'NORMALIZER' },\r\n\t\t\t{ name: \"Anteilstransformator\", checked: false, tag: 'SHARE' }\r\n\t\t],\r\n\t\tmyfeatures: [\r\n\t\t\t{ name: \"Minimum\", checked: false, tag: 'MIN' },\r\n\t\t\t{ name: \"Maximum\", checked: false, tag: 'MAX' },\r\n\t\t\t{ name: \"Varianz\", checked: false, tag: 'VARIANCE' },\r\n\t\t\t{ name: \"Energie\", checked: false, tag: 'ENERGY' },\r\n\t\t\t{ name: \"Fourier-Transformation\", checked: false, tag: 'FOURIER_TRANSFORM' },\r\n\t\t\t{ name: \"Mittelwert\", checked: false, tag: 'MEAN' },\r\n\t\t\t{ name: \"Autoregressiv\", checked: false, tag: 'AUTOREGRESSIVE' },\r\n\t\t\t{ name: \"Abweichung\", checked: false, tag: 'SKEWNESS' },\r\n\t\t\t{ name: \"Wölbung\", checked: false, tag: 'KURTOSIS' },\r\n\t\t],\r\n\t\tclassifiers: [\r\n\t\t\t{ name: \"MLPClassifier\", checked: false, tag: 'MLP' },\r\n\t\t\t{ name: \"RandomForestClassifier\", checked: false, tag: 'RANDOM_FOREST' },\r\n\t\t\t{ name: \"KNeighborsClassifier\", checked: false, tag: 'K_NEIGHOBORS' },\r\n\t\t\t{ name: \"Support Vector Machine\", checked: false, tag: 'SVM' }\r\n\t\t],\r\n\t\tchosenScaler: 0,\r\n\t\tchosenclassifier: 0,\r\n\t\tchosenImputator: 0\r\n\t};\r\n\r\n\t/**\r\n\t * Befüllt die beiden state-Variablen, die so aussehen, als müssten da die Datensätze des aktuellen Projekts rein, \r\n\t * mit den Daten aus der props-Variable dataSetMetas.\r\n\t */\r\n\tprivate fillState(): void {\r\n\t\tfor (const x of this.props.dataSetMetas) {\r\n\t\t\tthis.state.databaseList.push({dataSetName: x.dataSetName, dataSetID: x.dataSetID, chosen: false})\r\n\t\t\tthis.state.datasets.push({dataSetName: x.dataSetName, dataSetID: x.dataSetID, chosen: false})\r\n\t\t}\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tlet newDatabaseList: { dataSetID: number, dataSetName: string, chosen: boolean; }[] = [];\r\n\t\tthis.props.dataSetMetas?.map((dataset) => {\r\n\t\t\tnewDatabaseList.push({ dataSetID: dataset.dataSetID, dataSetName: dataset.dataSetName, chosen: false });\r\n\t\t})\r\n\t\tthis.setState({ databaseList: newDatabaseList });\r\n\r\n\t}\r\n\r\n\thandleMouse = (flag: boolean) => {\r\n\t\treturn () => {\r\n\t\t\tthis.setState({ mouse: flag });\r\n\t\t};\r\n\t};\r\n\r\n\thandleCheck = (id: number, chosen: boolean) => {\r\n\t\tconst { datasets } = this.state;\r\n\t\tconst newDatasets = datasets.map((dataset) => {\r\n\t\t\t// eslint-disable-next-line\r\n\t\t\tif (dataset.dataSetID == id) return { ...dataset, chosen };\r\n\t\t\telse return dataset;\r\n\t\t});\r\n\t\tthis.setState({ datasets: newDatasets });\r\n\t};\r\n\r\n\thandleDelete = (id: number) => {\r\n\t\tif (window.confirm('Sind Sie sicher, die gewählt Emailadresse löschen zu wollen?')) {\r\n\t\t\tconst { datasets } = this.state;\r\n\t\t\tconst newDatasets = datasets.filter((dataset) => {\r\n\t\t\t\treturn dataset.dataSetID !== id;\r\n\t\t\t});\r\n\t\t\t//update emailList\r\n\t\t\tthis.setState({ datasets: newDatasets });\r\n\t\t}\r\n\t};\r\n\r\n\t//addDataset for add new Dataset\r\n\taddDataset = (datasetObj: { dataSetID: number, dataSetName: string, chosen: boolean; }) => {\r\n\t\t//get orignal datasetList\r\n\t\tconst { datasets } = this.state;\r\n\t\t//add new one\r\n\t\tconst newDatasets = [datasetObj, ...datasets];\r\n\t\t//update datasetList\r\n\t\tthis.setState({ datasets: newDatasets });\r\n\t};\r\n\r\n\thandleCreate = () => {\r\n\t\t//if (this.state.databaseList == []) {\r\n\t\t//\t}\r\n\t\tconst flag = !this.state.openNewWindow;\r\n\t\tthis.setState({ openNewWindow: flag });\r\n\t};\r\n\r\n\thandleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\r\n\t\tthis.setState({\r\n\t\t\tvalue: e.target.value\r\n\t\t});\r\n\t};\r\n\r\n\thandleChoose = () => {\r\n\t\t/* wait to change load model*/\r\n\t\tthis.setState({ openNewWindow: false });\r\n\t\t// eslint-disable-next-line\r\n\t\tif (this.state.value == '') {\r\n\t\t\tNotificationManager.error(\"Keine Option ausgewählt!\", \"\", 3000);\r\n\t\t} else {\r\n\t\t\tconst { databaseList } = this.state;\r\n\t\t\tconst newDatabaseList1 = databaseList.map((databaseObj) => {\r\n\t\t\t\t// eslint-disable-next-line\r\n\t\t\t\tif (databaseObj.dataSetName == this.state.value) {\r\n\t\t\t\t\tdatabaseObj.chosen = true;\r\n\t\t\t\t\tconst datasetObj = { dataSetID: databaseObj.dataSetID, dataSetName: databaseObj.dataSetName, chosen: false };\r\n\t\t\t\t\tthis.addDataset(datasetObj);\r\n\t\t\t\t}\r\n\t\t\t\treturn databaseObj;\r\n\t\t\t}\r\n\t\t\t);\r\n\t\t\tconst newDatabaseList2 = newDatabaseList1.filter((databaseObj) => {\r\n\t\t\t\t// eslint-disable-next-line\r\n\t\t\t\treturn databaseObj.chosen == false;\r\n\t\t\t});\r\n\t\t\t//update emailList\r\n\t\t\tthis.setState({ databaseList: newDatabaseList2 });\r\n\t\t}\r\n\t};\r\n\r\n\toptions = () => {\r\n\t\tconst { databaseList } = this.state;\r\n\t\t/*way to add new into list\r\n\t\tand wait to get databaseList\r\n\t\tconst newdatabase = {id:'003', name:'dataset3', chosen: false}\r\n\t\tdatabaseList.push(newdatabase)\r\n\t\t*/\r\n\t\treturn databaseList.map(dataset =>\r\n\t\t\t<option key={dataset.dataSetID} value={dataset.dataSetName}>{dataset.dataSetName}</option>);\r\n\t};\r\n\r\n\thandleImputation = (index: number) => {\r\n\t\tvar newList = [...this.state.imputators];\r\n\t\tvar newChosen = this.state.chosenImputator;\r\n\t\tif (newList[index].checked) { newChosen--; }\r\n\t\telse { newChosen++; }\r\n\t\tif (newChosen <= 1) {\r\n\t\t\tnewList[index].checked = !newList[index].checked;\r\n\t\t\tthis.setState({ chosenImputator: newChosen, imputators: newList });\r\n\t\t} else {\r\n\t\t\tNotificationManager.error(\"Es darf nur ein Imputer ausgewählt werden.\", \"\", 3000);\r\n\t\t\treturn;\r\n\t\t}\r\n\t};\r\n\r\n\thandleScaler = (index: number) => {\r\n\r\n\t\tvar newList = [...this.state.scalers];\r\n\t\tvar newChosen = this.state.chosenScaler;\r\n\t\tif (newList[index].checked) { newChosen--; }\r\n\t\telse { newChosen++; }\r\n\t\tif (newChosen <= 1) {\r\n\t\t\tnewList[index].checked = !newList[index].checked;\r\n\t\t\tthis.setState({ chosenScaler: newChosen });\r\n\t\t\tthis.setState({ scalers: newList });\r\n\t\t} else {\r\n\t\t\tNotificationManager.error(\"Es darf nur ein Scaler ausgewählt werden.\", \"\", 3000);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t};\r\n\r\n\thandleExtraction = (index: number) => {\r\n\t\tvar newList = [...this.state.myfeatures];\r\n\t\tnewList[index].checked = !newList[index].checked;\r\n\t\tthis.setState({ features: newList });\r\n\t};\r\n\r\n\thandleClassifier = (index: number) => {\r\n\t\tvar newList = [...this.state.classifiers];\r\n\t\tvar newChosen = this.state.chosenclassifier;\r\n\t\tif (newList[index].checked) { newChosen--; }\r\n\t\telse { newChosen++; }\r\n\t\tif (newChosen <= 1) {\r\n\t\t\tnewList[index].checked = !newList[index].checked;\r\n\t\t\tthis.setState({ chosenclassifier: newChosen });\r\n\t\t\tthis.setState({ classifiers: newList });\r\n\t\t} else {\r\n\t\t\tNotificationManager.error(\"Es darf nur ein Klassifizierer ausgewählt werden\", \"\", 3000);\r\n\t\t\treturn;\r\n\t\t}\r\n\t};\r\n\r\n\thandleTrain = () => {\r\n\t\tvar dataSets: number[] = [], imputator = \"\", classifier = '', scaler = '', features: string[] = [];\r\n\t\tconst { datasets, imputators, classifiers, scalers, myfeatures } = this.state;\r\n\t\tlet datasetsflag = true, imputatorsflag = true, classifiersflag = true, scalersflag = true, featuresflag = true, nochoice = false\r\n\t\tdatasets.map((datasetObj) => {\r\n\t\t\tif (datasetObj.chosen) {\r\n\t\t\t\tdatasetsflag = false\r\n\t\t\t\tdataSets.push(datasetObj.dataSetID);\r\n\t\t\t}\r\n\t\t\treturn datasetObj;\r\n\t\t});\r\n\t\timputators.map((imputatorObj) => {\r\n\t\t\tif (imputatorObj.checked) {\r\n\t\t\t\timputatorsflag = false\r\n\t\t\t\timputator = imputatorObj.tag;\r\n\t\t\t}\r\n\t\t\treturn imputatorObj;\r\n\t\t});\r\n\t\tclassifiers.map((classifierObj) => {\r\n\t\t\tif (classifierObj.checked) {\r\n\t\t\t\tclassifiersflag = false\r\n\t\t\t\tclassifier = classifierObj.tag;\r\n\t\t\t}\r\n\t\t\treturn classifierObj;\r\n\t\t});\r\n\t\tscalers.map((scalerObj) => {\r\n\t\t\tif (scalerObj.checked) {\r\n\t\t\t\tscalersflag = false\r\n\t\t\t\tscaler = scalerObj.tag;\r\n\t\t\t}\r\n\t\t\treturn scalerObj;\r\n\t\t});\r\n\t\tmyfeatures.map((featureObj) => {\r\n\t\t\tif (featureObj.checked) {\r\n\t\t\t\tfeaturesflag = false\r\n\t\t\t\tfeatures.push(featureObj.tag);\r\n\t\t\t}\r\n\t\t\treturn featureObj;\r\n\t\t});\r\n\t\tif (datasetsflag) {\r\n\t\t\tNotificationManager.error(\"Kein Datensatz ausgewählt!\", \"\", 3000);\r\n\t\t\tnochoice = true\r\n\t\t}\r\n\t\tif (imputatorsflag) {\r\n\t\t\tNotificationManager.error(\"Kein Imputer ausgewählt!\", \"\", 3000);\r\n\t\t\tnochoice = true\r\n\t\t}\r\n\t\tif (classifiersflag) {\r\n\t\t\tNotificationManager.error(\"Kein Klassifizierer ausgewählt!\", \"\", 3000);\r\n\t\t\tnochoice = true\r\n\t\t}\r\n\t\tif (scalersflag) {\r\n\t\t\tNotificationManager.error(\"Kein Scaler ausgewählt!\", \"\", 3000);\r\n\t\t\tnochoice = true\r\n\t\t}\r\n\t\tif (featuresflag) {\r\n\t\t\tNotificationManager.error(\"Keine Merkmale zur Extraktion ausgewählt!\", \"\", 3000);\r\n\t\t\tnochoice = true\r\n\t\t}\r\n\t\tif (nochoice) return\r\n\t\t//console.log(chosendataSets, chosenImputator, chosenclassifier, chosenscaler, chosenFeatures)\r\n\t\tthis.props.train(dataSets, imputator, classifier, scaler, features);\r\n\t};\r\n\r\n\trender() {\r\n\t\tthis.fillState();\r\n\t\tconst { mouse, datasets, imputators, scalers, myfeatures, classifiers } = this.state;\r\n\t\treturn (\r\n\t\t\t<div className=\"train\">\r\n\t\t\t\t<h3>Datasets</h3>\r\n\t\t\t\t{datasets.map(dataset => {\r\n\t\t\t\t\treturn (\r\n\r\n\t\t\t\t\t\t<li style={{ backgroundColor: mouse ? '#ddd' : 'white' }} onMouseEnter={this.handleMouse(true)} onMouseLeave={this.handleMouse(false)} className='list' >\r\n\t\t\t\t\t\t\t<label>\r\n\t\t\t\t\t\t\t\t<input type=\"checkbox\" checked={dataset.chosen} onChange={(e: React.ChangeEvent<HTMLInputElement>): void => this.handleCheck(dataset.dataSetID, e.target.checked)} />\r\n\t\t\t\t\t\t\t\t<span>{dataset.dataSetName}</span>\r\n\t\t\t\t\t\t\t</label>\r\n\t\t\t\t\t\t\t<button onClick={() => this.handleDelete(dataset.dataSetID)} type='button' className=\"btn-item\" style={{ display: mouse ? 'block' : 'none' }}>Löschen</button>\r\n\t\t\t\t\t\t</li>\r\n\t\t\t\t\t);\r\n\t\t\t\t})}\r\n\r\n\t\t\t\t<div className=\"adddatasetbutton\">\r\n\t\t\t\t\t{this.state.openNewWindow && (\r\n\t\t\t\t\t\t<NewWindow>\r\n\t\t\t\t\t\t\t<div className=\"login-window\">\r\n\t\t\t\t\t\t\t\t<h1>DatabaseList</h1>\r\n\t\t\t\t\t\t\t\t<select onChange={this.handleChange}>\r\n\t\t\t\t\t\t\t\t\t<option value=\"\">choose dataset</option>\r\n\t\t\t\t\t\t\t\t\t{this.options()}\r\n\t\t\t\t\t\t\t\t</select>\r\n\t\t\t\t\t\t\t\t<button onClick={this.handleChoose} className=\"choose-btn\" type='button' >Add!</button>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</NewWindow>\r\n\t\t\t\t\t)}\r\n\t\t\t\t\t<button onClick={() => this.handleCreate()} className=\"create-btn\" type='button' >Add new Dataset</button>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div className=\"list\">\r\n\t\t\t\t\t<div className=\"imputationlist\">\r\n\t\t\t\t\t\t<h3>Imputation</h3>\r\n\t\t\t\t\t\t{imputators.map((imputator, index) => {\r\n\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t<input className='imputationcheck' type=\"checkbox\" value={index} checked={imputator.checked} onChange={() => this.handleImputation(index)} /><span>{imputator.name}</span>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t})}\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div className=\"scalerlist\">\r\n\t\t\t\t\t\t<h3>Normalisierung</h3>\r\n\t\t\t\t\t\t{scalers.map((scaler, index) => {\r\n\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t<input className='scalercheck' type=\"checkbox\" value={index} checked={scaler.checked} onChange={() => this.handleScaler(index)} /><span>{scaler.name}</span>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\r\n\t\t\t\t<div className=\"list\">\r\n\t\t\t\t\t<div className=\"extractionlist\">\r\n\t\t\t\t\t\t<h3>Merkmalextraktion</h3>\r\n\t\t\t\t\t\t{myfeatures.map((extraction, index) => {\r\n\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t<input className='featurecheck' type=\"checkbox\" value={index} checked={extraction.checked} onChange={() => this.handleExtraction(index)} /><span>{extraction.name}</span>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div className=\"classifierlist\">\r\n\t\t\t\t\t\t<h3>Modell</h3>\r\n\t\t\t\t\t\t{classifiers.map((classifier, index) => {\r\n\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t<input className='classifiercheck' type=\"checkbox\" value={index} checked={classifier.checked} onChange={() => this.handleClassifier(index)} /><span>{classifier.name}</span>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t})}\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<br></br>\r\n\r\n\t\t\t\t<div className=\"clearfloat\">\r\n\t\t\t\t\t<button onClick={() => this.handleTrain()} className=\"train-btn\" type='button' >Train Start!</button>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\r\n\r\n\t\t);\r\n\t}\r\n\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ModelList\\index.tsx",["355"],"import React, { Component } from 'react'\r\nimport { NotificationManager } from 'react-notifications'\r\n\r\nexport default class ModelList extends Component {\r\n\r\n    props = {\r\n        currentProject: { projectID: -1, projectName: \"null\", AIModelID: [-1] },\r\n        pageLoadModel: function (chosenmodelID: number) { }\r\n    }\r\n\r\n    state = {\r\n        chosenmodelID: -1\r\n    }\r\n\r\n    handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\r\n        this.setState({\r\n            chosenmodelID: e.target.value\r\n        })\r\n    }\r\n\r\n    handleChoose() {\r\n        /* wait to change load model*/\r\n        if (this.state.chosenmodelID == -1) {\r\n            NotificationManager.error('Sie haben noch kein Modell gewählt!', \"\", 3000)\r\n        } else {\r\n            this.props.pageLoadModel(this.state.chosenmodelID)\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <section>\r\n                <label>ModellList</label>\r\n                <select onChange={this.handleChange}>\r\n                    <option>Modell Wählen</option>\r\n                    {this.props.currentProject.AIModelID.map((modelObj) => {\r\n                        return <option value={modelObj} key={modelObj} >Modell{modelObj}</option>\r\n                    })}\r\n                </select>\r\n                <button onClick={() => this.handleChoose()} className=\"btn\" >Laden das gewählte Modell(zu Auslieferungsseite)</button>\r\n            </section>\r\n        )\r\n    }\r\n}\r\n",{"ruleId":"356","severity":1,"message":"357","line":4,"column":10,"nodeType":"358","messageId":"359","endLine":4,"endColumn":16},{"ruleId":"360","severity":1,"message":"361","line":99,"column":5,"nodeType":"362","messageId":"363","endLine":107,"endColumn":6},{"ruleId":"360","severity":1,"message":"361","line":114,"column":9,"nodeType":"364","messageId":"363","endLine":114,"endColumn":15},{"ruleId":"360","severity":1,"message":"361","line":118,"column":9,"nodeType":"364","messageId":"363","endLine":118,"endColumn":15},{"ruleId":"365","severity":1,"message":"366","line":64,"column":13,"nodeType":"367","messageId":"368","endLine":67,"endColumn":23},{"ruleId":"356","severity":1,"message":"369","line":8,"column":10,"nodeType":"358","messageId":"359","endLine":8,"endColumn":26},{"ruleId":"370","severity":1,"message":"371","line":229,"column":29,"nodeType":"372","messageId":"368","endLine":229,"endColumn":31},{"ruleId":"356","severity":1,"message":"373","line":9,"column":33,"nodeType":"358","messageId":"359","endLine":9,"endColumn":52},{"ruleId":"374","severity":1,"message":"375","line":16,"column":13,"nodeType":"376","messageId":"377","endLine":16,"endColumn":22,"fix":"378"},{"ruleId":"370","severity":1,"message":"371","line":121,"column":24,"nodeType":"372","messageId":"368","endLine":121,"endColumn":26},{"ruleId":"379","severity":1,"message":"380","line":62,"column":20,"nodeType":"381","messageId":"382","endLine":62,"endColumn":21,"fix":"383"},{"ruleId":"370","severity":1,"message":"384","line":311,"column":12,"nodeType":"372","messageId":"368","endLine":311,"endColumn":14},{"ruleId":"370","severity":1,"message":"384","line":344,"column":35,"nodeType":"372","messageId":"368","endLine":344,"endColumn":37},{"ruleId":"356","severity":1,"message":"385","line":1,"column":10,"nodeType":"358","messageId":"359","endLine":1,"endColumn":27},{"ruleId":"356","severity":1,"message":"386","line":1,"column":29,"nodeType":"358","messageId":"359","endLine":1,"endColumn":39},{"ruleId":"370","severity":1,"message":"384","line":30,"column":17,"nodeType":"372","messageId":"368","endLine":30,"endColumn":19},{"ruleId":"370","severity":1,"message":"384","line":79,"column":29,"nodeType":"372","messageId":"368","endLine":79,"endColumn":31},{"ruleId":"370","severity":1,"message":"384","line":81,"column":36,"nodeType":"372","messageId":"368","endLine":81,"endColumn":38},{"ruleId":"387","severity":1,"message":"388","line":94,"column":80,"nodeType":"389","messageId":"390","endLine":94,"endColumn":82},{"ruleId":"387","severity":1,"message":"388","line":94,"column":104,"nodeType":"389","messageId":"390","endLine":94,"endColumn":106},{"ruleId":"370","severity":1,"message":"384","line":98,"column":35,"nodeType":"372","messageId":"368","endLine":98,"endColumn":37},{"ruleId":"356","severity":1,"message":"391","line":9,"column":10,"nodeType":"358","messageId":"359","endLine":9,"endColumn":31},{"ruleId":"356","severity":1,"message":"373","line":9,"column":33,"nodeType":"358","messageId":"359","endLine":9,"endColumn":52},{"ruleId":"374","severity":1,"message":"375","line":13,"column":10,"nodeType":"376","messageId":"377","endLine":13,"endColumn":19,"fix":"392"},{"ruleId":"370","severity":1,"message":"384","line":138,"column":33,"nodeType":"372","messageId":"368","endLine":138,"endColumn":35},{"ruleId":"370","severity":1,"message":"384","line":29,"column":41,"nodeType":"372","messageId":"368","endLine":29,"endColumn":43},{"ruleId":"356","severity":1,"message":"373","line":2,"column":10,"nodeType":"358","messageId":"359","endLine":2,"endColumn":29},{"ruleId":"393","severity":1,"message":"394","line":31,"column":9,"nodeType":"395","endLine":31,"endColumn":32},{"ruleId":"393","severity":1,"message":"394","line":32,"column":9,"nodeType":"395","endLine":32,"endColumn":32},{"ruleId":"393","severity":1,"message":"394","line":33,"column":9,"nodeType":"395","endLine":33,"endColumn":32},{"ruleId":"393","severity":1,"message":"394","line":34,"column":9,"nodeType":"395","endLine":34,"endColumn":32},{"ruleId":"393","severity":1,"message":"394","line":35,"column":9,"nodeType":"395","endLine":35,"endColumn":32},{"ruleId":"396","severity":1,"message":"397","line":55,"column":18,"nodeType":"358","messageId":"398","endLine":55,"endColumn":19},{"ruleId":"370","severity":1,"message":"384","line":70,"column":23,"nodeType":"372","messageId":"368","endLine":70,"endColumn":25},{"ruleId":"370","severity":1,"message":"384","line":73,"column":23,"nodeType":"372","messageId":"368","endLine":73,"endColumn":25},{"ruleId":"393","severity":1,"message":"394","line":98,"column":9,"nodeType":"395","endLine":98,"endColumn":32},{"ruleId":"393","severity":1,"message":"394","line":99,"column":9,"nodeType":"395","endLine":99,"endColumn":32},{"ruleId":"393","severity":1,"message":"394","line":100,"column":9,"nodeType":"395","endLine":100,"endColumn":32},{"ruleId":"356","severity":1,"message":"391","line":2,"column":10,"nodeType":"358","messageId":"359","endLine":2,"endColumn":31},{"ruleId":"356","severity":1,"message":"399","line":1,"column":10,"nodeType":"358","messageId":"359","endLine":1,"endColumn":16},{"ruleId":"356","severity":1,"message":"400","line":2,"column":17,"nodeType":"358","messageId":"359","endLine":2,"endColumn":26},{"ruleId":"401","severity":1,"message":"402","line":2,"column":8,"nodeType":"358","messageId":"359","endLine":2,"endColumn":14},{"ruleId":"401","severity":1,"message":"403","line":3,"column":8,"nodeType":"358","messageId":"359","endLine":3,"endColumn":15},{"ruleId":"370","severity":1,"message":"371","line":35,"column":33,"nodeType":"372","messageId":"368","endLine":35,"endColumn":35},{"ruleId":"404","severity":1,"message":"397","line":53,"column":22,"nodeType":"358","messageId":"398","endLine":53,"endColumn":23},{"ruleId":"405","severity":1,"message":"406","line":57,"column":17,"nodeType":"407","messageId":"408","endLine":67,"endColumn":18},{"ruleId":"370","severity":1,"message":"384","line":68,"column":27,"nodeType":"372","messageId":"368","endLine":68,"endColumn":29},{"ruleId":"370","severity":1,"message":"384","line":71,"column":27,"nodeType":"372","messageId":"368","endLine":71,"endColumn":29},{"ruleId":"356","severity":1,"message":"373","line":9,"column":33,"nodeType":"358","messageId":"359","endLine":9,"endColumn":52},{"ruleId":"374","severity":1,"message":"375","line":13,"column":10,"nodeType":"376","messageId":"377","endLine":13,"endColumn":19,"fix":"409"},{"ruleId":"356","severity":1,"message":"410","line":1,"column":10,"nodeType":"358","messageId":"359","endLine":1,"endColumn":18},{"ruleId":"356","severity":1,"message":"411","line":2,"column":10,"nodeType":"358","messageId":"359","endLine":2,"endColumn":23},{"ruleId":"370","severity":1,"message":"371","line":59,"column":47,"nodeType":"372","messageId":"368","endLine":59,"endColumn":49},{"ruleId":"370","severity":1,"message":"384","line":63,"column":32,"nodeType":"372","messageId":"368","endLine":63,"endColumn":34},{"ruleId":"356","severity":1,"message":"391","line":3,"column":10,"nodeType":"358","messageId":"359","endLine":3,"endColumn":31},{"ruleId":"356","severity":1,"message":"412","line":1,"column":10,"nodeType":"358","messageId":"359","endLine":1,"endColumn":26},{"ruleId":"413","severity":1,"message":"414","line":37,"column":56,"nodeType":"415","messageId":"416","endLine":37,"endColumn":58},{"ruleId":"370","severity":1,"message":"384","line":38,"column":39,"nodeType":"372","messageId":"368","endLine":38,"endColumn":41},{"ruleId":"370","severity":1,"message":"371","line":39,"column":54,"nodeType":"372","messageId":"368","endLine":39,"endColumn":56},{"ruleId":"370","severity":1,"message":"384","line":41,"column":55,"nodeType":"372","messageId":"368","endLine":41,"endColumn":57},{"ruleId":"413","severity":1,"message":"414","line":62,"column":56,"nodeType":"415","messageId":"416","endLine":62,"endColumn":58},{"ruleId":"370","severity":1,"message":"384","line":63,"column":39,"nodeType":"372","messageId":"368","endLine":63,"endColumn":41},{"ruleId":"356","severity":1,"message":"417","line":64,"column":25,"nodeType":"358","messageId":"359","endLine":64,"endColumn":35},{"ruleId":"356","severity":1,"message":"391","line":3,"column":10,"nodeType":"358","messageId":"359","endLine":3,"endColumn":31},{"ruleId":"413","severity":1,"message":"414","line":67,"column":42,"nodeType":"415","messageId":"416","endLine":67,"endColumn":44},{"ruleId":"370","severity":1,"message":"384","line":23,"column":38,"nodeType":"372","messageId":"368","endLine":23,"endColumn":40},"@typescript-eslint/no-unused-vars","'States' is defined but never used.","Identifier","unusedVar","no-unreachable","Unreachable code.","VariableDeclaration","unreachableCode","BreakStatement","no-duplicate-case","Duplicate case label.","SwitchCase","unexpected","'isBreakStatement' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","'NotificationManager' is defined but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"418","text":"419"},"rest-spread-spacing","Unexpected whitespace after rest operator.","RestElement","unexpectedWhitespace",{"range":"420","text":"421"},"Expected '===' and instead saw '=='.","'AccelerometerData' is defined but never used.","'SensorData' is defined but never used.","no-mixed-operators","Unexpected mix of '||' and '&&'.","LogicalExpression","unexpectedMixedOperator","'NotificationContainer' is defined but never used.",{"range":"422","text":"419"},"react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","@typescript-eslint/no-redeclare","'i' is already defined.","redeclared","'Method' is defined but never used.","'Component' is defined but never used.","no-unused-vars","'PubSub' is defined but never used.","'diagram' is defined but never used.","no-redeclare","default-case","Expected a default case.","SwitchStatement","missingDefaultCase",{"range":"423","text":"419"},"'relative' is defined but never used.","'useDebugValue' is defined but never used.","'runInThisContext' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'id' is assigned a value but never used.",[706,706],"()",[2480,2481],"",[600,600],[555,555]]
