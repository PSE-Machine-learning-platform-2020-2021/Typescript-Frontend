[{"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\index.tsx":"1","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\reportWebVitals.ts":"2","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\MainController.tsx":"3","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ReferringController.tsx":"4","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\StartController.tsx":"5","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\AIController.tsx":"6","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Facade.tsx":"7","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\VisualizationController.tsx":"8","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DataCollectionController.tsx":"9","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\SensorManager.tsx":"10","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DeliveryController.tsx":"11","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\State.tsx":"12","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\index.tsx":"13","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\index.tsx":"14","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\index.tsx":"15","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\index.tsx":"16","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Language.tsx":"17","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeliveryFormat.tsx":"18","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\User.tsx":"19","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIBuilder.tsx":"20","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIDistributor.tsx":"21","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\SensorData.tsx":"22","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DatabaseConnector.tsx":"23","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ModelCreationController.tsx":"24","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\FinishController.tsx":"25","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\index.tsx":"26","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\index.tsx":"27","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\State.tsx":"28","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\State.tsx":"29","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\State.tsx":"30","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\State.tsx":"31","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Project.tsx":"32","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeviceData.tsx":"33","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\index.tsx":"34","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\State.tsx":"35","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Title\\index.tsx":"36","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\State.tsx":"37","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Input\\index.tsx":"38","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Countdown\\index.tsx":"39","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Title\\index.tsx":"40","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ConstantsText\\index.tsx":"41","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\NewProjectButton\\index.tsx":"42","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoginWindow\\index.tsx":"43","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoadModelButton\\index.tsx":"44","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Diagram\\index.tsx":"45","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Input\\Labelling\\index.tsx":"46","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Title\\index.tsx":"47","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Diagram\\index.tsx":"48","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataSet.tsx":"49","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Session.tsx":"50","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIModel.tsx":"51","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\DownloadButton\\index.tsx":"52","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\DiagramList\\index.tsx":"53","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\FinishButton\\index.tsx":"54","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\EmailList\\index.tsx":"55","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\State.tsx":"56","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataRow.tsx":"57","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Label.tsx":"58","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\QRImage\\index.tsx":"59","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LinkText\\index.tsx":"60","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ChangeToVisuBtn\\index.tsx":"61","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ProjectList\\index.tsx":"62","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ModelCreationComponents\\Train\\index.tsx":"63","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataPoint.tsx":"64","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\TimeSpan.tsx":"65","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ModelList\\index.tsx":"66","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ResultPage\\Result.tsx":"67","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ResultPage\\State.tsx":"68"},{"size":419,"mtime":1613977999233,"results":"69","hashOfConfig":"70"},{"size":440,"mtime":1613146123200,"results":"71","hashOfConfig":"70"},{"size":3971,"mtime":1618095471792,"results":"72","hashOfConfig":"70"},{"size":10082,"mtime":1618909404348,"results":"73","hashOfConfig":"70"},{"size":3568,"mtime":1617894332006,"results":"74","hashOfConfig":"70"},{"size":6117,"mtime":1618043168884,"results":"75","hashOfConfig":"70"},{"size":22708,"mtime":1618934299586,"results":"76","hashOfConfig":"70"},{"size":3736,"mtime":1618909404348,"results":"77","hashOfConfig":"70"},{"size":3066,"mtime":1618148134169,"results":"78","hashOfConfig":"70"},{"size":9461,"mtime":1618935306019,"results":"79","hashOfConfig":"70"},{"size":2296,"mtime":1618415515238,"results":"80","hashOfConfig":"70"},{"size":5142,"mtime":1617894332031,"results":"81","hashOfConfig":"70"},{"size":3556,"mtime":1616515796161,"results":"82","hashOfConfig":"70"},{"size":3300,"mtime":1618925946689,"results":"83","hashOfConfig":"70"},{"size":7585,"mtime":1618415515306,"results":"84","hashOfConfig":"70"},{"size":3760,"mtime":1618909404361,"results":"85","hashOfConfig":"70"},{"size":940,"mtime":1618043212145,"results":"86","hashOfConfig":"70"},{"size":214,"mtime":1613280191746,"results":"87","hashOfConfig":"70"},{"size":13430,"mtime":1618934299557,"results":"88","hashOfConfig":"70"},{"size":4979,"mtime":1617802594514,"results":"89","hashOfConfig":"70"},{"size":4983,"mtime":1618074229599,"results":"90","hashOfConfig":"70"},{"size":1609,"mtime":1617900063401,"results":"91","hashOfConfig":"70"},{"size":12113,"mtime":1618931178787,"results":"92","hashOfConfig":"70"},{"size":3388,"mtime":1617802594512,"results":"93","hashOfConfig":"70"},{"size":4061,"mtime":1617807543214,"results":"94","hashOfConfig":"70"},{"size":3335,"mtime":1618909404363,"results":"95","hashOfConfig":"70"},{"size":3120,"mtime":1618415515300,"results":"96","hashOfConfig":"70"},{"size":586,"mtime":1617719373909,"results":"97","hashOfConfig":"70"},{"size":581,"mtime":1616594917995,"results":"98","hashOfConfig":"70"},{"size":846,"mtime":1617721893722,"results":"99","hashOfConfig":"70"},{"size":967,"mtime":1616515796154,"results":"100","hashOfConfig":"70"},{"size":9478,"mtime":1618934299607,"results":"101","hashOfConfig":"70"},{"size":3071,"mtime":1618043212143,"results":"102","hashOfConfig":"70"},{"size":3833,"mtime":1618909404362,"results":"103","hashOfConfig":"70"},{"size":600,"mtime":1617721893724,"results":"104","hashOfConfig":"70"},{"size":361,"mtime":1618415515298,"results":"105","hashOfConfig":"70"},{"size":276,"mtime":1613662337789,"results":"106","hashOfConfig":"70"},{"size":5147,"mtime":1618909404359,"results":"107","hashOfConfig":"70"},{"size":1551,"mtime":1618415515245,"results":"108","hashOfConfig":"70"},{"size":433,"mtime":1618415515257,"results":"109","hashOfConfig":"70"},{"size":587,"mtime":1618415515290,"results":"110","hashOfConfig":"70"},{"size":1687,"mtime":1618909404357,"results":"111","hashOfConfig":"70"},{"size":4803,"mtime":1618909404357,"results":"112","hashOfConfig":"70"},{"size":2115,"mtime":1618909404356,"results":"113","hashOfConfig":"70"},{"size":5264,"mtime":1618415515273,"results":"114","hashOfConfig":"70"},{"size":6213,"mtime":1618909404352,"results":"115","hashOfConfig":"70"},{"size":431,"mtime":1618415515281,"results":"116","hashOfConfig":"70"},{"size":6360,"mtime":1618937833633,"results":"117","hashOfConfig":"70"},{"size":5382,"mtime":1618934299593,"results":"118","hashOfConfig":"70"},{"size":1837,"mtime":1618043212145,"results":"119","hashOfConfig":"70"},{"size":485,"mtime":1616514481828,"results":"120","hashOfConfig":"70"},{"size":799,"mtime":1618909404351,"results":"121","hashOfConfig":"70"},{"size":8027,"mtime":1618909404360,"results":"122","hashOfConfig":"70"},{"size":677,"mtime":1618909404361,"results":"123","hashOfConfig":"70"},{"size":8757,"mtime":1618909404351,"results":"124","hashOfConfig":"70"},{"size":698,"mtime":1616515796157,"results":"125","hashOfConfig":"70"},{"size":3276,"mtime":1618934296906,"results":"126","hashOfConfig":"70"},{"size":1877,"mtime":1618047786071,"results":"127","hashOfConfig":"70"},{"size":557,"mtime":1618909404358,"results":"128","hashOfConfig":"70"},{"size":902,"mtime":1618909404355,"results":"129","hashOfConfig":"70"},{"size":815,"mtime":1618909404354,"results":"130","hashOfConfig":"70"},{"size":4942,"mtime":1618909404358,"results":"131","hashOfConfig":"70"},{"size":14624,"mtime":1618909404354,"results":"132","hashOfConfig":"70"},{"size":1010,"mtime":1618043212141,"results":"133","hashOfConfig":"70"},{"size":1404,"mtime":1618048187749,"results":"134","hashOfConfig":"70"},{"size":1910,"mtime":1618415515293,"results":"135","hashOfConfig":"70"},{"size":3426,"mtime":1618909404362,"results":"136","hashOfConfig":"70"},{"size":669,"mtime":1617900168546,"results":"137","hashOfConfig":"70"},{"filePath":"138","messages":"139","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"fl9nei",{"filePath":"140","messages":"141","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"142","messages":"143","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"144","messages":"145","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"146","messages":"147","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"148","messages":"149","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"150","messages":"151","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"152"},{"filePath":"153","messages":"154","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"155","messages":"156","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"157","messages":"158","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"159"},{"filePath":"160","messages":"161","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"162","messages":"163","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"164","messages":"165","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"166","messages":"167","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"168","messages":"169","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"170","messages":"171","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"172","messages":"173","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"174","messages":"175","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"176","messages":"177","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"178"},{"filePath":"179","messages":"180","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"181","messages":"182","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"183","messages":"184","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"185","messages":"186","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"187"},{"filePath":"188","messages":"189","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"190","messages":"191","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"192","messages":"193","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"194","messages":"195","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"196","messages":"197","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"198","messages":"199","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"200","messages":"201","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"202","messages":"203","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"204","messages":"205","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"206"},{"filePath":"207","messages":"208","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"209","messages":"210","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"211","messages":"212","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"213","messages":"214","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"215","messages":"216","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"217","messages":"218","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"219","messages":"220","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"221","messages":"222","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"223","messages":"224","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"225","messages":"226","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"227","messages":"228","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"229","messages":"230","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"231","messages":"232","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"233","messages":"234","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"235"},{"filePath":"236","messages":"237","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"238","messages":"239","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"240","messages":"241","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"242"},{"filePath":"243","messages":"244","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"245","messages":"246","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"247","messages":"248","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"249","messages":"250","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"251"},{"filePath":"252","messages":"253","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"254","messages":"255","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"256","messages":"257","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"258","messages":"259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"260","messages":"261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"262","messages":"263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"264","messages":"265","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"266","messages":"267","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"268","messages":"269","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"270","messages":"271","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"272"},{"filePath":"273","messages":"274","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"275","messages":"276","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"277","messages":"278","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"279","messages":"280","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"281","messages":"282","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\reportWebVitals.ts",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\MainController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ReferringController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\StartController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\AIController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Facade.tsx",["283"],"import { DeliveryFormat } from \"./DeliveryFormat\";\r\nimport { DatabaseConnector } from \"./DatabaseConnector\";\r\nimport { Language, LanguageMessages } from \"./Language\";\r\nimport { Admin, Dataminer, AIModelUser, User } from \"./User\";\r\nimport { AIBuilder } from \"./AIBuilder\";\r\nimport { AIDistributor } from \"./AIDistributor\";\r\nimport { SensorData } from \"./SensorData\";\r\nimport { AIController } from \"../controller/AIController\";\r\nimport { IDataRowST, IDataRowSTRID } from \"./DataRow\";\r\nimport { ILabel } from \"./Label\";\r\nimport { ISpan } from \"./TimeSpan\";\r\nimport { IDevice } from \"./DeviceData\";\r\nimport { IDataPoint } from \"./DataPoint\";\r\n\r\ninterface FacadeInterface {\r\n  createDataSet(sensorTypeID: number[], dataSetName: string, datarowNames?: string[]): Promise<number>;\r\n  sendDataPoint(dataRowID: number, datapoint: IDataPoint): Promise<boolean>;\r\n  sendDataPointsAgain(): Promise<boolean>;\r\n  loadProject(projectID?: number): Promise<boolean>;\r\n  getProjectMetas(): Promise<{ projectID: number, projectName: string, AIModelID: number[]; }[]>;\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[];\r\n  getSessionID(): number;\r\n  getDataRows(dataSetID: number): { dataRows: IDataRowST[]; };\r\n  getCurrentDataRows(): { dataRows: IDataRowST[]; };\r\n  getMessages(): LanguageMessages | null;\r\n  setLanguage(languageCode: string): Promise<boolean>;\r\n  getLanguageMetas(): Promise<{ languageCode: number, languageName: string; }[]>;\r\n  getAdminEmail(): string;\r\n  deleteDataSet(dataSetID: number): Promise<boolean>;\r\n  registerAdmin(adminName: string, adminEmail: string, password: string): Promise<boolean>;\r\n  registerDataminer(dataminerName: string, sessionID: number): Promise<boolean>;\r\n  registerAIModelUser(aiModelUserName: string, modelID: number): Promise<boolean>;\r\n  loginAdmin(adminEmail: string, password: string): Promise<boolean>;\r\n  createProject(projectName: string): Promise<boolean>;\r\n  createLabel(span: ISpan, labelName: string): Promise<number>;\r\n  setLabel(labelID: number, span: ISpan, labelName?: string): Promise<boolean>;\r\n  deleteLabel(labelID: number): Promise<boolean>;\r\n  getLabels(): { labels: ILabel[]; };\r\n  classify(aiId: number, dataSetId: number, callBack: <R = unknown>(prediction: string | object) => R): void;\r\n  getAIModel(id: number, format: DeliveryFormat): object;\r\n  sendAIModel(model: number, ...recipients: string[]): boolean;\r\n  applyModel(dataSets: number[], imputator: string, classifier: string, scaler: string, features: string[],\r\n    trainingDataPercentage: number, slidingWindowSize: number, slidingWindowStep: number): void;\r\n} export type { FacadeInterface };\r\n\r\n/**\r\n * Die Facade stellt alle interaktionen mit dem Model zur Verfügung\r\n */\r\nexport class Facade {\r\n  private language?: Language; //Alle Nachrichten, in der geladenen Sprache\r\n  private dbCon: DatabaseConnector; //Die Verbindung zur Datenbank\r\n  private user?: User; //Der Benutzer, entweder Admin, Datenerfasser oder AIModelUser\r\n\r\n\r\n  /**\r\n   * Erstellt die Facade\r\n   * @param languageCode der Sprachcode von der Sprache, die geladen werden soll\r\n   */\r\n  constructor(languageCode: string) {\r\n    this.dbCon = new DatabaseConnector();\r\n    this.dbCon.loadLanguage({ languageCode }).then((language: LanguageMessages) => { this.language = new Language(language); });\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein Datensatz\r\n   * @param sensorTypeID muss der Sensor Typ ID von einem Sensor des Gerätes übereinstimmen\r\n   * @param dataSetName Name des Datensatzes\r\n   * @returns true, wenn der Datensatz erstellt wurde. \r\n   * Dies ist der Fall, wenn ein Benutzer existiert welcher in einer Session ist und alle Sensortypen existieren.\r\n   */\r\n  async createDataSet(sensorTypeID: number[], dataSetName: string, datarowNames?: string[]): Promise<number> {\r\n    if (this.user === undefined) {\r\n      return -2;\r\n    }\r\n    let sessionID: number = this.getSessionID();\r\n    if (sessionID === undefined) {\r\n      sessionID = 0;\r\n    }\r\n    if (sessionID > 0 || this.user.getName() === AIController.AI_MODEL_USER_NAME) {\r\n      let projectID: number = this.user.getCurrentProjectID();\r\n      if (projectID === undefined) {\r\n        projectID = 0;\r\n      }\r\n      let userID: number = this.user.getID();\r\n      let dataRow: { sensorID: number, datarowName?: string; }[] = [];\r\n      for (let i = 0; i < sensorTypeID.length; i++) {\r\n        let sensorID = sensorTypeID[i];\r\n        if (datarowNames != null && datarowNames.length >= i) {\r\n          dataRow.push({ sensorID, datarowName: datarowNames[i] });\r\n        }\r\n        else {\r\n          dataRow.push({ sensorID });\r\n        }\r\n      }\r\n      let dataSetID: number = await this.dbCon.createDataSet({ sessionID, projectID, userID, dataSetName, dataRow });\r\n      if (dataSetID <= 0) {\r\n        return -3;\r\n      }\r\n      var dataRows: IDataRowSTRID[] = [];\r\n      for (let i = 0; i < sensorTypeID.length; i++) {\r\n        dataRows.push({ sensorType: sensorTypeID[i], dataRow: [], dataRowID: i });\r\n      }\r\n      if (this.user.createDataSet(dataSetID, dataSetName, new Date().getMilliseconds(), dataRows) || this.user.getName() === AIController.AI_MODEL_USER_NAME) {\r\n        return dataSetID;\r\n      }\r\n      return -4;\r\n    }\r\n    return -5;\r\n  }\r\n\r\n  /**\r\n   * Sendet den Datenpunkt an die Datenbank und speichert den Punkt lokal\r\n   * @param dataRowID die ID der aktuellen Datenreihe des eingelesenen Datenpunkts\r\n   * @param value der SensorWert\r\n   * @param relativeTime die relative Zeit zum Aufnahmestart in Millisekunden\r\n   * @return true, wenn der Datenpunkt erfolgreich an die Datenbank gesendet wurde\r\n   */\r\n  async sendDataPoint(dataRowID: number, datapoint: IDataPoint[]): Promise<boolean> {\r\n    if (this.user !== undefined) {\r\n      let sessionID: number = this.getSessionID();\r\n      let userID: number = this.user.getID();\r\n      let dataSetID: number = this.user.getCurrentDataSetID();\r\n      this.user.addDatapoint(dataRowID, datapoint);\r\n      return this.dbCon.sendDataPoint({ sessionID, userID, dataSetID, dataRowID, datapoint });\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Email des Admins zurück\r\n   * @returns Email des Admins oder \"undefined\" wenn kein Admin angmeldet ist\r\n   */\r\n  getAdminMail(): string {\r\n    if (this.user != null && this.user instanceof Admin) {\r\n      return (this.user as Admin).getEmail();\r\n    }\r\n    return \"error\";\r\n  }\r\n\r\n  /**\r\n     * Sendet den aktuell bereits aufgenommenen Datensatz an die Datenbank\r\n     * Dafür da, falls die Verbindung verloren ging und der Datensatz neu hochgeladen werden muss\r\n     * @return true, wenn der Datensatz erfolgreich an die Datenbank gesendet wurde\r\n     */\r\n  async sendDataPointsAgain(): Promise<boolean> {\r\n    if (this.user !== undefined) {\r\n      let sessionID: number = this.getSessionID();\r\n      let userID: number = this.user.getID();\r\n      let dataSetID: number = this.user.getCurrentDataSetID();\r\n      let rows = this.user.getCurrentDataRows();\r\n      for (let i = 0; i < rows.dataRows.length; i++) {\r\n        var result = await this.dbCon.sendDataPointsAgain({ sessionID, userID, dataSetID, dataRowID: i, datapoints: rows.dataRows[i].datapoint });\r\n        if (!result) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Lädt aus der Datenbank das Projekt mit der übergebenen ID, hierfür muss der Admin angemeldet sein\r\n   * @param projectID die Projekt ID oder keine falls das aktuelle Projekt neu geladen werden soll\r\n   * @returns true, wenn das Projekt erfolgreich geladen wurde dies tritt nur ein, wenn eine Verbindung zur Datenbank besteht,\r\n   *          die Projekt ID existiert und der Admin dafür angemeldet ist\r\n   */\r\n  async loadProject(projectID?: number): Promise<boolean> {\r\n    if (this.user != null && this.user instanceof Admin) {\r\n      if (projectID == null) {\r\n        projectID = this.user?.getCurrentProjectID();\r\n      }\r\n      let adminEmail: string = this.user.getEmail();\r\n      let userID: number = this.user.getID();\r\n      return this.user.loadProject(await this.dbCon.loadProject({ userID, adminEmail, projectID }));\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /* Methode die noch nicht benutzt wird aber eventuell das laufgeschehen verbessern\r\n  /**\r\n     * Aktuallisiert aus der Datenbank das aktuelle Projekt, hierfür muss der Admin angemeldet sein und ein Projekt geladen sein\r\n     * @returns true, wenn das Projekt erfolgreich geladen wurde dies tritt nur ein, wenn eine Verbindung zur Datenbank besteht,\r\n     *          ein geladenes Projekt existiert und der Admin dafür angemeldet ist\r\n     \r\n  async updateCurrentProject(): Promise<boolean> {\r\n    if (this.user != null && this.user instanceof Admin) {\r\n      let projectID = this.user.getCurrentProjectID();\r\n      let adminEmail: string = this.user.getEmail();\r\n      let userID: number = this.user.getID();\r\n      return this.user.updateProject(await this.dbCon.updateProject({ userID, adminEmail, projectID }));\r\n    }\r\n    return false;\r\n  }*/\r\n\r\n\r\n  /**\r\n   * Lädt vom aktuell angemeldeten Admin von seinen Projekten den Namen, die Projekt ID und die AIModelIDs\r\n   * @returns Von allen Projekten des Admins Projekt ID und Projektname und die AIModelIDs\r\n   */\r\n  async getProjectMetas(): Promise<{ projectID: number, projectName: string, AIModelID: number[]; }[]> {\r\n    if (this.user != null) {\r\n      let userID: number = this.user.getID();\r\n      return await this.dbCon.getProjectMetas({ userID, adminEmail: this.getAdminEmail() });\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt von allen Datensätzen die Datensatz ID und der Datensatz Name zurück\r\n   */\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[] {\r\n    if (this.user !== undefined) {\r\n      return this.user.getDataSetMetas();\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID des aktuellen Projekts zurück, -1 falls kein aktuelles Projekt existiert\r\n   */\r\n  getSessionID(): number {\r\n    if (this.user != null) {\r\n      return this.user.getSessionID();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: IDataRowST[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getDataRows(dataSetID);\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen des aktuellen Datensatzes zurück\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: IDataRowST[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getCurrentDataRows();\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt aus der geladenen Sprache die Nachrichten die über die IDs angegeben werden\r\n   * @param messageID alle IDs, von denen die Sprachnachricht geladen werden soll\r\n   * @returns alle Nachrichten, in der gleichen Reihenfolge wie angefordert\r\n   */\r\n  getMessages(): LanguageMessages | null {\r\n    if (this.language != null) {\r\n      return this.language.getMessage();\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Gibt die auswählbaren Sensoren als ID mit ihrer Art in der Passenden Sprache zurück\r\n  \r\n  getAvailableSensors(): { sensorTypID: number, sensorType: string; }[] {\r\n    if (this.user != null && this.language != null) {\r\n      var sensors: { sensorTypID: number, sensorType: string; }[] = [];\r\n      let message: { messageID: number, message: string; }[] = this.language.getMessage(this.user.getAvailableSensors());\r\n      for (let i = 0; i < message.length; i++) {\r\n        sensors.push({ sensorTypID: message[i].messageID, sensorType: message[i].message });\r\n      }\r\n      return sensors;\r\n    }\r\n    return [];\r\n  }\r\n */\r\n\r\n  /**\r\n   * Lädt die Sprache aus der Datenbank mit dem übergebenen Sprachcode\r\n   * @param languageCode Sprachcode\r\n   * @returns true, falls die Sprache erfolgreich geladen wurde\r\n   */\r\n  async setLanguage(languageCode: string): Promise<boolean> {\r\n    if (this.language == null) {\r\n      const language: LanguageMessages = await this.dbCon.loadLanguage({ languageCode });\r\n      this.language = new Language(language);\r\n      return true;\r\n    } else if (languageCode !== this.language.getLanguageCode()) {\r\n      const language: LanguageMessages = await this.dbCon.loadLanguage({ languageCode });\r\n      return this.language.setLanguage(language);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gibt von allen in der Datenbank verfügbaren Sprachen den Sprachcode sowie den Sprachennamen zurück\r\n   */\r\n  getLanguageMetas(): Promise<{ languageCode: number, languageName: string; }[]> {\r\n    return this.dbCon.getLanguageMetas();\r\n  };\r\n\r\n  /**\r\n   * Gibt die Email vom Admin zurück, diese kann leer sein falls kein Admin angemeldet ist\r\n   */\r\n  getAdminEmail(): string {\r\n    if (this.user instanceof Admin) {\r\n      return this.user.getEmail();\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Löscht den Datensatz mit der übergebenen Datensatz ID\r\n   * @param dataSetID die Datensatz ID\r\n   * @returns true, wenn das löschen erfolgreich ist\r\n   */\r\n  async deleteDataSet(dataSetID: number): Promise<boolean> {\r\n    if (this.user != null && this.user.deleteDataSet(dataSetID)) {\r\n      let projectID: number = this.user.getCurrentProjectID();\r\n      if (projectID >= 0) {\r\n        let adminEmail: string = this.getAdminEmail();\r\n        let userID = this.user.getID();\r\n        return this.dbCon.deleteDataSet({ userID, adminEmail, projectID, dataSetID });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //wann Device erstellen ??? + constructor in User anpassen mit neuem Device parameter \r\n  async registerAdmin(adminName: string, adminEmail: string, password: string): Promise<boolean> {\r\n    //TODO Device\r\n    let device: IDevice = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let IDs: {\r\n      adminID: number, device: { deviceID: number, sensorID: number[]; };\r\n    } = await this.dbCon.registerAdmin({ adminName, adminEmail, password, device });\r\n    if (IDs.adminID >= 0) {\r\n      this.user = new Admin(IDs.adminID, IDs.device.deviceID, adminName, adminEmail);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async registerDataminer(dataminerName: string, sessionID: number): Promise<boolean> {\r\n    //TODO Device\r\n    let device: IDevice = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let dataminer:\r\n      {\r\n        dataminerID: number, device: { deviceID: number, sensorID: number[]; }, project: { projectID: number, projectName: string, sessionID: number; };\r\n      } = await this.dbCon.registerDataminer({ dataminerName, sessionID, device });\r\n    if (dataminer.dataminerID >= 0 && dataminer.device.deviceID >= 0) {\r\n      this.user = new Dataminer(dataminer.dataminerID, dataminer.device.deviceID, dataminerName);\r\n      this.user.loadProject(dataminer.project);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param aiModelUserName \r\n   */\r\n  async registerAIModelUser(aiModelUserName: string, modelID: number): Promise<boolean> {\r\n    //TODO Device\r\n    let device: IDevice = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let aiModelUser: {\r\n      aiModelUserID: number, device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    } = await this.dbCon.registerAIModelUser({ aiModelUserName, modelID, device });\r\n    if (aiModelUser.aiModelUserID >= 0 && aiModelUser.device.deviceID >= 0) {\r\n      this.user = new AIModelUser(aiModelUser.aiModelUserID, aiModelUser.device.deviceID, aiModelUserName);\r\n      this.user.loadProject(aiModelUser.project);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //TODO Device\r\n  async loginAdmin(adminEmail: string, password: string): Promise<boolean> {\r\n    if (this.user == null) {\r\n      let adminData: {\r\n        admin: { adminID: number, deviceID: number, adminName: string, email: string, device: IDevice; };\r\n      } = await this.dbCon.loginAdmin({ adminEmail, password });\r\n      if (adminData.admin != null && adminData.admin.adminID !== -1) {\r\n        let admin = adminData.admin;\r\n        this.user = new Admin(admin.adminID, admin.deviceID, admin.adminName, admin.email, admin.device);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /* eventuell implementieren\r\n    logoutAdmin(): boolean {\r\n      if (this.user != null) {\r\n        let logout = this.dbCon.logoutAdmin(this.getAdminEmail());\r\n        if (logout) {\r\n          delete this.user;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    */\r\n\r\n  /**\r\n   * Erstellt für den angemeldeten Admin ein neues Projekt\r\n   */\r\n  async createProject(projectName: string): Promise<boolean> {\r\n    if (this.user instanceof Admin) {\r\n      let userID = this.user.getID();\r\n      let adminEmail = this.getAdminEmail();\r\n      let project: { projectID: number, sessionID: number; } = await this.dbCon.createProject({ userID, adminEmail, projectName });\r\n      return this.user.createProject(project.projectID, project.sessionID, projectName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein neues Label für den aktuellen Datensatz\r\n   * @param span Start und Endzeit des Zeitfensters in Sekunden\r\n   */\r\n  async createLabel(span: ISpan, labelName: string): Promise<number> {\r\n    if (this.user != null) {\r\n      let sessionID: number = this.getSessionID();\r\n      let userID: number = this.user.getID();\r\n      let datasetID: number = this.user.getCurrentDataSetID();\r\n      let labelID: number = await this.dbCon.createLabel({ sessionID, userID, datasetID, label: { span, labelName } });\r\n      if (labelID >= 0) {\r\n        let created: boolean = this.user.createLabel(labelID, span, labelName);\r\n        if (created) {\r\n          return labelID;\r\n        }\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Überschreibt ein bestehendes Label mit den übergebenen Parametern\r\n   * @param labelID die LabelID, die schon exisiteren muss und überschrieben wird\r\n   * @param span Start und Endzeit des Zeitfensters in Sekunden\r\n   */\r\n  async setLabel(labelID: number, span: ISpan, labelName?: string): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let setted: boolean = this.user.setLabel(labelID, span, labelName);\r\n      if (setted) {\r\n        let sessionID: number = this.getSessionID();\r\n        let userID: number = this.user.getID();\r\n        let datasetID: number = this.user.getCurrentDataSetID();\r\n        return this.dbCon.setLabel({ sessionID, userID, datasetID, label: { labelID, span, labelName } });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht das bestehende Label mit der LabelID\r\n   * @param labelID die LabelID, die schon exisitert\r\n   */\r\n  async deleteLabel(labelID: number): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let deleted: boolean = this.user.deleteLabel(labelID);\r\n      if (deleted) {\r\n        let sessionID: number = this.getSessionID();\r\n        let userID: number = this.user.getID();\r\n        let dataSetID: number = this.user.getCurrentDataSetID();\r\n        return this.dbCon.deleteLabel({ sessionID, userID, dataSetID, labelID });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt die geladenen Labels zurück von dem aktuellen Datensatz\r\n   * @returns \r\n   */\r\n  getLabels(): { labels: ILabel[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getLabels();\r\n    }\r\n    return { labels: [] };\r\n  }\r\n\r\n  classify(aiId: number, dataSetId: number, callBack: <R = unknown>(prediction: string | object) => R): void {\r\n    let aiBuilder = new AIBuilder(aiId);\r\n    aiBuilder.classify(dataSetId, callBack);\r\n  };\r\n\r\n  getAIModel(id: number, format: DeliveryFormat): object {\r\n    let aiDist = new AIDistributor(id, format);\r\n    return aiDist.getAIModel();\r\n  }\r\n\r\n  /**\r\n   * Erzeugt eine Anfrage an den Server, an jede übergebene E-Mail-Adresse eine E-Mail zu versenden,\r\n   * die einen Link zur Startseite des mit übergebenen KI-Modells enthält.\r\n   * \r\n   * @param model      - Die ID des zu verteilenden KI-Modells.\r\n   * @param recipients - Die Liste der E-Mail-Adressen, an die das KI-Modell verteilt werden soll.\r\n   * @returns True, wenn die Anfrage an den Server erfolgreich durchgeführt werden konnte, False sonst.\r\n   */\r\n  sendAIModel(model: number, recipients: string[]): boolean {\r\n    const distributor = new AIDistributor(model, DeliveryFormat.WEB_APP);\r\n    return distributor.sendAIModel(recipients);\r\n  }\r\n\r\n  /**\r\n   * Diese Methode erzeugt eine Anfrage an den Server, die ihn damit beauftragt, ein KI-Modell mit den \r\n   * angegebenen Parametern zu erzeugen und zu trainieren. \r\n   * \r\n   * @param dataSets               - Die zum Training zu verwendenden Datensätze.\r\n   * @param imputator              - Der zur Vervollständigung der Daten zu verwendende Imputer.\r\n   * @param classifier             - Der Klassifizierer, der das Herzstück des zu erstellenden KI-Modells darstellt.\r\n   * @param scaler                 - Der Scaler, der die Daten für den Klassifizierer aufbereitet.\r\n   * @param features               - Die Merkmale, die aus den gegebenen Datensätzen herausgearbeitet werden sollen.\r\n   * @param trainingDataPercentage - Optional. Der Anteil der Daten, der zum Training des KI-Modells verwendet werden soll. \r\n   *                                 Standardmäßig sind das alle übergebenen Daten, da wir noch kein serverseitiges Testen der KI-Modell-Qualität durchführen.\r\n   * @param slidingWindowSize      - Optional. Die Größe der Datenblöcke, die jeweils verwertet werden. Standardwert ist 128 Datenpunkte.\r\n   * @param slidingWindowStep      - Optional. Die Schrittweite von einem Datenblock zum nächsten. Standardwert ist 64 Datenpunkte. \r\n   */\r\n  applyModel(dataSets: number[], imputator: string, classifier: string, scaler: string, features: string[],\r\n    trainingDataPercentage: number = 1, slidingWindowSize: number = 128, slidingWindowStep: number = 64): void {\r\n    const aiBuilder = new AIBuilder(-1);\r\n    const projectID = this.user!.getCurrentProjectID();\r\n    aiBuilder.applyModel(dataSets, imputator, classifier, scaler, features, projectID, trainingDataPercentage, slidingWindowSize, slidingWindowStep);\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\VisualizationController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DataCollectionController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\SensorManager.tsx",["284"],"import { MainController } from \"./MainController\";\r\nimport { Page } from \"../view/pages/PageInterface\";\r\nimport { IState, States } from \"../view/pages/State\";\r\nimport { Facade } from \"../model/Facade\";\r\nimport { State } from \"../view/pages/ModelCreationPage/State\";\r\nimport { shallow } from \"enzyme\";\r\nimport { IDataPoint } from \"../model/DataPoint\";\r\n\r\nexport class SensorManager {\r\n    private checkList: Promise<boolean>[] = [];\r\n    private currentSensors: Sensor[] = [];\r\n    private facade: Facade = MainController.getInstance().getFacade();\r\n    private waitTime: number = 5;\r\n    private readTime: number = 10;\r\n    private startTime: number = 10;\r\n    private page: Page | undefined = undefined;\r\n    private sensorTypes: number[] = [];\r\n    private dataPoints: { rowId: number, sensorType: number, value: number[]; relativeTime: number; }[] = [];\r\n    private dataRows: { sensorType: number, datapoint: { value: number[]; relativeTime: number; }[]; }[] = [];\r\n    private countPoints: number = 0;\r\n    private static readonly SHOW_POINTS_COUNT: number = 60;\r\n    private state?: IState;\r\n\r\n    /**\r\n    * Erzeugt eine neue Datenreihe und setzt diese damit als momentan benutzte Datenreihe. \r\n    * @param sensorTypes Die Angabe der zu benutzenden Sensoren. Die position im Array bestimmt die DataRow ID jedes Sensors.\r\n    * @returns Gibt true für ein erfolgreiches Erstellen eines Dataensatzes zurück, gibt sonst false zurück.\r\n    */\r\n    setUpDataRead(sensorTypes: number[], dataSetName: string, waitTime: number, readTime: number, saving: boolean) {\r\n        this.waitTime = waitTime;\r\n        this.readTime = readTime;\r\n        this.sensorTypes = sensorTypes;\r\n        for (let index = 0; index < sensorTypes.length; index++) {\r\n            switch (sensorTypes[index]) {\r\n                case 2:\r\n                    let accSensor = new Accelerometer({ frequency: 60 });\r\n                    this.currentSensors.push(accSensor);\r\n                    accSensor.addEventListener('reading', e => {\r\n                        this.getData(accSensor, index, sensorTypes[index], sensorTypes.length);\r\n                    });\r\n                    accSensor.addEventListener('error', event => {\r\n                        console.log(event.error.name, event.error.message);\r\n                    });\r\n                    break;\r\n                case 3:\r\n                    let gyroSensor = new Gyroscope({ frequency: 60 });\r\n                    this.currentSensors.push(gyroSensor);\r\n                    gyroSensor.addEventListener('reading', e => {\r\n                        this.getData(gyroSensor, index, sensorTypes[index], sensorTypes.length);\r\n                    });\r\n                    gyroSensor.addEventListener('error', event => {\r\n                        console.log(event.error.name, event.error.message);\r\n                    });\r\n                    break;\r\n                case 4:\r\n                    let magSensor = new Magnetometer({ frequency: 60 });\r\n                    this.currentSensors.push(magSensor);\r\n                    magSensor.addEventListener('reading', e => {\r\n                        this.getData(magSensor, index, sensorTypes[index], sensorTypes.length);\r\n                    });\r\n                    magSensor.addEventListener('error', event => {\r\n                        console.log(event.error.name, event.error.message);\r\n                    });\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        return (this.facade.createDataSet(sensorTypes, dataSetName));\r\n    }\r\n\r\n    /**\r\n    * Erfasst für den momentanene Datensatz Daten und sendet diese an die Explorer Datenbank.\r\n    * Wartet zuerst für die angegebene Wartezeit und nimmt dann für die angegeben Lesezeit daten auf.\r\n    */\r\n    readData(page: Page) {\r\n        this.page = page;\r\n        this.state = page.getState();\r\n        this.state!.recordingSettings!.usedSensorTypes = this.sensorTypes;\r\n        this.state!.currentState = States.waitForDB;\r\n        page.setState(this.state);\r\n        //Warte für waitTime und update dabei die Seite\r\n        let intervalId1 = setInterval(() => {\r\n            this.waitTime = this.waitTime - 1;\r\n            this.state!.recordingSettings!.waitTime = this.waitTime;\r\n            page.setState(this.state);\r\n            if (this.waitTime <= 0) {\r\n                clearInterval(intervalId1);\r\n                this.startTime = new Date().getTime();\r\n                for (let index = 0; index < this.currentSensors.length; index++) {\r\n                    this.currentSensors[index].start();\r\n                }\r\n                //Nimm Daten auf verteile sie an die Seite und das Modell. Erneuere dabei die aufnahmezeit auf der Seite\r\n                let intervalId2 = setInterval(() => {\r\n                    this.readTime = this.readTime - 1;\r\n                    while (this.dataPoints.length > 0) {\r\n                        let newDataPoint: IDataPoint[] = [];\r\n                        let rowID: number = this.dataPoints[0].rowId;\r\n                        for (let i = 0; i < this.dataPoints.length; i++) {\r\n                            if (rowID === this.dataPoints[i].rowId) {\r\n                                newDataPoint.push(this.dataPoints.splice(i, 1)[0]);\r\n                            }\r\n                        }\r\n                        this.checkList.push(MainController.getInstance().getFacade().sendDataPoint(rowID, newDataPoint));\r\n                    }\r\n\r\n                    if (this.readTime <= 0) {\r\n                        clearInterval(intervalId2);\r\n                        page.setState(this.state);\r\n                        for (let index = 0; index < this.currentSensors.length; index++) {\r\n                            this.currentSensors[index].stop();\r\n                        }\r\n                        console.log(this.countPoints);\r\n                        this.checkForErrors(this.state!, page);\r\n                    }\r\n                }, 1000);\r\n            }\r\n        }, 1000);\r\n    }\r\n\r\n    private async checkForErrors(state: State, page: Page) {\r\n        for (const element of this.checkList) {\r\n            let errorWhenSend = !(await element);\r\n            if (errorWhenSend) {\r\n                state.currentState = States.LoadError;\r\n            }\r\n        }\r\n        page.setState(state);\r\n    }\r\n\r\n    private async saveDatapointinRow(dataPoint: { rowId: number, sensorType: number, value: number[]; relativeTime: number; }, show: boolean) {\r\n        while (this.dataRows.length - 1 < dataPoint.rowId) {\r\n            this.dataRows.push({ sensorType: -1, datapoint: [] });\r\n        }\r\n        this.dataRows[dataPoint.rowId].sensorType = dataPoint.sensorType;\r\n        this.dataRows[dataPoint.rowId].datapoint.push({ value: dataPoint.value, relativeTime: dataPoint.relativeTime });\r\n\r\n        if (this.page !== undefined && show) {\r\n            this.state = this.page.getState();\r\n            this.state!.dataRows = this.dataRows;\r\n            this.page.setState(this.state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns Gibt als Zahl die Zeit in Sekunden zurück, für welche vor der Aufnahme gewartet wird. \r\n     */\r\n    getWaitTime() {\r\n        return this.waitTime;\r\n    }\r\n\r\n    /**\r\n     * @returns Gibt als Zahl die Zeit in Sekunden zurück, für welche die Aufnahme läuft. \r\n     */\r\n    getReadTime() {\r\n        return this.readTime;\r\n    }\r\n\r\n    /**\r\n    * Holt die Sensordaten für einen Sensor\r\n    * @param sensor der Sensor von dem die Daten gelsen werden\r\n    * @param sensorType Die ID des Sensortypes\r\n    */\r\n    private async getData(sensor: Magnetometer | Gyroscope | Accelerometer, rowId: number, sensorType: number, sensorCount: number) {\r\n        if (sensor.x === undefined || sensor.y === undefined || sensor.z === undefined) {\r\n            return;\r\n        }\r\n        const point = { rowId, sensorType, value: [sensor.x!, sensor.y!, sensor.z!], relativeTime: (new Date().getTime() - this.startTime) / 1000 };\r\n        this.dataPoints!.push(point);\r\n\r\n        this.countPoints++;\r\n        this.saveDatapointinRow(point, (this.countPoints % SensorManager.SHOW_POINTS_COUNT) === 0);\r\n    }\r\n\r\n    /**\r\n    * Prüft welche Sensoren verfügbar sind.\r\n    * @returns ein Array welches alle SensorTypeIDs enthält die verfügbar sind\r\n    */\r\n    async getAvailableSensors(): Promise<{ sensorTypID: number; sensorType: string; }[]> {\r\n        let sensors: { sensorTypID: number; sensorType: string; }[] = [];\r\n        let accelerometer = new Accelerometer({ frequency: 60 });\r\n        let accelerometerExist = this.existSensor(accelerometer);\r\n        let gyroscope = new Gyroscope({ frequency: 60 });\r\n        let gyroscopeExist = this.existSensor(gyroscope);\r\n\r\n        if (await accelerometerExist) {\r\n            sensors.push({ sensorTypID: 2, sensorType: \"Accelerometer\" });\r\n        }\r\n        if (await gyroscopeExist) {\r\n            sensors.push({ sensorTypID: 3, sensorType: \"Gyroscope\" });\r\n        }\r\n        return sensors;\r\n    };\r\n\r\n    private async existSensor(sensor: Sensor): Promise<boolean> {\r\n        var finish = false;\r\n        sensor.addEventListener('reading', e => {\r\n            finish = true;\r\n            sensor.stop();\r\n        });\r\n        sensor.start();\r\n        await this.wait(1000);\r\n        sensor.stop();\r\n        return finish;\r\n    };\r\n    private async wait(ms: number) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DeliveryController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Language.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeliveryFormat.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\User.tsx",["285"],"import { AIController } from \"../controller/AIController\";\r\nimport { IDataPoint } from \"./DataPoint\";\r\nimport { IDataRowST, IDataRowSTRID } from \"./DataRow\";\r\nimport { DeviceData, IDevice } from \"./DeviceData\";\r\nimport { ILabel } from \"./Label\";\r\nimport { IProjectData, Project } from \"./Project\";\r\nimport { SensorData } from \"./SensorData\";\r\nimport { ISpan } from \"./TimeSpan\";\r\n\r\n/**\r\n * Die Vorlage für alle existierenden Benutzer\r\n */\r\nexport abstract class User {\r\n  protected id: number; //Die eindeutige User ID\r\n  protected name: string; //Der Name des Users\r\n  protected device: DeviceData; //Das Benutzergerät des Benutzers\r\n  protected currentProject?: Project;\r\n  private dataSetID: number;\r\n\r\n  /**\r\n   * Erstellt einen Benutzer\r\n   * @param id eindeutige Benutzer ID\r\n   * @param name Name des Benutzer\r\n   */\r\n  constructor(id: number, device: DeviceData, name?: string) {\r\n    if (id < 0) {\r\n      this.id = -1;\r\n    } else {\r\n      this.id = id;\r\n    }\r\n    this.device = device;\r\n    if (name !== undefined) {\r\n      this.name = name;\r\n    } else {\r\n      this.name = this.device.getName();\r\n    }\r\n    this.dataSetID = -1;\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die aktuelle Datensatz ID zurück, falls diese nicht existiert wird -1 zurück gegeben.\r\n   */\r\n  getCurrentDataSetID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getCurrentDataSetID();\r\n    } else {\r\n      return this.dataSetID;\r\n    }\r\n  }\r\n\r\n  setCurrentDataSetID(newID: number): void {\r\n    if (this.name === AIController.AI_MODEL_USER_NAME) {\r\n      this.dataSetID = newID;\r\n    } else {\r\n      this.dataSetID = -1;\r\n    }\r\n  }\r\n\r\n  getCurrentProjectID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getID();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  addDatapoint(dataRowID: number, datapoint: IDataPoint[]): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.addDatapoint(dataRowID, datapoint);\r\n    }\r\n    return false;\r\n\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: IDataRowST[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getDataRows(dataSetID);\r\n    } else {\r\n      return { dataRows: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen des aktuellen Datensatzes zurück\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: IDataRowST[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getCurrentDataRows();\r\n    } else {\r\n      return { dataRows: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID des aktuellen Projekts zurück, -1 falls kein aktuelles Projekt existiert\r\n   */\r\n  getSessionID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getSessionID();\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  /**\r\n     * Erstellt für das aktuelle Projekt einen neuen Datensatz und setzt diesen als aktuellen Datensatz.\r\n     * @param dataSetID die eindeutige Datensatz ID\r\n     * @param dataSetName der Datensatznamen\r\n     * @param generateDate die Erstellungszeit von dem Datensatz\r\n     * @returns false, falls kein aktuelles Prokekt existiert\r\n     */\r\n  createDataSet(dataSetID: number, dataSetName: string, generateDate: number, dataRow: IDataRowSTRID[]): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.createDataSet(dataSetID, dataSetName, generateDate, dataRow);\r\n    } else {\r\n      this.setCurrentDataSetID(dataSetID);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Löscht vom aktuellen Projekt den Datensatz, mit der übergebenen Datensatz ID\r\n   * @param dataSetID die Datensatz ID\r\n   * @returns gibt die ProjektID zurück, zu dem der Datensatz gehörte, -1 falls der Datensatz nicht existiert hat\r\n   */\r\n  deleteDataSet(dataSetID: number): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.deleteDataSet(dataSetID);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Erstellt für das aktuelle Projekt und dem aktuellen Datensatz ein Label mit den übergebeben Parametern\r\n   * @param labelID Ist die eindeutige Label ID des Labels.\r\n   * @param start Ist die Startzeit des Labels.\r\n   * @param end Ist die Endzeit des Labels.\r\n   * @returns false, falls kein aktueller Datensatz existiert oder die LabelID für diesen Datensatz nicht eindeutig ist\r\n   */\r\n  createLabel(labelID: number, span: ISpan, labelName: string): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.createLabel(labelID, span, labelName);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setzt beim aktuellen Datensatz dem Label mit der LabelID die neu übergebenen Daten\r\n   * @param labelID \r\n   * @param start startzeit des Labels in Millisekunden\r\n   * @param end endzeit des Labels in Millisekunden\r\n   */\r\n  setLabel(labelID: number, span: ISpan, labelName?: string): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.setLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht von dem aktuellen Projekt und dem aktuellen Datensatz das Label mit der Label ID\r\n   * @param labelID die Label ID\r\n   * @returns false, falls kein aktueller Datensatz existiert oder kein Label mit der Label ID existiert\r\n   */\r\n  deleteLabel(labelID: number): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.deleteLabel(labelID);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln vom aktuellen Datensatz zurück.\r\n   * @returns leer, falls kein aktueller Datensatz existiert\r\n   */\r\n  getLabels(): { labels: ILabel[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getLabels();\r\n    }\r\n    return { labels: [] };\r\n  }\r\n\r\n  /**\r\n  * Lädt ein bestehendes Projekt in das Model\r\n  * @param project die Projektdaten\r\n  * @returns false, falls die Projekt ID schon existiert\r\n  */\r\n  abstract loadProject(project: IProject): boolean;\r\n\r\n  /**\r\n   * Gibt alle Sensoren aus, die das Benutzergerät und das Programm unterstützt\r\n  \r\n  getDeviceSensors(sensorTypeID: number[]): SensorData[] {\r\n    return this.device.getSensors(sensorTypeID);\r\n  }\r\n\r\n  /**\r\n   * Gibt die SensorTypID der auswählbaren Sensoren zurück\r\n  getAvailableSensors(): number[] {\r\n    return this.device.getAvailableSensors();\r\n  } */\r\n\r\n  /**\r\n   * Gibt von allen Datensätzen vom aktuellen Projekt Informationen zurück\r\n   * @returns dataSetID ist die DatensatzID und dataSetName ist der Datensatzname\r\n   */\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[] {\r\n    if (this.currentProject !== undefined) {\r\n      return this.currentProject.getDataSetMetas();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setzt einen neuen Benutzernamen\r\n   * @param name der neue Benutzername\r\n   */\r\n  setName(name: string): void {\r\n    this.name = name;\r\n  }\r\n\r\n  /**\r\n   * Gibt den Benutzernamen zurück\r\n   */\r\n  getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  /**\r\n   * Setzt ein neues Benutzergerät\r\n   * @param device das Benutzergerät\r\n   */\r\n  setDevice(device: DeviceData) {\r\n    this.device = device;\r\n  }\r\n\r\n  /**\r\n   * Gibt falls ein Benutzergerät verfügbar ist dieses zurück\r\n   */\r\n  getDevice(): { device?: DeviceData; } {\r\n    return { device: this.device };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Benutzer ID zurück\r\n   */\r\n  getID(): number {\r\n    return this.id;\r\n  }\r\n}\r\n\r\n/**\r\n * Die Klasse Admin dient für einen Benutzer mit einem Account\r\n */\r\nexport class Admin extends User {\r\n  private email: string; //Die eindeutige Admin Email\r\n  private project: Project[] = []; //Alle Projekte, die zu dem Admin gehören\r\n\r\n  /**\r\n   * Zum erstellen eines Admins\r\n   * @param adminID die Admin ID\r\n   * @param deviceID die Geräte ID des Admins\r\n   * @param adminName der Name des Admins\r\n   * @param email die Emailadresse des Admins\r\n   */\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string);\r\n\r\n  /**\r\n   * Für die Implementierung eines Bestehenden Admins\r\n   * @param adminID die Admin ID\r\n   * @param deviceID die Geräte ID\r\n   * @param adminName der Admin Name\r\n   * @param email die Emailadresse des Admins\r\n   * @param device das Gerät des Admins\r\n   */\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string, device: IDevice);\r\n  ////////////////////////////////////////TODO\r\n\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string, device?: IDevice) {\r\n    super(adminID, DeviceData.loadDevice(deviceID, device), adminName);\r\n    this.email = email;\r\n  }\r\n\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: IProject): boolean {\r\n    var id = this.existProject(project.projectID);\r\n    var newProject: Project = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    this.currentProject = newProject;\r\n    if (id === -1) {\r\n      this.project.push(newProject);\r\n    } else {\r\n      this.project[id] = newProject;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /* Methode die noch nicht benutzt wird aber eventuell das laufgeschehen verbessern\r\n    /**\r\n     * Aktuallisiert das Projekt mit den übergebenen Daten\r\n     \r\n    updateProject(project: {\r\n      projectID: number, sessionID: number, projectName: string, projectData?: {\r\n        aiModelID?: number[],\r\n        dataSet: {\r\n          dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n          dataRows: {\r\n            dataRowID: number,\r\n            dataRow: { value: number[], relativeTime: number; }[];\r\n          }[],\r\n          label: { name: string, labelID: number, start: number, end: number; }[];\r\n        }[];\r\n      };\r\n    }): boolean {\r\n      var id = this.existProject(project.projectID);\r\n      if (id === -1) {\r\n        return false;\r\n      } else {\r\n        return this.project[id].updateProject(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n      }\r\n    }\r\n    */\r\n\r\n  /**\r\n   * Fügt ein neues Projekt mit den übergebenen Parametern hinzu und setzt dieses Projekt als aktuelles Projekt\r\n   * @param projectID die Projekt ID, diese muss für den Admin eindeutig sein\r\n   * @param sessionID die Session ID, diese muss global eindeutig sein\r\n   * @param projectName der Name des Projektes\r\n   * @returns Bei angabe einer Project ID, die schon existiert wird false zurück gegeben\r\n   */\r\n  createProject(projectID: number, sessionID: number, projectName: string): boolean {\r\n    if (this.existProject(projectID) === -1) {\r\n      var newproject: Project = new Project(projectID, sessionID, projectName);\r\n      this.project.push(newproject);\r\n      this.currentProject = newproject;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prüft ob ein Projekt mit der ID existiert und gibt die Stelle im Projekt array zurück an dem das Projekt liegt\r\n   * @param projectID \r\n   * @returns -1 falls das Projekt nicht existiert oder die Array Position des Projekts\r\n   */\r\n  private existProject(projectID: number): number {\r\n    for (let i = 0; i < this.project.length; i++) {\r\n      if (this.project[i].getID() === projectID) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Admin Emailadresse zurück\r\n   */\r\n  getEmail(): string {\r\n    return this.email;\r\n  }\r\n}\r\n\r\n/**\r\n * Dataminer ist die Klasse, um Datensammler mit ihren Geräte Sensoren zu spreichern\r\n */\r\nexport class Dataminer extends User {\r\n  /**\r\n   * Erstellt einen Datensammler\r\n   * @param id die Benutzer ID\r\n   * @param name der Benutzername\r\n   * @param deviceID die Geräte ID\r\n   */\r\n  constructor(id: number, deviceID: number, name?: string) {\r\n    super(id, DeviceData.loadDevice(deviceID), name);\r\n  }\r\n\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: IProject): boolean {\r\n    this.currentProject = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * AIModelUser ist die Klasse, um KI-Modell Benutzer zu speichern\r\n */\r\nexport class AIModelUser extends User {\r\n  /**\r\n   * Erstellt einen KI-Modell Benutzer, wenn Name \"\" gesetzt ist und eine Geräte ID gesetzt ist wird als Name der Geräte Name gewählt\r\n   * @param id die eindeutige Benutzer ID\r\n   * @param name der Benutzername\r\n   * @param deviceID die Geräte ID\r\n   */\r\n  constructor(id: number, deviceID: number, name?: string) {\r\n    super(id, DeviceData.loadDevice(deviceID), name);\r\n  }\r\n\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: IProject): boolean {\r\n    this.currentProject = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    return true;\r\n  }\r\n}\r\nexport interface IProject {\r\n  projectID: number,\r\n  sessionID: number,\r\n  projectName: string,\r\n  projectData?: IProjectData;\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIBuilder.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIDistributor.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\SensorData.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DatabaseConnector.tsx",["286"],"import { IDataPoint } from \"./DataPoint\";\r\nimport { IDevice } from \"./DeviceData\";\r\nimport { ILabel } from \"./Label\";\r\nimport { LanguageMessages } from \"./Language\";\r\nimport { ISpan } from \"./TimeSpan\";\r\nimport { IProject } from \"./User\";\r\n\r\n//Die Schnittstelle zur Datenbank.\r\nexport class DatabaseConnector {\r\n  private static readonly databasePHPURL: string = \"/src/database/index.php\";\r\n  private static lastProjectUpdate: number = 0;\r\n\r\n  /**\r\n   * Gibt Name und Code jeder verfügbaren Sprache zurück\r\n   */\r\n  async getLanguageMetas(): Promise<{ languageCode: number, languageName: string; }[]> {\r\n    const result: { languageCode: number, languageName: string; }[] = await this.sendRequest(\"get_language_metas\");\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Läd die Sprache mit dem gegebenen Sprachcode, falls dieser in der Datenbank verfügbar ist\r\n   * @param languageCode Sprachcode\r\n   * @returns die Sprache\r\n   */\r\n  async loadLanguage(requestData: { languageCode: string; }): Promise<LanguageMessages> {\r\n    const result: LanguageMessages = await this.sendRequest(\"load_language\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Erzeugt ein neues Projekt in der Datenbank\r\n   * @param userID von dem Admin, der das Projekt erstellt\r\n   * @param adminEmail zur Sicherheit, muss zur ID übereinstimmen\r\n   * @param projectName der Name des neuen Projekts (Projekte dürfen nicht gleich heißen wie ein bestehendes Projekt)\r\n   * @returns ProjektID und die SessionID, falls das Projekt nicht erstellt werden konnte beides -1\r\n   */\r\n  async createProject(requestData: { userID: number, adminEmail: string, projectName: string; })\r\n    : Promise<{ projectID: number, sessionID: number; }> {\r\n    const result: { projectID: number, sessionID: number; } = await this.sendRequest(\"create_project\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Erzeugt einen leeren Datensatz in der Datenbank\r\n   * @param sessionID die SessionID des Projekts (Implizit die AdminID)\r\n   * @param projektID zur Sicherheit, muss zur SessionID übereinstimmen\r\n   * @param userID die UserID, der Daten anlegen möchte\r\n   * @param dataSetName der Name des Datensatzes\r\n   * @param dataRow die zu erzeugenden Datenreihen, die sensorID muss schon existieren\r\n   * @returns dataSetID (dataRowID ist implizit, da es die ID der Position im Array von dataRow ist (beginnend mit 1)), bei Fehler -1\r\n   */\r\n  async createDataSet(requestData:\r\n    { sessionID: number, projectID: number, userID: number, dataSetName: string, dataRow: { sensorID: number, datarowName?: string; }[]; })\r\n    : Promise<number> {\r\n    const dataSetID: number = (await this.sendRequest(\"create_data_set\", requestData)).dataSetID;\r\n    return dataSetID;\r\n  }\r\n\r\n  /**\r\n   * Sendet den Datenpunkt mit den übergebenen Parametern\r\n   * @param sessionID die Session ID\r\n   * @param userID zur Sicherheit, muss zur SessionID und zur DatensatzID übereinstimmen\r\n   * @param datSetID \r\n   * @param dataRowID \r\n   * @param datapoint \r\n   */\r\n  async sendDataPoint(requestData: { sessionID: number, userID: number, dataSetID: number, dataRowID: number, datapoint: IDataPoint[]; })\r\n    : Promise<boolean> {\r\n    return this.sendRequest(\"send_data_point\", requestData) as Promise<boolean>;\r\n  }\r\n\r\n  /**\r\n   * Sendet die Datenpunkte mit den übergebenen Parametern, falls die Verbindung abgebrochen ist um alle Datenpunkte auf einmal zu senden\r\n   * @param sessionID die Session ID\r\n   * @param userID zur Sicherheit, muss zur SessionID und zur DatensatzID übereinstimmen\r\n   * @param datSetID \r\n   * @param dataRowID \r\n   * @param datapoints alle zu sendenden Datenpunkten \r\n   */\r\n  async sendDataPointsAgain(requestData: { sessionID: number, userID: number, dataSetID: number, dataRowID: number, datapoints: IDataPoint[]; })\r\n    : Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"send_data_points_again\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Lädt das Projekt mit der ensprechenden userID und ProjektID.\r\n   * @param userID \r\n   * @param adminEmail zur Sicherheit, muss zur UserID übereinstimmen\r\n   * @param projectID \r\n   * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n   */\r\n  async loadProject(requestData: { userID: number, adminEmail: string, projectID: number; }): Promise<IProject> {\r\n    let time: number = new Date().getMilliseconds();\r\n    const result: IProject = await this.sendRequest(\"load_project\", requestData);\r\n    if (result.projectID != null) {\r\n      DatabaseConnector.lastProjectUpdate = time;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /* Methode die noch nicht benutzt wird aber eventuell das laufgeschehen verbessern\r\n  /**\r\n   * Lädt das Projekt mit der ensprechenden userID und ProjektID.\r\n   * @param userID \r\n   * @param adminEmail zur Sicherheit, muss zur UserID übereinstimmen\r\n   * @param projectID \r\n   * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n   \r\n  async updateProject(requestData1: { userID: number, adminEmail: string, projectID: number; }): Promise<{\r\n    projectID: number, sessionID: number, projectName: string, projectData?: {\r\n      aiModelID?: number[],\r\n      dataSet: {\r\n        dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n        dataRows: {\r\n          dataRowID: number, recordingStart: number,\r\n          dataRow: { value: number[], relativeTime: number; }[];\r\n        }[],\r\n        label: { name: string, labelID: number, start: number, end: number; }[];\r\n      }[];\r\n    };\r\n  }> {\r\n    const requestData: { userID: number, adminEmail: string, projectID: number, lastUpdate?: number; } = requestData1;\r\n    requestData.lastUpdate = DatabaseConnector.lastProjectUpdate;\r\n    let time: number = new Date().getMilliseconds();\r\n    const result: {\r\n      projectID: number, sessionID: number, projectName: string, projectData?: {\r\n        aiModelID?: number[],\r\n        dataSet: {\r\n          dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n          dataRows: {\r\n            dataRowID: number, recordingStart: number,\r\n            dataRow: { value: number[], relativeTime: number; }[];\r\n          }[],\r\n          label: { name: string, labelID: number, start: number, end: number; }[];\r\n        }[];\r\n      };\r\n    } = await this.sendRequest(\"update_project\", requestData);\r\n    if (result.projectID != null) {\r\n      DatabaseConnector.lastProjectUpdate = time;\r\n    }\r\n    return result;\r\n  }\r\n  */\r\n\r\n  /**\r\n   * Gibt von allen Projekten des angemeldeten Admins, mit der Email adminEmail, die Projekt ID und den Projekt Namen zurück\r\n   * @param userID\r\n   * @param adminEmail zur Sicherheit, muss zur UserID übereinstimmen\r\n   */\r\n  async getProjectMetas(requestData: { userID: number, adminEmail: string; })\r\n    : Promise<{ projectID: number, projectName: string, AIModelID: number[]; }[]> {\r\n    const result: { projectID: number, projectName: string, AIModelID: number[]; }[]\r\n      = await this.sendRequest(\"get_project_metas\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Löscht den Datensatz im Projekt welcher die angegebene ID besitzt\r\n   * @param userID\r\n   * @param adminEmail zur Sicherheit, muss zur UserID übereinstimmen\r\n   * @param projectID \r\n   * @param dataSetID \r\n   * @returns ob der Datenset erfolgreich gelöscht wurde\r\n   */\r\n  async deleteDataSet(requestData: { userID: number, adminEmail: string, projectID: number, dataSetID: number; }): Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"delete_data_set\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n     * Registriert einen neuen Projektleiter. \r\n     * @param adminName \r\n     * @param adminEmail \r\n     * @param password \r\n     * @param device \r\n     * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n     */\r\n  async registerAdmin(requestData: { adminName: string, adminEmail: string, password: string, device: IDevice; })\r\n    : Promise<{ adminID: number, device: { deviceID: number, sensorID: number[]; }; }> {\r\n    const result: { adminID: number, device: { deviceID: number, sensorID: number[]; }; } = await this.sendRequest(\"register_admin\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Registriert einen Datenerfasser.\r\n   * @param dataminerName \r\n   * @param sessionID die SessionID, mit der der Datenerfasser verknüpft ist, diese bestimmt in welchem Projekt die Daten abgelegt werden\r\n   * @param device \r\n   * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n   */\r\n  async registerDataminer(requestData: { dataminerName: string, sessionID: number, device: IDevice; })\r\n    : Promise<{\r\n      dataminerID: number,\r\n      device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    }> {\r\n    const result: {\r\n      dataminerID: number,\r\n      device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    }\r\n      = await this.sendRequest(\"register_dataminer\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Registriert einen KI-Anwender\r\n   * @param aiModelUserName \r\n   * @param modelID \r\n   * @param device \r\n   * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n   */\r\n  async registerAIModelUser(requestData: { aiModelUserName: string, modelID: number, device: IDevice; })\r\n    : Promise<{\r\n      aiModelUserID: number,\r\n      device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    }> {\r\n    const result: {\r\n      aiModelUserID: number,\r\n      device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    }\r\n      = await this.sendRequest(\"register_ai_model_user\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Meldet den Admin an. \r\n   * @param email \r\n   * @param password \r\n   */\r\n  async loginAdmin(requestData: { adminEmail: string, password: string; })\r\n    : Promise<{ admin: { adminID: number, deviceID: number, adminName: string, email: string, device: IDevice; }; }> {\r\n    const result: { admin: { adminID: number, deviceID: number, adminName: string, email: string, device: IDevice; }; }\r\n      = await this.sendRequest(\"login_admin\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein Label\r\n   * @param sessionID \r\n   * @param userID \r\n   * @param datasetID \r\n   * @param label \r\n   * @returns labelID\r\n   */\r\n  async createLabel(requestData: { sessionID: number, userID: number, datasetID: number, label: { span: ISpan, labelName: string; }; }): Promise<number> {\r\n    const result: number = (await this.sendRequest(\"create_label\", requestData)).labelID;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Setzt dem bestehenden Label neue Werte\r\n   * @param sessionID \r\n   * @param userID \r\n   * @param datasetID \r\n   * @param label \r\n   */\r\n  async setLabel(requestData: { sessionID: number, userID: number, datasetID: number, label: { labelID: number, span: ISpan, labelName?: string; }; }): Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"set_label\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Löscht das Label\r\n   * @param sessionID \r\n   * @param userID \r\n   * @param datasetID \r\n   * @param labelID \r\n   */\r\n  async deleteLabel(requestData: { sessionID: number, userID: number, dataSetID: number, labelID: number; }): Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"delete_label\", requestData);\r\n    return result;\r\n  }\r\n\r\n  private async sendRequest(action: string, requestData?: object): Promise<any> {\r\n    const headers = { 'Content-Type': 'application/json' };\r\n    var obj;\r\n    await fetch(DatabaseConnector.databasePHPURL + \"?action=\" + action, { method: 'POST', headers, body: JSON.stringify(requestData) })\r\n      .then(response => response.json()).then(data => { obj = data; }).catch(function () {\r\n        obj = false;\r\n      });\r\n    return obj;\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ModelCreationController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\FinishController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Project.tsx",["287"],"import { AIModel } from \"./AIModel\";\r\nimport { IDataPoint } from \"./DataPoint\";\r\nimport { IDataRowRID, IDataRowST, IDataRowSTRID } from \"./DataRow\";\r\nimport { DataSet, IDataSet } from \"./DataSet\";\r\nimport { ILabel } from \"./Label\";\r\nimport { Session } from \"./Session\";\r\nimport { ISpan } from \"./TimeSpan\";\r\n\r\n/**\r\n * Diese Klasse speichert alle Informationen zu einem Projekt.\r\n * Ein Projekt beinhaltet aufgezeichnete Datensätze (DataSet) sowie Informationen zu den Datensätzen.\r\n */\r\nexport class Project {\r\n  private id: number; //Die eindeutige Projekt ID\r\n  private name: string; //Der Name des Projektes\r\n  private session: Session; //Die Session in dem das Projekt arbeitet\r\n  private aiModel: AIModel[] = []; //Das AIModel von dem Projekt\r\n  private dataSet: DataSet[] = []; //Die Datensätze, die zu dem Projekt gehören\r\n  private currentDataSet?: DataSet; //Aktueller Datensatz\r\n\r\n  /**\r\n     * Eine bereits existierendes Projekt kann wie folgt in das Model geladen werden.\r\n     * @param projectID Die Projekt ID\r\n     * @param sessionID Die Session ID\r\n     * @param projectName Der Projektnamen\r\n     * @param admin Der Besitzer dieses Projekts für die Session\r\n     * @param aiModelID Die schon existierenden AIModel IDs\r\n     * @param dataSet Die schon existierenden Datensätze\r\n     */\r\n  constructor(projectID: number, sessionID: number, projectName: string, projectData?: IProjectData) {\r\n    this.id = projectID;\r\n    this.name = projectName;\r\n    this.session = new Session(sessionID);\r\n    if (projectData !== undefined) {\r\n      if (projectData.aiModelID !== undefined) {\r\n        for (const id of projectData.aiModelID) {\r\n          this.aiModel.push(new AIModel(id));\r\n        }\r\n      }\r\n      for (const entry of projectData.dataSet) {\r\n        let dataSet: DataSet;\r\n        dataSet = new DataSet(\r\n          entry.dataSetID,\r\n          entry.dataSetName,\r\n          entry.generateDate,\r\n          entry.dataRows,\r\n          entry.label\r\n        );\r\n        this.dataSet.push(dataSet);\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Methode die noch nicht benutzt wird aber eventuell das laufgeschehen verbessern\r\n    updateProject(projectID: number, sessionID: number, projectName: string, projectData?: {\r\n      aiModelID?: number[],\r\n      dataSet: {\r\n        dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n        dataRows: {\r\n          dataRowID: number,\r\n          dataRow: { value: number[], relativeTime: number; }[];\r\n        }[],\r\n        label: { name: string, labelID: number, start: number, end: number; }[];\r\n      }[];\r\n    }): boolean {\r\n      if (this.id == projectID && sessionID == this.session.getID()) {\r\n        this.name = projectName;\r\n        if (projectData !== undefined) {\r\n          if (projectData.aiModelID !== undefined) {\r\n            for (const id of projectData.aiModelID) {\r\n              for (let i: number = 0; i < this.aiModel.length; i++) {\r\n                if (id == this.aiModel[i].getID()) {\r\n                  break;\r\n                }\r\n                if (i == this.aiModel.length - 1) {\r\n                  this.aiModel.push(new AIModel(id));\r\n                }\r\n              }\r\n            }\r\n          }////////////////////////////////////////////////////////TODO\r\n          /*\r\n          for (const entry of projectData.dataSet) {\r\n            let dataSet = new DataSet(\r\n              entry.dataRowSensors,\r\n              entry.dataSetID,\r\n              entry.dataSetName,\r\n              entry.generateDate,\r\n              entry.dataRows,\r\n              entry.label\r\n            );\r\n            this.dataSet.push(dataSet);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  */\r\n\r\n  /**\r\n   * Gibt den Projektnamen zurück\r\n   */\r\n  getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  /**\r\n   * Löscht den Datensatz mit der DatensatzID\r\n   * @param dataSetID die Datensatz ID\r\n   */\r\n  deleteDataSet(dataSetID: number): boolean {\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() === dataSetID) {\r\n        this.dataSet.splice(i, 1);\r\n        if (this.currentDataSet != null && this.currentDataSet.getID() === dataSetID) {\r\n          delete this.currentDataSet;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Projekt ID zurück.\r\n   */\r\n  getID(): number {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Erstellt einen neuen Datensatz und setzt diesen als aktuellen Datensatz.\r\n   * @param dataRowSensors die Sensoren, von denen die Daten ausgelesen werden\r\n   * @param dataSetID die eindeutige Datensatz ID\r\n   * @param dataSetName der Datensatznamen\r\n   * @param generateDate die Erstellungszeit von dem Datensatz\r\n   */\r\n  createDataSet(dataSetID: number, dataSetName: string, generateDate: number, dataRow: IDataRowSTRID[]): boolean {\r\n    if (dataRow.length <= 0 || dataSetID < 0 || dataSetName.length <= 0 || (generateDate != null && generateDate < 0)) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() === dataSetID) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var dataSet: DataSet = new DataSet(dataSetID, dataSetName, generateDate, dataRow);\r\n    this.dataSet.push(dataSet);\r\n    this.currentDataSet = dataSet;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gibt die aktuelle Datensatz ID zurück, falls diese nicht existiert wird -1 zurück gegeben\r\n   */\r\n  getCurrentDataSetID(): number {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.getID();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Fügt den übergebenen Datenpunkt dem aktuellen Datensatz hinzu\r\n   * @param dataRowID die DatenreihenID\r\n   * @param datapoint der Datenpunkt\r\n   * @returns true, wenn der Datenpunkt zur Datenreihe hinzugefügt werden konnte\r\n   */\r\n  addDatapoint(dataRowID: number, datapoint: IDataPoint[]): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.addDatapoint(dataRowID, datapoint);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt von allen Datensätzen Informationen zurück\r\n   * @returns dataSetID ist die DatensatzID und dataSetName ist der Datensatzname\r\n   */\r\n  getDataSetMetas(): IDataSetInfo[] {\r\n    let dataSetMetas: { dataSetID: number, dataSetName: string; }[] = [];\r\n    for (const dataSet of this.dataSet) {\r\n      dataSetMetas.push({ \"dataSetID\": dataSet.getID(), \"dataSetName\": dataSet.getName() });\r\n    }\r\n    return dataSetMetas;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: IDataRowST[]; } {\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() === dataSetID) {\r\n        this.currentDataSet = this.dataSet[i];\r\n        return { dataRows: this.dataSet[i].getDataRows() };\r\n      }\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datenreihen der aktuellen Datenreihe zurück\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: IDataRowST[]; } {\r\n    if (this.currentDataSet != null) {\r\n      return { dataRows: this.currentDataSet.getDataRows() };\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID zurück\r\n   */\r\n  getSessionID(): number {\r\n    return this.session.getID();\r\n  }\r\n\r\n  /**\r\n   * Setzt dem Label mit der übergebenen ID neue Werte.\r\n   * @param start Ist die neue Startzeit des Labels.\r\n   * @param end Ist die neue Endzeit des Labels.\r\n   * @param labelID Die Label ID, welche überarbeitet werden soll.\r\n   * @param labelName Ist bei Angabe der neue Name des Labels.\r\n   * @returns falls das Label nicht existiert oder es kein aktuellen Datensatz gibt wird false zurück gegeben\r\n   */\r\n  createLabel(labelID: number, span: ISpan, labelName: string): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.createLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Überschreibt ein bestehendes Label \r\n   * @param labelID die LabelID von dem zu überschreibenden Label\r\n   * @param span das neue Zeitfenster\r\n   * @param labelName falls das Label neu benannt werden soll\r\n   * @returns \r\n   */\r\n  setLabel(labelID: number, span: ISpan, labelName?: string): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.setLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht ein bestehendes Label mit der LabelID\r\n   * @param labelID die LabelID, von dem Label das gelöscht werden soll\r\n   * @returns \r\n   */\r\n  deleteLabel(labelID: number): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.deleteLabel(labelID);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln vom aktuellen Datensatz zurück.\r\n   * @returns leer, falls kein aktueller Datensatz existiert\r\n   */\r\n  getLabels(): { labels: ILabel[]; } {\r\n    if (this.currentDataSet != null) {\r\n      return { labels: this.currentDataSet.getLabels() };\r\n    }\r\n    return { labels: [] };\r\n  }\r\n}\r\nexport interface IDataSetInfo {\r\n  dataSetID: number,\r\n  dataSetName: string;\r\n}\r\nexport interface IProjectData {\r\n  aiModelID?: number[],\r\n  dataSet: IDataSet[];\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeviceData.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Input\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Countdown\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ConstantsText\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\NewProjectButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoginWindow\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoadModelButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Diagram\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Input\\Labelling\\index.tsx",["288","289"],"import React, { Component, ChangeEvent } from 'react';\r\nimport { NotificationManager } from 'react-notifications';\r\n\r\nexport default class Labelling extends Component {\r\n    private static readonly E_MISSING_DE: string = \"Das Labelzeitfenster muss bestimmt werden!\";\r\n    private static readonly E_NAME_MISSING_DE: string = \"Das Labelzeitfenster braucht einen Namen!\";\r\n    private static readonly E_TIME_INVALID_DE: string = \"Das Labelzeitfenster muss mit einer Start und Endzeit bestimmt werden,\\n die Angabe ist in Sekunden.\";\r\n    private static readonly T_BUTTON_DELETE_DE: string = \"Löschen\";\r\n    private static readonly T_BUTTON_ADD_DE: string = \"Label hinzufügen\";\r\n    private static readonly T_TIME_FROM_DE: string = \"Von\";\r\n    private static readonly T_TIME_TO_DE: string = \"bis\";\r\n    private static readonly T_LABEL_START_DE: string = \"Start\";\r\n    private static readonly T_LABEL_END_DE: string = \"Ende\";\r\n    private static readonly T_LABEL_NAME_DE: string = \"Label-Name\";\r\n\r\n    state = {\r\n        labels: [] as { labelID: number, start: number, end: number, name: string; }[],\r\n        newStart: \"\", newEnd: '', newName: \"\"\r\n    };\r\n\r\n    props = {\r\n        //die Funktion für neues Label hinzuzufügen, durch props übermittelt\r\n        newLabel: function (label: {\r\n            labelID: number;\r\n            start: number;\r\n            end: number;\r\n            name: string;\r\n        }) { },\r\n        //die Funktion für Label zu löschen, durch props übermittelt\r\n        pagedeleteLabel: function (label: {\r\n            labelID: number;\r\n            start: number;\r\n            end: number;\r\n            name: string;\r\n        }) { }\r\n    };\r\n    IDcounter: number = 0; //berechnet ID von Label\r\n\r\n    /**\r\n     * aktualisiert den State zu den eingegebenen Label-Namen\r\n     * @param e Eingabeaktion\r\n     */\r\n    handleChangeLabel = (e: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ newName: e.target.value });\r\n    };\r\n\r\n    /**\r\n     * aktualisiert den State zu dem eingegebenen Zeitfenstersanfang\r\n     * @param e Eingabeaktion\r\n     */\r\n    handleChangeStart = (e: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ newStart: e.target.value });\r\n    };\r\n\r\n    /**\r\n     * aktualisiert den State zu dem eingegebenen Zeitfenstersende\r\n     * @param e Eingabeaktion\r\n     */\r\n    handleChangeEnd = (e: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ newEnd: e.target.value });\r\n    };\r\n\r\n    /**\r\n     * anrufe die Addierenmethode und leere die Eingabefelder\r\n     */\r\n    handleClick = () => {\r\n        const { newStart, newEnd, newName } = this.state;\r\n        const labelObj = { start: newStart, end: newEnd, name: newName };\r\n        this.addLabel(labelObj);\r\n        this.setState({ newStart: \"\", newEnd: '', newName: \"\" });\r\n    };\r\n\r\n    /**\r\n     * füge das eingegebene Label hinzu\r\n     */\r\n    addLabel = (labelObj: { start: string, end: string, name: string; }) => {\r\n        if (labelObj.start === \"\" || labelObj.end === \"\") {\r\n            NotificationManager.error(Labelling.E_MISSING_DE);\r\n            return;\r\n        }\r\n        if (labelObj.name === \"\") {\r\n            NotificationManager.error(Labelling.E_NAME_MISSING_DE);\r\n            return;\r\n        }\r\n        labelObj.start = labelObj.start.replace(\",\", \".\");\r\n        labelObj.end = labelObj.end.replace(\",\", \".\");\r\n        let start = this.formatFloatInString(labelObj.start);\r\n        let end = this.formatFloatInString(labelObj.end);\r\n        if (start === NaN && end === NaN) {\r\n            NotificationManager.success(Labelling.E_TIME_INVALID_DE);\r\n            return;\r\n        }\r\n        const label: { labelID: number, start: number, end: number, name: string; } = {\r\n            labelID: this.IDcounter,\r\n            start: start,\r\n            end: end,\r\n            name: labelObj.name\r\n        };\r\n        this.props.newLabel(label);\r\n        const { labels } = this.state;\r\n        const newLabels = [label, ...labels];\r\n        this.setState({ labels: newLabels });\r\n    };\r\n\r\n    /**\r\n     * lösche das entsprechende Label\r\n     * @param e die Klickaktion\r\n     * @param id ID von dem Label, das gelöscht wird\r\n     */\r\n    deleteLabel = (e: React.MouseEvent<HTMLButtonElement>, id: number) => {\r\n\r\n        const { labels } = this.state;\r\n\r\n        let newLabels = labels.filter((label) => {\r\n            if (label.labelID === id) {\r\n                this.props.pagedeleteLabel(label);\r\n            }\r\n            return label.labelID !== id;\r\n        });\r\n        this.setState({ labels: newLabels });\r\n    };\r\n\r\n    /**\r\n     * verwandelt String zur Nummer\r\n     * @param stringNumber das String, das verwandelt wird\r\n     * @returns die entsprechende Nummer\r\n     */\r\n    private formatFloatInString(stringNumber: string): number {\r\n        return (parseInt((parseFloat(stringNumber) * 1000).toString()) / 1000);\r\n    }\r\n\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"label-wrap\">\r\n                {\r\n                    this.state.labels.map((label) => {\r\n                        return (\r\n                            <li >\r\n                                {Labelling.T_TIME_FROM_DE} {label.start} s {Labelling.T_TIME_TO_DE} {label.end} s:  {label.name}\r\n                                <button className='delete' onClick={(e) => this.deleteLabel(e, label.labelID)}>{Labelling.T_BUTTON_DELETE_DE}</button>\r\n                            </li>\r\n                        );\r\n                    })}\r\n                <div>\r\n                    {Labelling.T_LABEL_START_DE}:\r\n                        <input type=\"text\" value={this.state.newStart} onChange={this.handleChangeStart} /><br />\r\n\r\n                    {Labelling.T_LABEL_END_DE}:\r\n                        <input type=\"text\" value={this.state.newEnd} onChange={this.handleChangeEnd} /><br />\r\n\r\n                    {Labelling.T_LABEL_NAME_DE}:\r\n                        <input type=\"text\" value={this.state.newName} onChange={this.handleChangeLabel} />\r\n                    <br />\r\n\r\n                    <button className='add' type=\"button\" onClick={() => this.handleClick()}>{Labelling.T_BUTTON_ADD_DE}</button>\r\n                </div>\r\n\r\n            </div>\r\n        );\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Diagram\\index.tsx",["290"],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataSet.tsx",["291","292"],"import { IDataPoint } from \"./DataPoint\";\r\nimport { DataRow, IDataRowRID, IDataRowST, IDataRowSTRID } from \"./DataRow\";\r\nimport { ILabel, Label } from \"./Label\";\r\nimport { SensorData } from \"./SensorData\";\r\nimport { ISpan } from \"./TimeSpan\";\r\n\r\n/**\r\n * Die Klasse fasst Datenreihen, welche Sensorwerte und deren relative Zeit besitzen, zu einem Datensatz zusammen.\r\n */\r\nexport class DataSet {\r\n  private generateDate: number; //Dies ist die Erstellungszeit dieses Datensatzes in Millisekunden.\r\n  private id: number; //Dies ist die Datensatz ID.\r\n  private name: string; //Dies ist der Name des Datensatzes.\r\n  private dataRow: DataRow[] = []; //Dies sind die Datenreihen, welche zu dem Datensatz gehören.\r\n  private label: Label[] = []; //Dies sind die existierenden Labels für den Datensatz.\r\n\r\n  /**\r\n   * Eine bereits existierende Datensatz kann wie folgt in das Model geladen werden.\r\n   * @param dataRowSensors die Sensoren, von denen die Daten ausgelesen werden, \r\n   * die Anzahl muss mit der Anzahl der Datenreihen übereinstimmen. Und der i´te Sensor wird zur i´ten Datenreihe hinzugefügt.\r\n   * @param dataSetID die eindeutige Datensatz ID\r\n   * @param dataSetName der Datensatznamen\r\n   * @param generateDate die Erstellungszeit von dem Datensatz\r\n   * @param dataRows die schon existierenden Datenreihen\r\n   * @param label die schon existierenden Labels\r\n   */\r\n  constructor(dataSetID: number, dataSetName: string, generateDate: number, dataRows: IDataRowSTRID[], label?: ILabel[]) {\r\n    if (dataRows != null) {\r\n      for (let i = 0; i < dataRows.length; i++) {\r\n        this.dataRow.push(new DataRow({ SensorTypeID: dataRows[i].sensorType }, dataRows[i].dataRowID, dataRows[i].dataRow));\r\n      }\r\n    }\r\n    if (label != null) {\r\n      for (let i = 0; i < label.length; i++) {\r\n        if (label[i].span !== undefined) {\r\n          this.label.push(new Label(label[i].name, label[i].labelID, label[i].span));\r\n        } else if (label[i].start !== undefined && label[i].end !== undefined) {\r\n          this.label.push(new Label(label[i].name, label[i].labelID, { start: label[i].start!, end: label[i].end! }));\r\n        }\r\n      }\r\n    }\r\n    if (generateDate != null) {\r\n      this.generateDate = generateDate;\r\n    } else {\r\n      this.generateDate = new Date().getTime();\r\n    }\r\n    this.id = dataSetID;\r\n    this.name = dataSetName;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datensatz ID zurück.\r\n   */\r\n  public getID(): number {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Gibt den Datensatz Namen zurück.\r\n   */\r\n  public getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  addDatapoint(dataRowID: number, datapoint: IDataPoint[]): boolean {\r\n    for (let i = 0; i < this.dataRow.length; i++) {\r\n      if (this.dataRow[i].getID() === dataRowID) {\r\n        return this.dataRow[i].addDatapoint(datapoint);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Datenreihen zurück.\r\n   * @returns Ein zwei Dimensionales Array, die Erste Dimension wählt die Datenreihe und die zweite Dimension den Datenpunkt.\r\n   */\r\n  public getDataRows(): IDataRowST[] {\r\n    var dataRows: IDataRowST[] = [];\r\n    for (let i = 0; i < this.dataRow.length; i++) {\r\n      dataRows.push(this.dataRow[i].getDataRow());\r\n    }\r\n    return dataRows;\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein Label\r\n   * @param labelID die eindeutige Label ID\r\n   * @param name der Labelname\r\n   * @param start die Startzeit des Zeitfensters in Millisekunden\r\n   * @param end die Endzeit des Zeitfensters in Millisekunden\r\n   * @returns falls das Label mit der ID schon existiert wird false zurück gegeben\r\n   */\r\n  public createLabel(labelID: number, span: ISpan, labelName: string): boolean {\r\n    if (labelID < 0 || span.start < 0 || span.end < span.start) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() === labelID) {\r\n        return false;\r\n      }\r\n    }\r\n    this.label.push(new Label(labelName, labelID, span));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Setzt dem Label mit der übergebenen ID neue Werte.\r\n   * @param span ist die Start- und Endzeit in Millisekunden.\r\n   * @param labelID Die Label ID, welche überarbeitet werden soll.\r\n   * @param labelName Ist bei Angabe der neue Name des Labels.\r\n   * @returns falls das Label nicht existiert wird false zurück gegeben\r\n   */\r\n  public setLabel(labelID: number, span: ISpan, labelName?: string): boolean {\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() === labelID) {\r\n        return this.label[i].setLabel(span, labelName);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht das Label mit der übergebenen LabelID.\r\n   * @param labelID die LabelID\r\n   */\r\n  public deleteLabel(labelID: number): boolean {\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() === labelID) {\r\n        this.label.splice(i, 1);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln zurück.\r\n   */\r\n  public getLabels(): ILabel[] {\r\n    var labelList: ILabel[] = [];\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      labelList.push(this.label[i].getLabel());\r\n    }\r\n    return labelList;\r\n  }\r\n}\r\nexport interface IDataSet {\r\n  dataSetID: number,\r\n  dataSetName: string,\r\n  generateDate: number,\r\n  dataRows: IDataRowSTRID[],\r\n  label: ILabel[];\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Session.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIModel.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\DownloadButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\DiagramList\\index.tsx",["293","294","295","296","297","298"],"import Chart from 'chart.js';\r\nimport React, { Component, CSSProperties } from 'react';\r\nimport \"./DiagramList.css\";\r\n\r\n\r\nexport default class DiagramList extends Component {\r\n    private static readonly T_ACCELEROMETER_DE: string = \"Beschleunigungssensor\";\r\n    private static readonly T_GYROSCOPE_DE: string = \"Gyroskop\";\r\n    private static readonly T_MAGNETOMETER_DE: string = \"Magnetometer\";\r\n    private diagrammData: {\r\n\r\n        datavalue: number,\r\n    }[] = [{\r\n        datavalue: 0,\r\n    }]\r\n\r\n    /**\r\n     * Variablen und Methoden welche der Klasse zur verfügung gestellt werden müssen\r\n     */\r\n    props = {\r\n        currentDataSets: [] as { dataSetID: number, rows: { sensorType: number, datapoint: { value: number[], relativeTime: number; }[]; }[]; }[],\r\n        dataSetMetas: [] as { dataSetID: number, dataSetName: string; }[]\r\n        //testDataSet: [] as { dataSetID: number, rows: { sensorType: number, datapoint: { value: number[], relativeTime: number }[] }[] }[],\r\n    };\r\n\r\n    /**\r\n     * Status für diese Komponente\r\n     */\r\n    state = {\r\n        showDiagramIndex: 0,\r\n        diagramList: [] as any[],\r\n        diagrammData: {\r\n            lineLabels: [] as any[],\r\n            sensorRow: [] as any[],\r\n            datavalue: [] as any[],\r\n            time: [] as any[],\r\n\r\n        },\r\n        color: ['rgba(46,190,87,1)', 'rgba(68,24,232,1)', 'rgba(238,173,14,1)', 'rgba(178,34,34,1)', 'rgba(238, 130, 238,1)', 'rgba(0, 0, 0,1)',\r\n            'rgba(106, 90, 205,1)', 'rgba(238, 118, 0,1)', 'rgba(105, 105, 105,1)'],\r\n        csscolor: ['rgba(46,190,87,1)', 'rgba(68,24,232,1)', 'rgba(238,173,14,1)', 'rgba(178,34,34,1)', 'rgba(238, 130, 238,1)', 'rgba(0, 0, 0,1)',\r\n            'rgba(106, 90, 205,1)', 'rgba(238, 118, 0,1)', 'rgba(105, 105, 105,1)']\r\n    };\r\n\r\n    /**\r\n     * Nach Klicken auf Diagram das Zeigendiagram wechseln\r\n     * @param diagram gewählte Diagram\r\n     * @param index Diagramindex\r\n     */\r\n    handleClick = (diagram: any, index: any) => {\r\n        this.setState({ showDiagramIndex: index });\r\n    };\r\n\r\n    /**\r\n     * Diagram erstellen\r\n     * @param dataSet Datensätze für Diagram\r\n     */\r\n    updateDiagramm(dataSet: { dataSetID: number; rows: any[]; }, index: number) {\r\n        let diagrammData = this.state.diagrammData;\r\n        diagrammData.sensorRow = [];\r\n        diagrammData.datavalue = [];\r\n        diagrammData.time = [];\r\n        this.state.diagrammData = diagrammData;\r\n        var datavalues = [];\r\n        for (var i = 0; i < dataSet.rows.length; i++) {\r\n            this.state.diagrammData.sensorRow.push(dataSet.rows[i].sensorType);\r\n            for (var dataCoordinate = 0; dataCoordinate < 3; dataCoordinate++) {\r\n                for (var j = 0; j < dataSet.rows[i].datapoint.length; j++) {\r\n                    datavalues.push(dataSet.rows[i].datapoint[j].value[dataCoordinate]);\r\n                }\r\n                this.state.diagrammData.datavalue.push(datavalues);\r\n                datavalues = [];\r\n            }\r\n        }\r\n        for (var j = 0; j < dataSet.rows[0].datapoint.length; j++) {\r\n            this.state.diagrammData.time.push(dataSet.rows[0].datapoint[j].relativeTime);\r\n        }\r\n\r\n        var newDatasets = [];\r\n        var lineLabels = [];\r\n        for (var i = 0; i < this.state.diagrammData.sensorRow.length * 3; i++) {\r\n            var coordinate = \".X\";\r\n            var sensor = this.state.diagrammData.sensorRow[(i / 3) | 0];\r\n            var sensorName = '';\r\n            switch (sensor) {\r\n                case 2:\r\n                    sensorName = DiagramList.T_ACCELEROMETER_DE;\r\n                    break;\r\n                case 3:\r\n                    sensorName = DiagramList.T_GYROSCOPE_DE;\r\n                    break;\r\n                case 4:\r\n                    sensorName = DiagramList.T_MAGNETOMETER_DE;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            // eslint-disable-next-line\r\n            if (i % 3 == 1) {\r\n                coordinate = \".Y\";\r\n            }\r\n            // eslint-disable-next-line\r\n            if (i % 3 == 2) {\r\n                coordinate = \".Z\";\r\n            }\r\n\r\n            let color: CSSProperties = { \"color\": this.state.csscolor[i] };\r\n            lineLabels.push(<span style={color}>■{sensorName + coordinate}<br /></span>);\r\n            //this.setState({ lineLabels: lineLabels })\r\n            newDatasets.push(\r\n                {\r\n                    label: sensor + coordinate,\r\n                    strokeColor: this.state.color[i],\r\n                    borderWidth: 1,\r\n                    data: this.state.diagrammData.datavalue[i],\r\n                }\r\n            );\r\n        }\r\n        const data = {\r\n            labels: this.state.diagrammData.time,\r\n            datasets: newDatasets\r\n        };\r\n        const options = {\r\n            datasetFill: false,\r\n            pointDotRadius: 2,\r\n            pointHitDetectionRadius: 1,\r\n            offsetGridLines: true,\r\n            pointDot: false,\r\n        };\r\n        const newList = this.state.diagramList;\r\n        const id = dataSet.dataSetID;\r\n        if(newList[index] !== undefined) {\r\n        newList[index] = { dataSetID: id, lineLabels: lineLabels, data: data, options: options };\r\n        } else {\r\n            newList.push({ dataSetID: id, lineLabels: lineLabels, data: data, options: options })\r\n        }\r\n        this.state.diagramList = newList;\r\n        this.diagrammData[index].datavalue = this.props.currentDataSets[index].rows[0].datapoint.length\r\n    }\r\n\r\n    /**\r\n     * Render Methode des Komponenten\r\n     * @returns Aufbau des Komponenten\r\n     */\r\n    render() {\r\n\r\n        var LineChart = require(\"react-chartjs\").Line;\r\n\r\n        //jede Diagram nur einmal zeigen,und nur erneut mit neue Data\r\n        // eslint-disable-next-line\r\n        this.props.currentDataSets?.map((dataSet, index) => {\r\n            var flag = false;\r\n            // eslint-disable-next-line\r\n            this.state.diagramList.map((diagram, index2) => {\r\n                console.log(this.props.currentDataSets[index2].rows.length)\r\n                if (diagram.dataSetID === dataSet.dataSetID) {\r\n                    if (this.diagrammData[index2] !== undefined && this.diagrammData[index2].datavalue != this.props.currentDataSets[index2].rows[0].datapoint.length) {\r\n                        this.updateDiagramm(dataSet, index2);\r\n                        this.diagrammData[index2].datavalue = this.props.currentDataSets[index].rows[0].datapoint.length\r\n                    }\r\n                        flag = true;\r\n                        return diagram;\r\n                }\r\n            });\r\n            if (flag) { return dataSet; }\r\n            else { \r\n                this.diagrammData.push({datavalue: 0})\r\n                this.updateDiagramm(dataSet, index); \r\n            }\r\n        });\r\n        return (\r\n            <div className=\"view-section\">\r\n                {this.state.diagramList.map((diagram, index) => {\r\n                    let datasetname = \"Null\";\r\n                    this.props.dataSetMetas.forEach(dataset => {\r\n                        if (dataset.dataSetID === diagram.dataSetID) {\r\n                            datasetname = dataset.dataSetName;\r\n                        }\r\n                    });\r\n                    return (\r\n                        <div key={index} className=\"view-section\">\r\n                            <div className=\"diagramTop\" id={index.toString()}>\r\n                                <h5 className=\"datasetName\">{datasetname}</h5>\r\n                                {diagram.lineLabels}\r\n                            </div>\r\n                            <div className=\"diagramList\">\r\n                                <LineChart data={diagram.data} options={diagram.options} width={document.documentElement.clientWidth * 0.98} height={320} />\r\n                            </div>\r\n                        </div>\r\n                        );\r\n                    })}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\FinishButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\EmailList\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataRow.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Label.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\QRImage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LinkText\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ChangeToVisuBtn\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ProjectList\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ModelCreationComponents\\Train\\index.tsx",["299","300","301"],"import React, { Component } from 'react';\r\nimport NewWindow from 'react-new-window';\r\nimport { NotificationManager } from 'react-notifications';\r\nimport 'react-notifications/lib/notifications.css';\r\nimport './Train.css';\r\nexport default class Train extends Component {\r\n\tprivate static readonly T_IMPUTER_MEAN_DE: string = \"Arithmetischer Mittelwert\";\r\n\tprivate static readonly T_SCALER_STANDARD_DE: string = \"Standard Scaler\";\r\n\tprivate static readonly T_SCALER_ROBUST_DE: string = \"Robust Scaler\";\r\n\tprivate static readonly T_SCALER_MIN_MAX_DE: string = \"Min-Max Scaler\";\r\n\tprivate static readonly T_SCALER_NORMALIZER_DE: string = \"Normalizer\";\r\n\tprivate static readonly T_FEATURE_MIN_DE: string = \"Minimum\";\r\n\tprivate static readonly T_FEATURE_MAX_DE: string = \"Maximum\";\r\n\tprivate static readonly T_FEATURE_VARIANCE_DE: string = \"Varianz\";\r\n\tprivate static readonly T_FEATURE_ENERGY_DE: string = \"Energie\";\r\n\tprivate static readonly T_FEATURE_FOURIER_TRANSFORM_DE: string = \"Fourier-Transformation\";\r\n\tprivate static readonly T_FEATURE_MEAN_DE: string = \"Mittelwert\";\r\n\tprivate static readonly T_FEATURE_AUTOREGRESSIVE_DE: string = \"Autoregression\";\r\n\tprivate static readonly T_FEATURE_SKEWNESS_DE: string = \"Abweichung\";\r\n\tprivate static readonly T_FEATURE_KURTOSIS_DE: string = \"Wölbung\";\r\n\tprivate static readonly T_FEATURE_IQR_DE: string = \"Quantil-Regression\";\r\n\tprivate static readonly T_CLASSIFIER_MLP_DE: string = \"Multi-Level-Perceptron (Neurales Netz)\";\r\n\tprivate static readonly T_CLASSIFIER_RANDOM_FOREST_DE: string = \"Random-Forest-Klassifizierer\";\r\n\tprivate static readonly T_CLASSIFIER_K_NEIGHBORS_DE: string = \"K-nächster-Nachbar-Methode\";\r\n\tprivate static readonly T_CLASSIFIER_SVM_DE: string = \"Stützvektor-Maschine\";\r\n\tprivate static readonly E_IMPUTER_MULTI_SELECTION_DE: string = \"Es darf nur ein Imputer ausgewählt werden.\";\r\n\tprivate static readonly E_SCALER_MULTI_SELECTION_DE: string = \"Es darf nur ein Scaler ausgewählt werden.\";\r\n\tprivate static readonly E_CLASSIFIER_MULTI_SELECTION_DE: string = \"Es darf nur ein Klassifizierer ausgewählt werden.\";\r\n\tprivate static readonly E_DATASET_NO_SELECTION_DE: string = \"Kein Datensatz ausgewählt!\";\r\n\tprivate static readonly E_IMPUTER_NO_SELECTION_DE: string = \"Kein Imputer ausgewählt!\";\r\n\tprivate static readonly E_SCALER_NO_SELECTION_DE: string = \"Kein Scaler ausgewählt!\";\r\n\tprivate static readonly E_FEATURE_NO_SELECTION_DE: string = \"Keine Merkmale zur Extraktion ausgewählt!\";\r\n\tprivate static readonly E_CLASSIFIER_NO_SELECTION_DE: string = \"Kein Klassifizierer ausgewählt!\";\r\n\tprivate static readonly T_DATASET_TITLE_DE: string = \"Verwendete Datensätze\";\r\n\tprivate static readonly T_IMPUTER_TITLE_DE: string = \"Imputation\";\r\n\tprivate static readonly T_SCALER_TITLE_DE: string = \"Normalisierung (Scaling)\";\r\n\tprivate static readonly T_FEATURE_TITLE_DE: string = \"Merkmalsextraktion\";\r\n\tprivate static readonly T_CLASSIFIER_TITLE_DE: string = \"Klassifizierer\";\r\n\tprivate static readonly T_BUTTON_START_DE: string = \"KI-Modell trainieren\";\r\n\tprivate static readonly T_BUTTON_HOME_DE: string = \"Zurück zur Verweisseite\";\r\n\tprivate static readonly T_DATASET_CHOOSEALL_DE: string = \"Alle Datensätze wählen\";\r\n\tprivate static readonly T_FEATURE_CHOOSEALL_DE: string = \"Alle Merkmale wählen\";\r\n\r\n\r\n\t/**\r\n\t * Variablen und Methoden welche der Klasse zur verfügung gestellt werden müssen\r\n\t */\r\n\tprops = {\r\n\t\tdataSetMetas: [] as { dataSetID: number, dataSetName: string; }[],\r\n\t\ttrain: function (dataSets: number[], imputator: string, classifier: string, scaler: string, features: string[]) { },\r\n\t\tchangeToReferring: function () { }\r\n\t};\r\n\r\n\t/**\r\n\t * Status für diese Komponente\r\n\t */\r\n\tstate = {\r\n\t\tvalue: '' as string,\r\n\t\tdataSets: [] as number[],\r\n\t\timputators: [\r\n\t\t\t{ name: Train.T_IMPUTER_MEAN_DE, checked: true, tag: 'MEAN' },\r\n\t\t\t/*\t\t\tNOT IMPLEMENTED\r\n\t\t\t{ name: \"Letze Werte fortführen\", checked: false, tag: 'FORWARD' },\r\n\t\t\t{ name: \"Bewegter Durchschnitt\",  checked: false, tag: 'MOVING'  },\r\n\t\t\t{ name: \"Lineare Interpolation\",  checked: false, tag: 'LINEAR'  },\r\n\t\t\t{ name: \"Spline Interpolation\",   checked: false, tag: 'SPLINE'  }*/\r\n\t\t],\r\n\t\tscalers: [\r\n\t\t\t{ name: Train.T_SCALER_STANDARD_DE, checked: false, tag: 'STANDARD' },\r\n\t\t\t{ name: Train.T_SCALER_ROBUST_DE, checked: false, tag: 'ROBUST' },\r\n\t\t\t{ name: Train.T_SCALER_MIN_MAX_DE, checked: false, tag: 'MIN_MAX' },\r\n\t\t\t{ name: Train.T_SCALER_NORMALIZER_DE, checked: false, tag: 'NORMALIZER' },\r\n\t\t\t/*\t{ name: \"Anteilstransformator\",       checked: false, tag: 'SHARE'      }\tNOT IMPLEMENTED */\r\n\t\t],\r\n\t\tmyfeatures: [\r\n\t\t\t{ name: Train.T_FEATURE_MIN_DE, checked: false, tag: 'MIN' },\r\n\t\t\t{ name: Train.T_FEATURE_MAX_DE, checked: false, tag: 'MAX' },\r\n\t\t\t{ name: Train.T_FEATURE_VARIANCE_DE, checked: false, tag: 'VARIANCE' },\r\n\t\t\t{ name: Train.T_FEATURE_ENERGY_DE, checked: false, tag: 'ENERGY' },\r\n\t\t\t{ name: Train.T_FEATURE_FOURIER_TRANSFORM_DE, checked: false, tag: 'FOURIER_TRANSFORM' },\r\n\t\t\t{ name: Train.T_FEATURE_MEAN_DE, checked: false, tag: 'MEAN' },\r\n\t\t\t{ name: Train.T_FEATURE_AUTOREGRESSIVE_DE, checked: false, tag: 'AUTOREGRESSIVE' },\r\n\t\t\t{ name: Train.T_FEATURE_SKEWNESS_DE, checked: false, tag: 'SKEWNESS' },\r\n\t\t\t{ name: Train.T_FEATURE_KURTOSIS_DE, checked: false, tag: \"KURTOSIS\" },\r\n\t\t\t{ name: Train.T_FEATURE_IQR_DE, checked: false, tag: \"IQR\" }\r\n\t\t],\r\n\t\tclassifiers: [\r\n\t\t\t{ name: Train.T_CLASSIFIER_MLP_DE, checked: false, tag: 'MLP' },\r\n\t\t\t{ name: Train.T_CLASSIFIER_RANDOM_FOREST_DE, checked: false, tag: 'RANDOM_FOREST' },\r\n\t\t\t{ name: Train.T_CLASSIFIER_K_NEIGHBORS_DE, checked: false, tag: 'K_NEIGHOBORS' },\r\n\t\t\t{ name: Train.T_CLASSIFIER_SVM_DE, checked: false, tag: 'SVM' }\r\n\t\t],\r\n\t\tchosenScaler: 0,\r\n\t\tchosenclassifier: 0,\r\n\t\tchosenImputator: 0,\r\n\t\tchooseDataSetsFlag: false,\r\n\t\tchooseFeatureFlag: false\r\n\t};\r\n\r\n\t/**\r\n\t * Diese Methode fertigt das Ereignis ab, das ausgelöst wird, wenn eine der Datensatz-Checkboxen angeklickt wird.\r\n\t * @param id Datasetindex\r\n\t */\r\n\thandleDataset = (id: number): void => {\r\n\t\tlet dataSets = this.state.dataSets;\r\n\t\tif (dataSets.includes(id)) {\r\n\t\t\tthis.setState({ dataSets: dataSets.filter(value => value != id) });\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataSets.push(id)\r\n\t\t\tthis.setState({ dataSets: dataSets});\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Choose all Dataset\r\n\t * @param e InputEvent\r\n\t */\r\n\tchosenAllDatasets = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n\t\tconst chosen = e.target.checked;\r\n\t\tconst newflag = !(this.state.chooseDataSetsFlag);\r\n\t\tif(chosen) {\r\n\t\t\tthis.setState({ dataSets: this.props.dataSetMetas.map(dataSet => dataSet.dataSetID), chooseDataSetsFlag: newflag });\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.setState({dataSets: [], chooseDataSetsFlag: newflag})\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Check Imputation\r\n\t * @param index Imputationindex\r\n\t * @returns \r\n\t */\r\n\thandleImputation = (index: number): void => {\r\n\t\tlet newList = [...this.state.imputators];\r\n\t\tlet newChosen = this.state.chosenImputator;\r\n\t\tif (newList[index].checked) { newChosen--; }\r\n\t\telse { newChosen++; }\r\n\t\tif (newChosen <= 1) {\r\n\t\t\tnewList[index].checked = !newList[index].checked;\r\n\t\t\tthis.setState({ chosenImputator: newChosen, imputators: newList });\r\n\t\t} else {\r\n\t\t\tNotificationManager.error(Train.E_IMPUTER_MULTI_SELECTION_DE, \"\", 3000);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Check Scaler\r\n\t * @param index Scalerindex \r\n\t * @returns \r\n\t */\r\n\thandleScaler = (index: number): void => {\r\n\t\tlet newList = [...this.state.scalers];\r\n\t\tlet newChosen = this.state.chosenScaler;\r\n\t\tif (newList[index].checked) { newChosen--; }\r\n\t\telse { newChosen++; }\r\n\t\tif (newChosen <= 1) {\r\n\t\t\tnewList[index].checked = !newList[index].checked;\r\n\t\t\tthis.setState({ chosenScaler: newChosen, scalers: newList });\r\n\t\t}\r\n\t\telse {\r\n\t\t\tNotificationManager.error(Train.E_SCALER_MULTI_SELECTION_DE, \"\", 3000);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Check Extraction\r\n\t * @param index Extractionindex\r\n\t */\r\n\thandleExtraction = (index: number): void => {\r\n\t\tlet newList = [...this.state.myfeatures];\r\n\t\tnewList[index].checked = !newList[index].checked;\r\n\t\tthis.setState({ features: newList });\r\n\t};\r\n\r\n\t/**\r\n\t * Choose all Extraction\r\n\t * @param e InputEvent\r\n\t */\r\n\tchosenAllExtraction = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n\t\tconst checked = e.target.checked;\r\n\t\tconst { myfeatures, chooseFeatureFlag } = this.state;\r\n\t\tconst newflag = !chooseFeatureFlag\r\n\t\tconst newList = myfeatures.map(myfeature => { return { ...myfeature, checked }; });\r\n\t\tthis.setState({ myfeatures: newList, chooseFeatureFlag: newflag })\r\n\t}\r\n\r\n\t/**\r\n\t * Check Classifier\r\n\t * @param index Classifierindex\r\n\t * @returns \r\n\t */\r\n\thandleClassifier = (index: number): void => {\r\n\t\tlet newList = [...this.state.classifiers];\r\n\t\tlet newChosen = this.state.chosenclassifier;\r\n\t\tif (newList[index].checked) { newChosen--; }\r\n\t\telse { newChosen++; }\r\n\t\tif (newChosen <= 1) {\r\n\t\t\tnewList[index].checked = !newList[index].checked;\r\n\t\t\tthis.setState({ chosenclassifier: newChosen, classifiers: newList });\r\n\t\t}\r\n\t\telse {\r\n\t\t\tNotificationManager.error(Train.E_CLASSIFIER_MULTI_SELECTION_DE, \"\", 3000);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Trainieren Methode\r\n\t * @returns \r\n\t */\r\n\thandleTrain = (): void => {\r\n\t\tlet imputator = \"\", classifier = '', scaler = '', features: string[] = [];\r\n\t\tconst { dataSets, imputators, classifiers, scalers, myfeatures } = this.state;\r\n\t\tlet imputatorsflag = true, classifiersflag = true, scalersflag = true, featuresflag = true, nochoice = false;\r\n\t\timputators.map((imputatorObj) => {\r\n\t\t\tif (imputatorObj.checked) {\r\n\t\t\t\timputatorsflag = false;\r\n\t\t\t\timputator = imputatorObj.tag;\r\n\t\t\t}\r\n\t\t\treturn imputatorObj;\r\n\t\t});\r\n\t\tclassifiers.map((classifierObj) => {\r\n\t\t\tif (classifierObj.checked) {\r\n\t\t\t\tclassifiersflag = false;\r\n\t\t\t\tclassifier = classifierObj.tag;\r\n\t\t\t}\r\n\t\t\treturn classifierObj;\r\n\t\t});\r\n\t\tscalers.map((scalerObj) => {\r\n\t\t\tif (scalerObj.checked) {\r\n\t\t\t\tscalersflag = false;\r\n\t\t\t\tscaler = scalerObj.tag;\r\n\t\t\t}\r\n\t\t\treturn scalerObj;\r\n\t\t});\r\n\t\tmyfeatures.map((featureObj) => {\r\n\t\t\tif (featureObj.checked) {\r\n\t\t\t\tfeaturesflag = false;\r\n\t\t\t\tfeatures.push(featureObj.tag);\r\n\t\t\t}\r\n\t\t\treturn featureObj;\r\n\t\t});\r\n\t\tif (dataSets.length == 0) {\r\n\t\t\tNotificationManager.error(Train.E_DATASET_NO_SELECTION_DE, \"\", 3000);\r\n\t\t\tnochoice = true;\r\n\t\t}\r\n\t\tif (imputatorsflag) {\r\n\t\t\tNotificationManager.error(Train.E_IMPUTER_NO_SELECTION_DE, \"\", 3000);\r\n\t\t\tnochoice = true;\r\n\t\t}\r\n\t\tif (classifiersflag) {\r\n\t\t\tNotificationManager.error(Train.E_CLASSIFIER_NO_SELECTION_DE, \"\", 3000);\r\n\t\t\tnochoice = true;\r\n\t\t}\r\n\t\tif (scalersflag) {\r\n\t\t\tNotificationManager.error(Train.E_SCALER_NO_SELECTION_DE, \"\", 3000);\r\n\t\t\tnochoice = true;\r\n\t\t}\r\n\t\tif (featuresflag) {\r\n\t\t\tNotificationManager.error(Train.E_FEATURE_NO_SELECTION_DE, \"\", 3000);\r\n\t\t\tnochoice = true;\r\n\t\t}\r\n\t\tif (nochoice) return;\r\n\t\tthis.props.train(dataSets, imputator, classifier, scaler, features);\r\n\t};\r\n\r\n\t/**\r\n\t * Wechseln zu Darstellungsseite\r\n\t */\r\n\thandleChangePage() {\r\n\t\tthis.props.changeToReferring();\r\n\t}\r\n\r\n\t/**\r\n\t * Render Methode des Komponenten\r\n\t * @returns Aufbau des Komponenten\r\n\t */\r\n\trender(): JSX.Element {\r\n\t\tconst { imputators, scalers, myfeatures, classifiers, chooseDataSetsFlag, chooseFeatureFlag } = this.state;\r\n\t\treturn (\r\n\t\t\t<div className=\"train view-section\">\r\n\t\t\t\t<div className=\"view-section\">\r\n\t\t\t\t\t<div className=\"list\">\r\n\t\t\t\t\t\t<h3 className=\"text\">{Train.T_DATASET_TITLE_DE}</h3>\r\n\t\t\t\t\t\t{this.props.dataSetMetas.map((dataSet, index) => {\r\n\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t<input className='datasetscheck' type=\"checkbox\" id={\"D\" + index.toString()} value={index} checked={this.state.dataSets.includes(dataSet.dataSetID)} onChange={() => this.handleDataset(dataSet.dataSetID)} />\r\n\t\t\t\t\t\t\t\t\t<label htmlFor={\"D\" + index.toString()}>{dataSet.dataSetName}</label>\r\n\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t<input className='chooseall' type=\"checkbox\" id={\"D\"} onChange={this.chosenAllDatasets} checked={chooseDataSetsFlag} />\r\n\t\t\t\t\t\t<label htmlFor={\"D\"}>{Train.T_DATASET_CHOOSEALL_DE}</label>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div className=\"list\">\r\n\t\t\t\t\t\t<div className=\"imputationlist\">\r\n\t\t\t\t\t\t\t<h3 className=\"text\">{Train.T_IMPUTER_TITLE_DE}</h3>\r\n\t\t\t\t\t\t\t{imputators.map((imputator, index) => {\r\n\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t\t<input className='imputationcheck' type=\"checkbox\" id={\"I\" + index.toString()} value={index} checked={imputator.checked} onChange={() => this.handleImputation(index)} />\r\n\t\t\t\t\t\t\t\t\t\t<label htmlFor={\"I\" + index.toString()}>{imputator.name}</label>\r\n\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div className=\"scalerlist\">\r\n\t\t\t\t\t\t\t<h3 className=\"text\">{Train.T_SCALER_TITLE_DE}</h3>\r\n\t\t\t\t\t\t\t{scalers.map((scaler, index) => {\r\n\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t\t<input className='scalercheck' type=\"checkbox\" id={\"S\" + index.toString()} value={index} checked={scaler.checked} onChange={() => this.handleScaler(index)} />\r\n\t\t\t\t\t\t\t\t\t\t<label htmlFor={\"S\" + index.toString()}>{scaler.name}</label>\r\n\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div className=\"classifierlist\">\r\n\t\t\t\t\t\t\t<h3 className=\"text\">{Train.T_CLASSIFIER_TITLE_DE}</h3>\r\n\t\t\t\t\t\t\t{classifiers.map((classifier, index) => {\r\n\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t\t<input className='classifiercheck' type=\"checkbox\" id={\"C\" + index.toString()} value={index} checked={classifier.checked} onChange={() => this.handleClassifier(index)} />\r\n\t\t\t\t\t\t\t\t\t\t<label htmlFor={\"C\" + index.toString()}>{classifier.name}</label>\r\n\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div className=\"list\">\r\n\t\t\t\t\t\t<div className=\"extractionlist\">\r\n\t\t\t\t\t\t\t<h3 className=\"text\">{Train.T_FEATURE_TITLE_DE}</h3>\r\n\t\t\t\t\t\t\t{myfeatures.map((extraction, index) => {\r\n\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t<div key={index}>\r\n\t\t\t\t\t\t\t\t\t\t<input className='featurecheck' type=\"checkbox\" id={\"F\" + index.toString()} value={index} checked={extraction.checked} onChange={() => this.handleExtraction(index)} />\r\n\t\t\t\t\t\t\t\t\t\t<label htmlFor={\"F\" + index.toString()}>{extraction.name}</label>\r\n\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t<input className='chooseall' type=\"checkbox\" id={\"F\"} onChange={this.chosenAllExtraction} checked={chooseFeatureFlag} />\r\n\t\t\t\t\t\t\t<label htmlFor={\"F\"}>{Train.T_FEATURE_CHOOSEALL_DE}</label>\r\n\t\t\t\t\t\t</div>\r\n\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div className=\"clearfloat\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div className=\"view-section\">\r\n\t\t\t\t\t<button onClick={() => this.handleTrain()} className=\"train-btn\" type='button' >{Train.T_BUTTON_START_DE}</button>\r\n\t\t\t\t\t<button onClick={() => this.handleChangePage()} className=\"changepage-btn\" type='button' >{Train.T_BUTTON_HOME_DE}</button>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\r\n\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataPoint.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\TimeSpan.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ModelList\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ResultPage\\Result.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ResultPage\\State.tsx",[],{"ruleId":"302","severity":1,"message":"303","line":7,"column":10,"nodeType":"304","messageId":"305","endLine":7,"endColumn":20},{"ruleId":"302","severity":1,"message":"306","line":6,"column":10,"nodeType":"304","messageId":"305","endLine":6,"endColumn":17},{"ruleId":"302","severity":1,"message":"303","line":7,"column":10,"nodeType":"304","messageId":"305","endLine":7,"endColumn":20},{"ruleId":"302","severity":1,"message":"307","line":3,"column":10,"nodeType":"304","messageId":"305","endLine":3,"endColumn":16},{"ruleId":"302","severity":1,"message":"308","line":3,"column":10,"nodeType":"304","messageId":"305","endLine":3,"endColumn":21},{"ruleId":"309","severity":1,"message":"310","line":89,"column":13,"nodeType":"311","messageId":"312","endLine":89,"endColumn":26},{"ruleId":"309","severity":1,"message":"310","line":89,"column":30,"nodeType":"311","messageId":"312","endLine":89,"endColumn":41},{"ruleId":"313","severity":1,"message":"314","line":61,"column":18,"nodeType":"304","messageId":"315","endLine":61,"endColumn":19},{"ruleId":"302","severity":1,"message":"308","line":2,"column":19,"nodeType":"304","messageId":"305","endLine":2,"endColumn":30},{"ruleId":"302","severity":1,"message":"303","line":4,"column":10,"nodeType":"304","messageId":"305","endLine":4,"endColumn":20},{"ruleId":"302","severity":1,"message":"316","line":1,"column":8,"nodeType":"304","messageId":"305","endLine":1,"endColumn":13},{"ruleId":"317","severity":1,"message":"318","line":63,"column":9,"nodeType":"319","endLine":63,"endColumn":19},{"ruleId":"313","severity":1,"message":"314","line":75,"column":18,"nodeType":"304","messageId":"315","endLine":75,"endColumn":19},{"ruleId":"313","severity":1,"message":"320","line":81,"column":18,"nodeType":"304","messageId":"315","endLine":81,"endColumn":19},{"ruleId":"317","severity":1,"message":"318","line":137,"column":9,"nodeType":"319","endLine":137,"endColumn":19},{"ruleId":"321","severity":1,"message":"322","line":157,"column":104,"nodeType":"311","messageId":"323","endLine":157,"endColumn":106},{"ruleId":"302","severity":1,"message":"324","line":2,"column":8,"nodeType":"304","messageId":"305","endLine":2,"endColumn":17},{"ruleId":"321","severity":1,"message":"322","line":107,"column":61,"nodeType":"311","messageId":"323","endLine":107,"endColumn":63},{"ruleId":"321","severity":1,"message":"325","line":244,"column":23,"nodeType":"311","messageId":"323","endLine":244,"endColumn":25},"@typescript-eslint/no-unused-vars","'SensorData' is defined but never used.","Identifier","unusedVar","'shallow' is defined but never used.","'ILabel' is defined but never used.","'IDataRowRID' is defined but never used.","use-isnan","Use the isNaN function to compare with NaN.","BinaryExpression","comparisonWithNaN","@typescript-eslint/no-redeclare","'j' is already defined.","redeclared","'Chart' is defined but never used.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","'i' is already defined.","eqeqeq","Expected '!==' and instead saw '!='.","unexpected","'NewWindow' is defined but never used.","Expected '===' and instead saw '=='."]