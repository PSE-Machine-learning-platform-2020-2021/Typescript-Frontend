[{"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\index.tsx":"1","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\reportWebVitals.ts":"2","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\MainController.tsx":"3","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ReferringController.tsx":"4","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\StartController.tsx":"5","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\AIController.tsx":"6","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Facade.tsx":"7","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\VisualizationController.tsx":"8","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DataCollectionController.tsx":"9","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\SensorManager.tsx":"10","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DeliveryController.tsx":"11","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\State.tsx":"12","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\index.tsx":"13","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\index.tsx":"14","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\index.tsx":"15","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\index.tsx":"16","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Language.tsx":"17","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeliveryFormat.tsx":"18","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\User.tsx":"19","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIBuilder.tsx":"20","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIDistributor.tsx":"21","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\SensorData.tsx":"22","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DatabaseConnector.tsx":"23","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ModelCreationController.tsx":"24","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\FinishController.tsx":"25","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\index.tsx":"26","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\index.tsx":"27","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\State.tsx":"28","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\State.tsx":"29","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\State.tsx":"30","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\State.tsx":"31","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Project.tsx":"32","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeviceData.tsx":"33","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\index.tsx":"34","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\State.tsx":"35","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Title\\index.tsx":"36","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\State.tsx":"37","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Input\\index.tsx":"38","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Countdown\\index.tsx":"39","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Title\\index.tsx":"40","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ConstantsText\\index.tsx":"41","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\NewProjectButton\\index.tsx":"42","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoginWindow\\index.tsx":"43","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoadModelButton\\index.tsx":"44","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Diagram\\index.tsx":"45","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Input\\Labelling\\index.tsx":"46","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Title\\index.tsx":"47","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Diagram\\index.tsx":"48","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataSet.tsx":"49","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Session.tsx":"50","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIModel.tsx":"51","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\DownloadButton\\index.tsx":"52","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\DiagramList\\index.tsx":"53","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\FinishButton\\index.tsx":"54","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\EmailList\\index.tsx":"55","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\State.tsx":"56","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataRow.tsx":"57","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Label.tsx":"58","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\QRImage\\index.tsx":"59","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LinkText\\index.tsx":"60","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ChangeToVisuBtn\\index.tsx":"61","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ProjectList\\index.tsx":"62","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ModelCreationComponents\\Train\\index.tsx":"63","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataPoint.tsx":"64","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\TimeSpan.tsx":"65","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ModelList\\index.tsx":"66","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ResultPage\\Result.tsx":"67","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ResultPage\\State.tsx":"68"},{"size":419,"mtime":1613977999233,"results":"69","hashOfConfig":"70"},{"size":440,"mtime":1613146123200,"results":"71","hashOfConfig":"70"},{"size":3971,"mtime":1618095471792,"results":"72","hashOfConfig":"70"},{"size":9967,"mtime":1618074229595,"results":"73","hashOfConfig":"70"},{"size":3568,"mtime":1617894332006,"results":"74","hashOfConfig":"70"},{"size":6117,"mtime":1618043168884,"results":"75","hashOfConfig":"70"},{"size":22397,"mtime":1618148136583,"results":"76","hashOfConfig":"70"},{"size":4142,"mtime":1618148588487,"results":"77","hashOfConfig":"70"},{"size":3066,"mtime":1618148134169,"results":"78","hashOfConfig":"70"},{"size":9796,"mtime":1617894332005,"results":"79","hashOfConfig":"70"},{"size":2372,"mtime":1618074229591,"results":"80","hashOfConfig":"70"},{"size":5142,"mtime":1617894332031,"results":"81","hashOfConfig":"70"},{"size":3556,"mtime":1616515796161,"results":"82","hashOfConfig":"70"},{"size":3338,"mtime":1617802594528,"results":"83","hashOfConfig":"70"},{"size":7654,"mtime":1618095471957,"results":"84","hashOfConfig":"70"},{"size":3543,"mtime":1618045950782,"results":"85","hashOfConfig":"70"},{"size":940,"mtime":1618043212145,"results":"86","hashOfConfig":"70"},{"size":214,"mtime":1613280191746,"results":"87","hashOfConfig":"70"},{"size":13428,"mtime":1618059189960,"results":"88","hashOfConfig":"70"},{"size":4979,"mtime":1617802594514,"results":"89","hashOfConfig":"70"},{"size":4983,"mtime":1618074229599,"results":"90","hashOfConfig":"70"},{"size":1609,"mtime":1617900063401,"results":"91","hashOfConfig":"70"},{"size":12134,"mtime":1618048187783,"results":"92","hashOfConfig":"70"},{"size":3388,"mtime":1617802594512,"results":"93","hashOfConfig":"70"},{"size":4061,"mtime":1617807543214,"results":"94","hashOfConfig":"70"},{"size":3328,"mtime":1618148588497,"results":"95","hashOfConfig":"70"},{"size":3025,"mtime":1618148588495,"results":"96","hashOfConfig":"70"},{"size":586,"mtime":1617719373909,"results":"97","hashOfConfig":"70"},{"size":581,"mtime":1616594917995,"results":"98","hashOfConfig":"70"},{"size":846,"mtime":1617721893722,"results":"99","hashOfConfig":"70"},{"size":967,"mtime":1616515796154,"results":"100","hashOfConfig":"70"},{"size":9476,"mtime":1618059130379,"results":"101","hashOfConfig":"70"},{"size":3071,"mtime":1618043212143,"results":"102","hashOfConfig":"70"},{"size":3799,"mtime":1618148588496,"results":"103","hashOfConfig":"70"},{"size":600,"mtime":1617721893724,"results":"104","hashOfConfig":"70"},{"size":371,"mtime":1617894332025,"results":"105","hashOfConfig":"70"},{"size":276,"mtime":1613662337789,"results":"106","hashOfConfig":"70"},{"size":5105,"mtime":1617894332024,"results":"107","hashOfConfig":"70"},{"size":1535,"mtime":1617894332014,"results":"108","hashOfConfig":"70"},{"size":373,"mtime":1617894332015,"results":"109","hashOfConfig":"70"},{"size":866,"mtime":1618095471925,"results":"110","hashOfConfig":"70"},{"size":1750,"mtime":1617894332023,"results":"111","hashOfConfig":"70"},{"size":3196,"mtime":1618095471938,"results":"112","hashOfConfig":"70"},{"size":1727,"mtime":1617894332021,"results":"113","hashOfConfig":"70"},{"size":5007,"mtime":1617894332017,"results":"114","hashOfConfig":"70"},{"size":5381,"mtime":1618046172868,"results":"115","hashOfConfig":"70"},{"size":369,"mtime":1617894332018,"results":"116","hashOfConfig":"70"},{"size":5484,"mtime":1618095471806,"results":"117","hashOfConfig":"70"},{"size":5380,"mtime":1618061177344,"results":"118","hashOfConfig":"70"},{"size":1837,"mtime":1618043212145,"results":"119","hashOfConfig":"70"},{"size":485,"mtime":1616514481828,"results":"120","hashOfConfig":"70"},{"size":735,"mtime":1617894332016,"results":"121","hashOfConfig":"70"},{"size":8044,"mtime":1618148588493,"results":"122","hashOfConfig":"70"},{"size":682,"mtime":1618148588494,"results":"123","hashOfConfig":"70"},{"size":7187,"mtime":1618148588490,"results":"124","hashOfConfig":"70"},{"size":698,"mtime":1616515796157,"results":"125","hashOfConfig":"70"},{"size":3185,"mtime":1618058376824,"results":"126","hashOfConfig":"70"},{"size":1877,"mtime":1618047786071,"results":"127","hashOfConfig":"70"},{"size":537,"mtime":1617894332024,"results":"128","hashOfConfig":"70"},{"size":787,"mtime":1618095471930,"results":"129","hashOfConfig":"70"},{"size":743,"mtime":1617894332020,"results":"130","hashOfConfig":"70"},{"size":4602,"mtime":1618074229602,"results":"131","hashOfConfig":"70"},{"size":14083,"mtime":1618148588491,"results":"132","hashOfConfig":"70"},{"size":1010,"mtime":1618043212141,"results":"133","hashOfConfig":"70"},{"size":1404,"mtime":1618048187749,"results":"134","hashOfConfig":"70"},{"size":1906,"mtime":1617894332022,"results":"135","hashOfConfig":"70"},{"size":3195,"mtime":1618095471962,"results":"136","hashOfConfig":"70"},{"size":669,"mtime":1617900168546,"results":"137","hashOfConfig":"70"},{"filePath":"138","messages":"139","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"fl9nei",{"filePath":"140","messages":"141","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"142","messages":"143","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"144","messages":"145","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"146","messages":"147","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"148","messages":"149","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"150","messages":"151","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"152"},{"filePath":"153","messages":"154","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"155","messages":"156","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"157","messages":"158","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"159","messages":"160","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"161","messages":"162","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"163","messages":"164","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"165","messages":"166","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"167","messages":"168","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"169","messages":"170","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"171","messages":"172","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"173","messages":"174","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"175","messages":"176","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"177"},{"filePath":"178","messages":"179","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"180","messages":"181","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"182","messages":"183","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"184","messages":"185","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"186"},{"filePath":"187","messages":"188","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"189","messages":"190","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"191","messages":"192","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"193","messages":"194","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"195","messages":"196","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"197","messages":"198","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"199","messages":"200","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"201","messages":"202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"203","messages":"204","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"205"},{"filePath":"206","messages":"207","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"208","messages":"209","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"210","messages":"211","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"212","messages":"213","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"214","messages":"215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"216","messages":"217","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"218","messages":"219","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"220","messages":"221","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"222","messages":"223","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"224","messages":"225","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"226","messages":"227","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"228","messages":"229","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"230","messages":"231","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"232","messages":"233","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"234"},{"filePath":"235","messages":"236","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"237","messages":"238","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"239"},{"filePath":"240","messages":"241","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"242"},{"filePath":"243","messages":"244","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"245","messages":"246","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"247","messages":"248","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"249","messages":"250","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"251","messages":"252","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"253","messages":"254","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"255","messages":"256","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"257","messages":"258","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"259","messages":"260","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"261","messages":"262","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"263","messages":"264","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"265","messages":"266","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"267","messages":"268","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"269","messages":"270","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"271","messages":"272","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"273","messages":"274","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"275","messages":"276","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"277","messages":"278","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"279","messages":"280","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\reportWebVitals.ts",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\MainController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ReferringController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\StartController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\AIController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Facade.tsx",["281"],"import { DeliveryFormat } from \"./DeliveryFormat\";\r\nimport { DatabaseConnector } from \"./DatabaseConnector\";\r\nimport { Language, LanguageMessages } from \"./Language\";\r\nimport { Admin, Dataminer, AIModelUser, User } from \"./User\";\r\nimport { AIBuilder } from \"./AIBuilder\";\r\nimport { AIDistributor } from \"./AIDistributor\";\r\nimport { SensorData } from \"./SensorData\";\r\nimport { AIController } from \"../controller/AIController\";\r\nimport { IDataRowST, IDataRowSTRID } from \"./DataRow\";\r\nimport { ILabel } from \"./Label\";\r\nimport { ISpan } from \"./TimeSpan\";\r\nimport { IDevice } from \"./DeviceData\";\r\nimport { IDataPoint } from \"./DataPoint\";\r\n\r\ninterface FacadeInterface {\r\n  createDataSet(sensorTypeID: number[], dataSetName: string, datarowNames?: string[]): Promise<number>;\r\n  sendDataPoint(dataRowID: number, datapoint: IDataPoint): Promise<boolean>;\r\n  sendDataPointsAgain(): Promise<boolean>;\r\n  loadProject(projectID?: number): Promise<boolean>;\r\n  getProjectMetas(): Promise<{ projectID: number, projectName: string, AIModelID: number[]; }[]>;\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[];\r\n  getSessionID(): number;\r\n  getDataRows(dataSetID: number): { dataRows: IDataRowST[]; };\r\n  getCurrentDataRows(): { dataRows: IDataRowST[]; };\r\n  getMessages(): LanguageMessages | null;\r\n  setLanguage(languageCode: string): Promise<boolean>;\r\n  getLanguageMetas(): Promise<{ languageCode: number, languageName: string; }[]>;\r\n  getAdminEmail(): string;\r\n  deleteDataSet(dataSetID: number): Promise<boolean>;\r\n  registerAdmin(adminName: string, adminEmail: string, password: string): Promise<boolean>;\r\n  registerDataminer(dataminerName: string, sessionID: number): Promise<boolean>;\r\n  registerAIModelUser(aiModelUserName: string, modelID: number): Promise<boolean>;\r\n  loginAdmin(adminEmail: string, password: string): Promise<boolean>;\r\n  createProject(projectName: string): Promise<boolean>;\r\n  createLabel(span: ISpan, labelName: string): Promise<number>;\r\n  setLabel(labelID: number, span: ISpan, labelName?: string): Promise<boolean>;\r\n  deleteLabel(labelID: number): Promise<boolean>;\r\n  getLabels(): { labels: ILabel[]; };\r\n  classify(aiId: number, dataSetId: number, callBack: <R = unknown>(prediction: string | object) => R): void;\r\n  getAIModel(id: number, format: DeliveryFormat): object;\r\n  sendAIModel(model: number, ...recipients: string[]): boolean;\r\n  applyModel(dataSets: number[], imputator: string, classifier: string, scaler: string, features: string[],\r\n    trainingDataPercentage: number, slidingWindowSize: number, slidingWindowStep: number): void;\r\n} export type { FacadeInterface };\r\n\r\n/**\r\n * Die Facade stellt alle interaktionen mit dem Model zur Verfügung\r\n */\r\nexport class Facade {\r\n  private language?: Language; //Alle Nachrichten, in der geladenen Sprache\r\n  private dbCon: DatabaseConnector; //Die Verbindung zur Datenbank\r\n  private user?: User; //Der Benutzer, entweder Admin, Datenerfasser oder AIModelUser\r\n\r\n\r\n  /**\r\n   * Erstellt die Facade\r\n   * @param languageCode der Sprachcode von der Sprache, die geladen werden soll\r\n   */\r\n  constructor(languageCode: string) {\r\n    this.dbCon = new DatabaseConnector();\r\n    this.dbCon.loadLanguage({ languageCode }).then((language: LanguageMessages) => { this.language = new Language(language); });\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein Datensatz\r\n   * @param sensorTypeID muss der Sensor Typ ID von einem Sensor des Gerätes übereinstimmen\r\n   * @param dataSetName Name des Datensatzes\r\n   * @returns true, wenn der Datensatz erstellt wurde. \r\n   * Dies ist der Fall, wenn ein Benutzer existiert welcher in einer Session ist und alle Sensortypen existieren.\r\n   */\r\n  async createDataSet(sensorTypeID: number[], dataSetName: string, datarowNames?: string[]): Promise<number> {\r\n    if (this.user === undefined) {\r\n      return -2;\r\n    }\r\n    let sessionID: number = this.getSessionID();\r\n    if (sessionID === undefined) {\r\n      sessionID = 0;\r\n    }\r\n    if (sessionID > 0 || this.user.getName() === AIController.AI_MODEL_USER_NAME) {\r\n      let projectID: number = this.user.getCurrentProjectID();\r\n      if (projectID === undefined) {\r\n        projectID = 0;\r\n      }\r\n      let userID: number = this.user.getID();\r\n      let dataRow: { sensorID: number, datarowName?: string; }[] = [];\r\n      for (let i = 0; i < sensorTypeID.length; i++) {\r\n        let sensorID = sensorTypeID[i];\r\n        if (datarowNames != null && datarowNames.length >= i) {\r\n          dataRow.push({ sensorID, datarowName: datarowNames[i] });\r\n        }\r\n        else {\r\n          dataRow.push({ sensorID });\r\n        }\r\n      }\r\n      let dataSetID: number = await this.dbCon.createDataSet({ sessionID, projectID, userID, dataSetName, dataRow });\r\n      if (dataSetID <= 0) {\r\n        return -3;\r\n      }\r\n      var dataRows: IDataRowSTRID[] = [];\r\n      for (let i = 0; i < sensorTypeID.length; i++) {\r\n        dataRows.push({ sensorType: sensorTypeID[i], dataRow: [], dataRowID: i });\r\n      }\r\n      if (this.user.createDataSet(dataSetID, dataSetName, new Date().getMilliseconds(), dataRows) || this.user.getName() === AIController.AI_MODEL_USER_NAME) {\r\n        return dataSetID;\r\n      }\r\n      return -4;\r\n    }\r\n    return -5;\r\n  }\r\n\r\n  /**\r\n   * Sendet den Datenpunkt an die Datenbank und speichert den Punkt lokal\r\n   * @param dataRowID die ID der aktuellen Datenreihe des eingelesenen Datenpunkts\r\n   * @param value der SensorWert\r\n   * @param relativeTime die relative Zeit zum Aufnahmestart in Millisekunden\r\n   * @return true, wenn der Datenpunkt erfolgreich an die Datenbank gesendet wurde\r\n   */\r\n  async sendDataPoint(dataRowID: number, datapoint: IDataPoint): Promise<boolean> {\r\n    if (this.user !== undefined) {\r\n      let sessionID: number = this.getSessionID();\r\n      let userID: number = this.user.getID();\r\n      let dataSetID: number = this.user.getCurrentDataSetID();\r\n      this.user.addDatapoint(dataRowID, datapoint);\r\n      return this.dbCon.sendDataPoint({ sessionID, userID, dataSetID, dataRowID, datapoint });\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n     * Sendet den aktuell bereits aufgenommenen Datensatz an die Datenbank\r\n     * Dafür da, falls die Verbindung verloren ging und der Datensatz neu hochgeladen werden muss\r\n     * @return true, wenn der Datensatz erfolgreich an die Datenbank gesendet wurde\r\n     */\r\n  async sendDataPointsAgain(): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let sessionID: number = this.getSessionID();\r\n      let userID: number = this.user.getID();\r\n      let dataSetID: number = this.user.getCurrentDataSetID();\r\n      let rows = this.user.getCurrentDataRows();\r\n      for (let i = 0; i < rows.dataRows.length; i++) {\r\n        var result = await this.dbCon.sendDataPointsAgain({ sessionID, userID, dataSetID, dataRowID: i, datapoints: rows.dataRows[i].datapoint });\r\n        if (!result) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Lädt aus der Datenbank das Projekt mit der übergebenen ID, hierfür muss der Admin angemeldet sein\r\n   * @param projectID die Projekt ID oder keine falls das aktuelle Projekt neu geladen werden soll\r\n   * @returns true, wenn das Projekt erfolgreich geladen wurde dies tritt nur ein, wenn eine Verbindung zur Datenbank besteht,\r\n   *          die Projekt ID existiert und der Admin dafür angemeldet ist\r\n   */\r\n  async loadProject(projectID?: number): Promise<boolean> {\r\n    if (this.user != null && this.user instanceof Admin) {\r\n      if (projectID == null) {\r\n        projectID = this.user?.getCurrentProjectID();\r\n      }\r\n      let adminEmail: string = this.user.getEmail();\r\n      let userID: number = this.user.getID();\r\n      return this.user.loadProject(await this.dbCon.loadProject({ userID, adminEmail, projectID }));\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /* Methode die noch nicht benutzt wird aber eventuell das laufgeschehen verbessern\r\n  /**\r\n     * Aktuallisiert aus der Datenbank das aktuelle Projekt, hierfür muss der Admin angemeldet sein und ein Projekt geladen sein\r\n     * @returns true, wenn das Projekt erfolgreich geladen wurde dies tritt nur ein, wenn eine Verbindung zur Datenbank besteht,\r\n     *          ein geladenes Projekt existiert und der Admin dafür angemeldet ist\r\n     \r\n  async updateCurrentProject(): Promise<boolean> {\r\n    if (this.user != null && this.user instanceof Admin) {\r\n      let projectID = this.user.getCurrentProjectID();\r\n      let adminEmail: string = this.user.getEmail();\r\n      let userID: number = this.user.getID();\r\n      return this.user.updateProject(await this.dbCon.updateProject({ userID, adminEmail, projectID }));\r\n    }\r\n    return false;\r\n  }*/\r\n\r\n\r\n  /**\r\n   * Lädt vom aktuell angemeldeten Admin von seinen Projekten den Namen, die Projekt ID und die AIModelIDs\r\n   * @returns Von allen Projekten des Admins Projekt ID und Projektname und die AIModelIDs\r\n   */\r\n  async getProjectMetas(): Promise<{ projectID: number, projectName: string, AIModelID: number[]; }[]> {\r\n    if (this.user != null) {\r\n      let userID: number = this.user.getID();\r\n      return await this.dbCon.getProjectMetas({ userID, adminEmail: this.getAdminEmail() });\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt von allen Datensätzen die Datensatz ID und der Datensatz Name zurück\r\n   */\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[] {\r\n    if (this.user !== undefined) {\r\n      return this.user.getDataSetMetas();\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID des aktuellen Projekts zurück, -1 falls kein aktuelles Projekt existiert\r\n   */\r\n  getSessionID(): number {\r\n    if (this.user != null) {\r\n      return this.user.getSessionID();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: IDataRowST[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getDataRows(dataSetID);\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen des aktuellen Datensatzes zurück\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: IDataRowST[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getCurrentDataRows();\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt aus der geladenen Sprache die Nachrichten die über die IDs angegeben werden\r\n   * @param messageID alle IDs, von denen die Sprachnachricht geladen werden soll\r\n   * @returns alle Nachrichten, in der gleichen Reihenfolge wie angefordert\r\n   */\r\n  getMessages(): LanguageMessages | null {\r\n    if (this.language != null) {\r\n      return this.language.getMessage();\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Gibt die auswählbaren Sensoren als ID mit ihrer Art in der Passenden Sprache zurück\r\n  \r\n  getAvailableSensors(): { sensorTypID: number, sensorType: string; }[] {\r\n    if (this.user != null && this.language != null) {\r\n      var sensors: { sensorTypID: number, sensorType: string; }[] = [];\r\n      let message: { messageID: number, message: string; }[] = this.language.getMessage(this.user.getAvailableSensors());\r\n      for (let i = 0; i < message.length; i++) {\r\n        sensors.push({ sensorTypID: message[i].messageID, sensorType: message[i].message });\r\n      }\r\n      return sensors;\r\n    }\r\n    return [];\r\n  }\r\n */\r\n\r\n  /**\r\n   * Lädt die Sprache aus der Datenbank mit dem übergebenen Sprachcode\r\n   * @param languageCode Sprachcode\r\n   * @returns true, falls die Sprache erfolgreich geladen wurde\r\n   */\r\n  async setLanguage(languageCode: string): Promise<boolean> {\r\n    if (this.language == null) {\r\n      const language: LanguageMessages = await this.dbCon.loadLanguage({ languageCode });\r\n      this.language = new Language(language);\r\n      return true;\r\n    } else if (languageCode !== this.language.getLanguageCode()) {\r\n      const language: LanguageMessages = await this.dbCon.loadLanguage({ languageCode });\r\n      return this.language.setLanguage(language);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gibt von allen in der Datenbank verfügbaren Sprachen den Sprachcode sowie den Sprachennamen zurück\r\n   */\r\n  getLanguageMetas(): Promise<{ languageCode: number, languageName: string; }[]> {\r\n    return this.dbCon.getLanguageMetas();\r\n  };\r\n\r\n  /**\r\n   * Gibt die Email vom Admin zurück, diese kann leer sein falls kein Admin angemeldet ist\r\n   */\r\n  getAdminEmail(): string {\r\n    if (this.user instanceof Admin) {\r\n      return this.user.getEmail();\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Löscht den Datensatz mit der übergebenen Datensatz ID\r\n   * @param dataSetID die Datensatz ID\r\n   * @returns true, wenn das löschen erfolgreich ist\r\n   */\r\n  async deleteDataSet(dataSetID: number): Promise<boolean> {\r\n    if (this.user != null && this.user.deleteDataSet(dataSetID)) {\r\n      let projectID: number = this.user.getCurrentProjectID();\r\n      if (projectID >= 0) {\r\n        let adminEmail: string = this.getAdminEmail();\r\n        let userID = this.user.getID();\r\n        return this.dbCon.deleteDataSet({ userID, adminEmail, projectID, dataSetID });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //wann Device erstellen ??? + constructor in User anpassen mit neuem Device parameter \r\n  async registerAdmin(adminName: string, adminEmail: string, password: string): Promise<boolean> {\r\n    //TODO Device\r\n    let device: IDevice = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let IDs: {\r\n      adminID: number, device: { deviceID: number, sensorID: number[]; };\r\n    } = await this.dbCon.registerAdmin({ adminName, adminEmail, password, device });\r\n    if (IDs.adminID >= 0) {\r\n      this.user = new Admin(IDs.adminID, IDs.device.deviceID, adminName, adminEmail);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async registerDataminer(dataminerName: string, sessionID: number): Promise<boolean> {\r\n    //TODO Device\r\n    let device: IDevice = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let dataminer:\r\n      {\r\n        dataminerID: number, device: { deviceID: number, sensorID: number[]; }, project: { projectID: number, projectName: string, sessionID: number; };\r\n      } = await this.dbCon.registerDataminer({ dataminerName, sessionID, device });\r\n    if (dataminer.dataminerID >= 0 && dataminer.device.deviceID >= 0) {\r\n      this.user = new Dataminer(dataminer.dataminerID, dataminer.device.deviceID, dataminerName);\r\n      this.user.loadProject(dataminer.project);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param aiModelUserName \r\n   */\r\n  async registerAIModelUser(aiModelUserName: string, modelID: number): Promise<boolean> {\r\n    //TODO Device\r\n    let device: IDevice = { deviceID: -1, deviceName: \"\", deviceType: \"\", firmware: \"\", generation: \"\", MACADRESS: \"\", sensorInformation: [] };\r\n    let aiModelUser: {\r\n      aiModelUserID: number, device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    } = await this.dbCon.registerAIModelUser({ aiModelUserName, modelID, device });\r\n    if (aiModelUser.aiModelUserID >= 0 && aiModelUser.device.deviceID >= 0) {\r\n      this.user = new AIModelUser(aiModelUser.aiModelUserID, aiModelUser.device.deviceID, aiModelUserName);\r\n      this.user.loadProject(aiModelUser.project);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //TODO Device\r\n  async loginAdmin(adminEmail: string, password: string): Promise<boolean> {\r\n    if (this.user == null) {\r\n      let adminData: {\r\n        admin: { adminID: number, deviceID: number, adminName: string, email: string, device: IDevice; };\r\n      } = await this.dbCon.loginAdmin({ adminEmail, password });\r\n      if (adminData.admin != null && adminData.admin.adminID !== -1) {\r\n        let admin = adminData.admin;\r\n        this.user = new Admin(admin.adminID, admin.deviceID, admin.adminName, admin.email, admin.device);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /* eventuell implementieren\r\n    logoutAdmin(): boolean {\r\n      if (this.user != null) {\r\n        let logout = this.dbCon.logoutAdmin(this.getAdminEmail());\r\n        if (logout) {\r\n          delete this.user;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    */\r\n\r\n  /**\r\n   * Erstellt für den angemeldeten Admin ein neues Projekt\r\n   */\r\n  async createProject(projectName: string): Promise<boolean> {\r\n    if (this.user instanceof Admin) {\r\n      let userID = this.user.getID();\r\n      let adminEmail = this.getAdminEmail();\r\n      let project: { projectID: number, sessionID: number; } = await this.dbCon.createProject({ userID, adminEmail, projectName });\r\n      return this.user.createProject(project.projectID, project.sessionID, projectName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein neues Label für den aktuellen Datensatz\r\n   * @param span Start und Endzeit des Zeitfensters in Sekunden\r\n   */\r\n  async createLabel(span: ISpan, labelName: string): Promise<number> {\r\n    if (this.user != null) {\r\n      let sessionID: number = this.getSessionID();\r\n      let userID: number = this.user.getID();\r\n      let datasetID: number = this.user.getCurrentDataSetID();\r\n      let labelID: number = await this.dbCon.createLabel({ sessionID, userID, datasetID, label: { span, labelName } });\r\n      if (labelID >= 0) {\r\n        let created: boolean = this.user.createLabel(labelID, span, labelName);\r\n        if (created) {\r\n          return labelID;\r\n        }\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Überschreibt ein bestehendes Label mit den übergebenen Parametern\r\n   * @param labelID die LabelID, die schon exisiteren muss und überschrieben wird\r\n   * @param span Start und Endzeit des Zeitfensters in Sekunden\r\n   */\r\n  async setLabel(labelID: number, span: ISpan, labelName?: string): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let setted: boolean = this.user.setLabel(labelID, span, labelName);\r\n      if (setted) {\r\n        let sessionID: number = this.getSessionID();\r\n        let userID: number = this.user.getID();\r\n        let datasetID: number = this.user.getCurrentDataSetID();\r\n        return this.dbCon.setLabel({ sessionID, userID, datasetID, label: { labelID, span, labelName } });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht das bestehende Label mit der LabelID\r\n   * @param labelID die LabelID, die schon exisitert\r\n   */\r\n  async deleteLabel(labelID: number): Promise<boolean> {\r\n    if (this.user != null) {\r\n      let deleted: boolean = this.user.deleteLabel(labelID);\r\n      if (deleted) {\r\n        let sessionID: number = this.getSessionID();\r\n        let userID: number = this.user.getID();\r\n        let dataSetID: number = this.user.getCurrentDataSetID();\r\n        return this.dbCon.deleteLabel({ sessionID, userID, dataSetID, labelID });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt die geladenen Labels zurück von dem aktuellen Datensatz\r\n   * @returns \r\n   */\r\n  getLabels(): { labels: ILabel[]; } {\r\n    if (this.user != null) {\r\n      return this.user.getLabels();\r\n    }\r\n    return { labels: [] };\r\n  }\r\n\r\n  classify(aiId: number, dataSetId: number, callBack: <R = unknown>(prediction: string | object) => R): void {\r\n    let aiBuilder = new AIBuilder(aiId);\r\n    aiBuilder.classify(dataSetId, callBack);\r\n  };\r\n\r\n  getAIModel(id: number, format: DeliveryFormat): object {\r\n    let aiDist = new AIDistributor(id, format);\r\n    return aiDist.getAIModel();\r\n  }\r\n\r\n  /**\r\n   * Erzeugt eine Anfrage an den Server, an jede übergebene E-Mail-Adresse eine E-Mail zu versenden,\r\n   * die einen Link zur Startseite des mit übergebenen KI-Modells enthält.\r\n   * \r\n   * @param model      - Die ID des zu verteilenden KI-Modells.\r\n   * @param recipients - Die Liste der E-Mail-Adressen, an die das KI-Modell verteilt werden soll.\r\n   * @returns True, wenn die Anfrage an den Server erfolgreich durchgeführt werden konnte, False sonst.\r\n   */\r\n  sendAIModel(model: number, recipients: string[]): boolean {\r\n    const distributor = new AIDistributor(model, DeliveryFormat.WEB_APP);\r\n    return distributor.sendAIModel(recipients);\r\n  }\r\n\r\n  /**\r\n   * Diese Methode erzeugt eine Anfrage an den Server, die ihn damit beauftragt, ein KI-Modell mit den \r\n   * angegebenen Parametern zu erzeugen und zu trainieren. \r\n   * \r\n   * @param dataSets               - Die zum Training zu verwendenden Datensätze.\r\n   * @param imputator              - Der zur Vervollständigung der Daten zu verwendende Imputer.\r\n   * @param classifier             - Der Klassifizierer, der das Herzstück des zu erstellenden KI-Modells darstellt.\r\n   * @param scaler                 - Der Scaler, der die Daten für den Klassifizierer aufbereitet.\r\n   * @param features               - Die Merkmale, die aus den gegebenen Datensätzen herausgearbeitet werden sollen.\r\n   * @param trainingDataPercentage - Optional. Der Anteil der Daten, der zum Training des KI-Modells verwendet werden soll. \r\n   *                                 Standardmäßig sind das alle übergebenen Daten, da wir noch kein serverseitiges Testen der KI-Modell-Qualität durchführen.\r\n   * @param slidingWindowSize      - Optional. Die Größe der Datenblöcke, die jeweils verwertet werden. Standardwert ist 128 Datenpunkte.\r\n   * @param slidingWindowStep      - Optional. Die Schrittweite von einem Datenblock zum nächsten. Standardwert ist 64 Datenpunkte. \r\n   */\r\n  applyModel(dataSets: number[], imputator: string, classifier: string, scaler: string, features: string[],\r\n    trainingDataPercentage: number = 1, slidingWindowSize: number = 128, slidingWindowStep: number = 64): void {\r\n    const aiBuilder = new AIBuilder(-1);\r\n    const projectID = this.user!.getCurrentProjectID();\r\n    aiBuilder.applyModel(dataSets, imputator, classifier, scaler, features, projectID, trainingDataPercentage, slidingWindowSize, slidingWindowStep);\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\VisualizationController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DataCollectionController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\SensorManager.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\DeliveryController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Language.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeliveryFormat.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\User.tsx",["282"],"import { AIController } from \"../controller/AIController\";\r\nimport { IDataPoint } from \"./DataPoint\";\r\nimport { IDataRowST, IDataRowSTRID } from \"./DataRow\";\r\nimport { DeviceData, IDevice } from \"./DeviceData\";\r\nimport { ILabel } from \"./Label\";\r\nimport { IProjectData, Project } from \"./Project\";\r\nimport { SensorData } from \"./SensorData\";\r\nimport { ISpan } from \"./TimeSpan\";\r\n\r\n/**\r\n * Die Vorlage für alle existierenden Benutzer\r\n */\r\nexport abstract class User {\r\n  protected id: number; //Die eindeutige User ID\r\n  protected name: string; //Der Name des Users\r\n  protected device: DeviceData; //Das Benutzergerät des Benutzers\r\n  protected currentProject?: Project;\r\n  private dataSetID: number;\r\n\r\n  /**\r\n   * Erstellt einen Benutzer\r\n   * @param id eindeutige Benutzer ID\r\n   * @param name Name des Benutzer\r\n   */\r\n  constructor(id: number, device: DeviceData, name?: string) {\r\n    if (id < 0) {\r\n      this.id = -1;\r\n    } else {\r\n      this.id = id;\r\n    }\r\n    this.device = device;\r\n    if (name !== undefined) {\r\n      this.name = name;\r\n    } else {\r\n      this.name = this.device.getName();\r\n    }\r\n    this.dataSetID = -1;\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die aktuelle Datensatz ID zurück, falls diese nicht existiert wird -1 zurück gegeben.\r\n   */\r\n  getCurrentDataSetID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getCurrentDataSetID();\r\n    } else {\r\n      return this.dataSetID;\r\n    }\r\n  }\r\n\r\n  setCurrentDataSetID(newID: number): void {\r\n    if (this.name === AIController.AI_MODEL_USER_NAME) {\r\n      this.dataSetID = newID;\r\n    } else {\r\n      this.dataSetID = -1;\r\n    }\r\n  }\r\n\r\n  getCurrentProjectID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getID();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  addDatapoint(dataRowID: number, datapoint: IDataPoint): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.addDatapoint(dataRowID, datapoint);\r\n    }\r\n    return false;\r\n\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: IDataRowST[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getDataRows(dataSetID);\r\n    } else {\r\n      return { dataRows: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt vom aktuellen Projekt die Datenreihen des aktuellen Datensatzes zurück\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: IDataRowST[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getCurrentDataRows();\r\n    } else {\r\n      return { dataRows: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID des aktuellen Projekts zurück, -1 falls kein aktuelles Projekt existiert\r\n   */\r\n  getSessionID(): number {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getSessionID();\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  /**\r\n     * Erstellt für das aktuelle Projekt einen neuen Datensatz und setzt diesen als aktuellen Datensatz.\r\n     * @param dataSetID die eindeutige Datensatz ID\r\n     * @param dataSetName der Datensatznamen\r\n     * @param generateDate die Erstellungszeit von dem Datensatz\r\n     * @returns false, falls kein aktuelles Prokekt existiert\r\n     */\r\n  createDataSet(dataSetID: number, dataSetName: string, generateDate: number, dataRow: IDataRowSTRID[]): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.createDataSet(dataSetID, dataSetName, generateDate, dataRow);\r\n    } else {\r\n      this.setCurrentDataSetID(dataSetID);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Löscht vom aktuellen Projekt den Datensatz, mit der übergebenen Datensatz ID\r\n   * @param dataSetID die Datensatz ID\r\n   * @returns gibt die ProjektID zurück, zu dem der Datensatz gehörte, -1 falls der Datensatz nicht existiert hat\r\n   */\r\n  deleteDataSet(dataSetID: number): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.deleteDataSet(dataSetID);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Erstellt für das aktuelle Projekt und dem aktuellen Datensatz ein Label mit den übergebeben Parametern\r\n   * @param labelID Ist die eindeutige Label ID des Labels.\r\n   * @param start Ist die Startzeit des Labels.\r\n   * @param end Ist die Endzeit des Labels.\r\n   * @returns false, falls kein aktueller Datensatz existiert oder die LabelID für diesen Datensatz nicht eindeutig ist\r\n   */\r\n  createLabel(labelID: number, span: ISpan, labelName: string): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.createLabel(labelID, span, labelName);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setzt beim aktuellen Datensatz dem Label mit der LabelID die neu übergebenen Daten\r\n   * @param labelID \r\n   * @param start startzeit des Labels in Millisekunden\r\n   * @param end endzeit des Labels in Millisekunden\r\n   */\r\n  setLabel(labelID: number, span: ISpan, labelName?: string): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.setLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht von dem aktuellen Projekt und dem aktuellen Datensatz das Label mit der Label ID\r\n   * @param labelID die Label ID\r\n   * @returns false, falls kein aktueller Datensatz existiert oder kein Label mit der Label ID existiert\r\n   */\r\n  deleteLabel(labelID: number): boolean {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.deleteLabel(labelID);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln vom aktuellen Datensatz zurück.\r\n   * @returns leer, falls kein aktueller Datensatz existiert\r\n   */\r\n  getLabels(): { labels: ILabel[]; } {\r\n    if (this.currentProject != null) {\r\n      return this.currentProject.getLabels();\r\n    }\r\n    return { labels: [] };\r\n  }\r\n\r\n  /**\r\n  * Lädt ein bestehendes Projekt in das Model\r\n  * @param project die Projektdaten\r\n  * @returns false, falls die Projekt ID schon existiert\r\n  */\r\n  abstract loadProject(project: IProject): boolean;\r\n\r\n  /**\r\n   * Gibt alle Sensoren aus, die das Benutzergerät und das Programm unterstützt\r\n  \r\n  getDeviceSensors(sensorTypeID: number[]): SensorData[] {\r\n    return this.device.getSensors(sensorTypeID);\r\n  }\r\n\r\n  /**\r\n   * Gibt die SensorTypID der auswählbaren Sensoren zurück\r\n  getAvailableSensors(): number[] {\r\n    return this.device.getAvailableSensors();\r\n  } */\r\n\r\n  /**\r\n   * Gibt von allen Datensätzen vom aktuellen Projekt Informationen zurück\r\n   * @returns dataSetID ist die DatensatzID und dataSetName ist der Datensatzname\r\n   */\r\n  getDataSetMetas(): { dataSetID: number, dataSetName: string; }[] {\r\n    if (this.currentProject !== undefined) {\r\n      return this.currentProject.getDataSetMetas();\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setzt einen neuen Benutzernamen\r\n   * @param name der neue Benutzername\r\n   */\r\n  setName(name: string): void {\r\n    this.name = name;\r\n  }\r\n\r\n  /**\r\n   * Gibt den Benutzernamen zurück\r\n   */\r\n  getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  /**\r\n   * Setzt ein neues Benutzergerät\r\n   * @param device das Benutzergerät\r\n   */\r\n  setDevice(device: DeviceData) {\r\n    this.device = device;\r\n  }\r\n\r\n  /**\r\n   * Gibt falls ein Benutzergerät verfügbar ist dieses zurück\r\n   */\r\n  getDevice(): { device?: DeviceData; } {\r\n    return { device: this.device };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Benutzer ID zurück\r\n   */\r\n  getID(): number {\r\n    return this.id;\r\n  }\r\n}\r\n\r\n/**\r\n * Die Klasse Admin dient für einen Benutzer mit einem Account\r\n */\r\nexport class Admin extends User {\r\n  private email: string; //Die eindeutige Admin Email\r\n  private project: Project[] = []; //Alle Projekte, die zu dem Admin gehören\r\n\r\n  /**\r\n   * Zum erstellen eines Admins\r\n   * @param adminID die Admin ID\r\n   * @param deviceID die Geräte ID des Admins\r\n   * @param adminName der Name des Admins\r\n   * @param email die Emailadresse des Admins\r\n   */\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string);\r\n\r\n  /**\r\n   * Für die Implementierung eines Bestehenden Admins\r\n   * @param adminID die Admin ID\r\n   * @param deviceID die Geräte ID\r\n   * @param adminName der Admin Name\r\n   * @param email die Emailadresse des Admins\r\n   * @param device das Gerät des Admins\r\n   */\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string, device: IDevice);\r\n  ////////////////////////////////////////TODO\r\n\r\n  constructor(adminID: number, deviceID: number, adminName: string, email: string, device?: IDevice) {\r\n    super(adminID, DeviceData.loadDevice(deviceID, device), adminName);\r\n    this.email = email;\r\n  }\r\n\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: IProject): boolean {\r\n    var id = this.existProject(project.projectID);\r\n    var newProject: Project = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    this.currentProject = newProject;\r\n    if (id === -1) {\r\n      this.project.push(newProject);\r\n    } else {\r\n      this.project[id] = newProject;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /* Methode die noch nicht benutzt wird aber eventuell das laufgeschehen verbessern\r\n    /**\r\n     * Aktuallisiert das Projekt mit den übergebenen Daten\r\n     \r\n    updateProject(project: {\r\n      projectID: number, sessionID: number, projectName: string, projectData?: {\r\n        aiModelID?: number[],\r\n        dataSet: {\r\n          dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n          dataRows: {\r\n            dataRowID: number,\r\n            dataRow: { value: number[], relativeTime: number; }[];\r\n          }[],\r\n          label: { name: string, labelID: number, start: number, end: number; }[];\r\n        }[];\r\n      };\r\n    }): boolean {\r\n      var id = this.existProject(project.projectID);\r\n      if (id === -1) {\r\n        return false;\r\n      } else {\r\n        return this.project[id].updateProject(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n      }\r\n    }\r\n    */\r\n\r\n  /**\r\n   * Fügt ein neues Projekt mit den übergebenen Parametern hinzu und setzt dieses Projekt als aktuelles Projekt\r\n   * @param projectID die Projekt ID, diese muss für den Admin eindeutig sein\r\n   * @param sessionID die Session ID, diese muss global eindeutig sein\r\n   * @param projectName der Name des Projektes\r\n   * @returns Bei angabe einer Project ID, die schon existiert wird false zurück gegeben\r\n   */\r\n  createProject(projectID: number, sessionID: number, projectName: string): boolean {\r\n    if (this.existProject(projectID) === -1) {\r\n      var newproject: Project = new Project(projectID, sessionID, projectName);\r\n      this.project.push(newproject);\r\n      this.currentProject = newproject;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prüft ob ein Projekt mit der ID existiert und gibt die Stelle im Projekt array zurück an dem das Projekt liegt\r\n   * @param projectID \r\n   * @returns -1 falls das Projekt nicht existiert oder die Array Position des Projekts\r\n   */\r\n  private existProject(projectID: number): number {\r\n    for (let i = 0; i < this.project.length; i++) {\r\n      if (this.project[i].getID() === projectID) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Admin Emailadresse zurück\r\n   */\r\n  getEmail(): string {\r\n    return this.email;\r\n  }\r\n}\r\n\r\n/**\r\n * Dataminer ist die Klasse, um Datensammler mit ihren Geräte Sensoren zu spreichern\r\n */\r\nexport class Dataminer extends User {\r\n  /**\r\n   * Erstellt einen Datensammler\r\n   * @param id die Benutzer ID\r\n   * @param name der Benutzername\r\n   * @param deviceID die Geräte ID\r\n   */\r\n  constructor(id: number, deviceID: number, name?: string) {\r\n    super(id, DeviceData.loadDevice(deviceID), name);\r\n  }\r\n\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: IProject): boolean {\r\n    this.currentProject = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * AIModelUser ist die Klasse, um KI-Modell Benutzer zu speichern\r\n */\r\nexport class AIModelUser extends User {\r\n  /**\r\n   * Erstellt einen KI-Modell Benutzer, wenn Name \"\" gesetzt ist und eine Geräte ID gesetzt ist wird als Name der Geräte Name gewählt\r\n   * @param id die eindeutige Benutzer ID\r\n   * @param name der Benutzername\r\n   * @param deviceID die Geräte ID\r\n   */\r\n  constructor(id: number, deviceID: number, name?: string) {\r\n    super(id, DeviceData.loadDevice(deviceID), name);\r\n  }\r\n\r\n  /**\r\n   * Implementiert die abstrakte Methode von User\r\n   */\r\n  loadProject(project: IProject): boolean {\r\n    this.currentProject = new Project(project.projectID, project.sessionID, project.projectName, project.projectData);\r\n    return true;\r\n  }\r\n}\r\nexport interface IProject {\r\n  projectID: number,\r\n  sessionID: number,\r\n  projectName: string,\r\n  projectData?: IProjectData;\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIBuilder.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIDistributor.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\SensorData.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DatabaseConnector.tsx",["283"],"import { IDataPoint } from \"./DataPoint\";\r\nimport { IDevice } from \"./DeviceData\";\r\nimport { ILabel } from \"./Label\";\r\nimport { LanguageMessages } from \"./Language\";\r\nimport { ISpan } from \"./TimeSpan\";\r\nimport { IProject } from \"./User\";\r\n\r\n//Die Schnittstelle zur Datenbank.\r\nexport class DatabaseConnector {\r\n  private static readonly databasePHPURL: string = \"/src/database/index.php\";\r\n  private static lastProjectUpdate: number = 0;\r\n\r\n  /**\r\n   * Gibt Name und Code jeder verfügbaren Sprache zurück\r\n   */\r\n  async getLanguageMetas(): Promise<{ languageCode: number, languageName: string; }[]> {\r\n    const result: { languageCode: number, languageName: string; }[] = await this.sendRequest(\"get_language_metas\");\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Läd die Sprache mit dem gegebenen Sprachcode, falls dieser in der Datenbank verfügbar ist\r\n   * @param languageCode Sprachcode\r\n   * @returns die Sprache\r\n   */\r\n  async loadLanguage(requestData: { languageCode: string; }): Promise<LanguageMessages> {\r\n    const result: LanguageMessages = await this.sendRequest(\"load_language\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Erzeugt ein neues Projekt in der Datenbank\r\n   * @param userID von dem Admin, der das Projekt erstellt\r\n   * @param adminEmail zur Sicherheit, muss zur ID übereinstimmen\r\n   * @param projectName der Name des neuen Projekts (Projekte dürfen nicht gleich heißen wie ein bestehendes Projekt)\r\n   * @returns ProjektID und die SessionID, falls das Projekt nicht erstellt werden konnte beides -1\r\n   */\r\n  async createProject(requestData: { userID: number, adminEmail: string, projectName: string; })\r\n    : Promise<{ projectID: number, sessionID: number; }> {\r\n    const result: { projectID: number, sessionID: number; } = await this.sendRequest(\"create_project\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Erzeugt einen leeren Datensatz in der Datenbank\r\n   * @param sessionID die SessionID des Projekts (Implizit die AdminID)\r\n   * @param projektID zur Sicherheit, muss zur SessionID übereinstimmen\r\n   * @param userID die UserID, der Daten anlegen möchte\r\n   * @param dataSetName der Name des Datensatzes\r\n   * @param dataRow die zu erzeugenden Datenreihen, die sensorID muss schon existieren\r\n   * @returns dataSetID (dataRowID ist implizit, da es die ID der Position im Array von dataRow ist (beginnend mit 1)), bei Fehler -1\r\n   */\r\n  async createDataSet(requestData:\r\n    { sessionID: number, projectID: number, userID: number, dataSetName: string, dataRow: { sensorID: number, datarowName?: string; }[]; })\r\n    : Promise<number> {\r\n    const dataSetID: number = (await this.sendRequest(\"create_data_set\", requestData)).dataSetID;\r\n    return dataSetID;\r\n  }\r\n\r\n  /**\r\n   * Sendet den Datenpunkt mit den übergebenen Parametern\r\n   * @param sessionID die Session ID\r\n   * @param userID zur Sicherheit, muss zur SessionID und zur DatensatzID übereinstimmen\r\n   * @param datSetID \r\n   * @param dataRowID \r\n   * @param datapoint \r\n   */\r\n  async sendDataPoint(requestData: { sessionID: number, userID: number, dataSetID: number, dataRowID: number, datapoint: IDataPoint; })\r\n    : Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"send_data_point\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Sendet die Datenpunkte mit den übergebenen Parametern, falls die Verbindung abgebrochen ist um alle Datenpunkte auf einmal zu senden\r\n   * @param sessionID die Session ID\r\n   * @param userID zur Sicherheit, muss zur SessionID und zur DatensatzID übereinstimmen\r\n   * @param datSetID \r\n   * @param dataRowID \r\n   * @param datapoints alle zu sendenden Datenpunkten \r\n   */\r\n  async sendDataPointsAgain(requestData: { sessionID: number, userID: number, dataSetID: number, dataRowID: number, datapoints: IDataPoint[]; })\r\n    : Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"send_data_points_again\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Lädt das Projekt mit der ensprechenden userID und ProjektID.\r\n   * @param userID \r\n   * @param adminEmail zur Sicherheit, muss zur UserID übereinstimmen\r\n   * @param projectID \r\n   * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n   */\r\n  async loadProject(requestData: { userID: number, adminEmail: string, projectID: number; }): Promise<IProject> {\r\n    let time: number = new Date().getMilliseconds();\r\n    const result: IProject = await this.sendRequest(\"load_project\", requestData);\r\n    if (result.projectID != null) {\r\n      DatabaseConnector.lastProjectUpdate = time;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /* Methode die noch nicht benutzt wird aber eventuell das laufgeschehen verbessern\r\n  /**\r\n   * Lädt das Projekt mit der ensprechenden userID und ProjektID.\r\n   * @param userID \r\n   * @param adminEmail zur Sicherheit, muss zur UserID übereinstimmen\r\n   * @param projectID \r\n   * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n   \r\n  async updateProject(requestData1: { userID: number, adminEmail: string, projectID: number; }): Promise<{\r\n    projectID: number, sessionID: number, projectName: string, projectData?: {\r\n      aiModelID?: number[],\r\n      dataSet: {\r\n        dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n        dataRows: {\r\n          dataRowID: number, recordingStart: number,\r\n          dataRow: { value: number[], relativeTime: number; }[];\r\n        }[],\r\n        label: { name: string, labelID: number, start: number, end: number; }[];\r\n      }[];\r\n    };\r\n  }> {\r\n    const requestData: { userID: number, adminEmail: string, projectID: number, lastUpdate?: number; } = requestData1;\r\n    requestData.lastUpdate = DatabaseConnector.lastProjectUpdate;\r\n    let time: number = new Date().getMilliseconds();\r\n    const result: {\r\n      projectID: number, sessionID: number, projectName: string, projectData?: {\r\n        aiModelID?: number[],\r\n        dataSet: {\r\n          dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n          dataRows: {\r\n            dataRowID: number, recordingStart: number,\r\n            dataRow: { value: number[], relativeTime: number; }[];\r\n          }[],\r\n          label: { name: string, labelID: number, start: number, end: number; }[];\r\n        }[];\r\n      };\r\n    } = await this.sendRequest(\"update_project\", requestData);\r\n    if (result.projectID != null) {\r\n      DatabaseConnector.lastProjectUpdate = time;\r\n    }\r\n    return result;\r\n  }\r\n  */\r\n\r\n  /**\r\n   * Gibt von allen Projekten des angemeldeten Admins, mit der Email adminEmail, die Projekt ID und den Projekt Namen zurück\r\n   * @param userID\r\n   * @param adminEmail zur Sicherheit, muss zur UserID übereinstimmen\r\n   */\r\n  async getProjectMetas(requestData: { userID: number, adminEmail: string; })\r\n    : Promise<{ projectID: number, projectName: string, AIModelID: number[]; }[]> {\r\n    const result: { projectID: number, projectName: string, AIModelID: number[]; }[]\r\n      = await this.sendRequest(\"get_project_metas\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Löscht den Datensatz im Projekt welcher die angegebene ID besitzt\r\n   * @param userID\r\n   * @param adminEmail zur Sicherheit, muss zur UserID übereinstimmen\r\n   * @param projectID \r\n   * @param dataSetID \r\n   * @returns ob der Datenset erfolgreich gelöscht wurde\r\n   */\r\n  async deleteDataSet(requestData: { userID: number, adminEmail: string, projectID: number, dataSetID: number; }): Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"delete_data_set\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n     * Registriert einen neuen Projektleiter. \r\n     * @param adminName \r\n     * @param adminEmail \r\n     * @param password \r\n     * @param device \r\n     * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n     */\r\n  async registerAdmin(requestData: { adminName: string, adminEmail: string, password: string, device: IDevice; })\r\n    : Promise<{ adminID: number, device: { deviceID: number, sensorID: number[]; }; }> {\r\n    const result: { adminID: number, device: { deviceID: number, sensorID: number[]; }; } = await this.sendRequest(\"register_admin\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Registriert einen Datenerfasser.\r\n   * @param dataminerName \r\n   * @param sessionID die SessionID, mit der der Datenerfasser verknüpft ist, diese bestimmt in welchem Projekt die Daten abgelegt werden\r\n   * @param device \r\n   * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n   */\r\n  async registerDataminer(requestData: { dataminerName: string, sessionID: number, device: IDevice; })\r\n    : Promise<{\r\n      dataminerID: number,\r\n      device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    }> {\r\n    const result: {\r\n      dataminerID: number,\r\n      device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    }\r\n      = await this.sendRequest(\"register_dataminer\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Registriert einen KI-Anwender\r\n   * @param aiModelUserName \r\n   * @param modelID \r\n   * @param device \r\n   * @returns Gibt die Daten zurück, als Fehler werden alle IDs auf -1 gesetzt\r\n   */\r\n  async registerAIModelUser(requestData: { aiModelUserName: string, modelID: number, device: IDevice; })\r\n    : Promise<{\r\n      aiModelUserID: number,\r\n      device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    }> {\r\n    const result: {\r\n      aiModelUserID: number,\r\n      device: { deviceID: number, sensorID: number[]; },\r\n      project: { projectID: number, projectName: string, sessionID: number; };\r\n    }\r\n      = await this.sendRequest(\"register_ai_model_user\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Meldet den Admin an. \r\n   * @param email \r\n   * @param password \r\n   */\r\n  async loginAdmin(requestData: { adminEmail: string, password: string; })\r\n    : Promise<{ admin: { adminID: number, deviceID: number, adminName: string, email: string, device: IDevice; }; }> {\r\n    const result: { admin: { adminID: number, deviceID: number, adminName: string, email: string, device: IDevice; }; }\r\n      = await this.sendRequest(\"login_admin\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein Label\r\n   * @param sessionID \r\n   * @param userID \r\n   * @param datasetID \r\n   * @param label \r\n   * @returns labelID\r\n   */\r\n  async createLabel(requestData: { sessionID: number, userID: number, datasetID: number, label: { span: ISpan, labelName: string; }; }): Promise<number> {\r\n    const result: number = (await this.sendRequest(\"create_label\", requestData)).labelID;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Setzt dem bestehenden Label neue Werte\r\n   * @param sessionID \r\n   * @param userID \r\n   * @param datasetID \r\n   * @param label \r\n   */\r\n  async setLabel(requestData: { sessionID: number, userID: number, datasetID: number, label: { labelID: number, span: ISpan, labelName?: string; }; }): Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"set_label\", requestData);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Löscht das Label\r\n   * @param sessionID \r\n   * @param userID \r\n   * @param datasetID \r\n   * @param labelID \r\n   */\r\n  async deleteLabel(requestData: { sessionID: number, userID: number, dataSetID: number, labelID: number; }): Promise<boolean> {\r\n    const result: boolean = await this.sendRequest(\"delete_label\", requestData);\r\n    return result;\r\n  }\r\n\r\n  private async sendRequest(action: string, requestData?: object): Promise<any> {\r\n    const headers = { 'Content-Type': 'application/json' };\r\n    var obj;\r\n    await fetch(DatabaseConnector.databasePHPURL + \"?action=\" + action, { method: 'POST', headers, body: JSON.stringify(requestData) })\r\n      .then(response => response.json()).then(data => { obj = data; }).catch(function () {\r\n        obj = false;\r\n      });\r\n    return obj;\r\n  }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\ModelCreationController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\controller\\FinishController.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\StartPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\FinishPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ReferringPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DataCollectionPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Project.tsx",["284"],"import { AIModel } from \"./AIModel\";\r\nimport { IDataPoint } from \"./DataPoint\";\r\nimport { IDataRowRID, IDataRowST, IDataRowSTRID } from \"./DataRow\";\r\nimport { DataSet, IDataSet } from \"./DataSet\";\r\nimport { ILabel } from \"./Label\";\r\nimport { Session } from \"./Session\";\r\nimport { ISpan } from \"./TimeSpan\";\r\n\r\n/**\r\n * Diese Klasse speichert alle Informationen zu einem Projekt.\r\n * Ein Projekt beinhaltet aufgezeichnete Datensätze (DataSet) sowie Informationen zu den Datensätzen.\r\n */\r\nexport class Project {\r\n  private id: number; //Die eindeutige Projekt ID\r\n  private name: string; //Der Name des Projektes\r\n  private session: Session; //Die Session in dem das Projekt arbeitet\r\n  private aiModel: AIModel[] = []; //Das AIModel von dem Projekt\r\n  private dataSet: DataSet[] = []; //Die Datensätze, die zu dem Projekt gehören\r\n  private currentDataSet?: DataSet; //Aktueller Datensatz\r\n\r\n  /**\r\n     * Eine bereits existierendes Projekt kann wie folgt in das Model geladen werden.\r\n     * @param projectID Die Projekt ID\r\n     * @param sessionID Die Session ID\r\n     * @param projectName Der Projektnamen\r\n     * @param admin Der Besitzer dieses Projekts für die Session\r\n     * @param aiModelID Die schon existierenden AIModel IDs\r\n     * @param dataSet Die schon existierenden Datensätze\r\n     */\r\n  constructor(projectID: number, sessionID: number, projectName: string, projectData?: IProjectData) {\r\n    this.id = projectID;\r\n    this.name = projectName;\r\n    this.session = new Session(sessionID);\r\n    if (projectData !== undefined) {\r\n      if (projectData.aiModelID !== undefined) {\r\n        for (const id of projectData.aiModelID) {\r\n          this.aiModel.push(new AIModel(id));\r\n        }\r\n      }\r\n      for (const entry of projectData.dataSet) {\r\n        let dataSet: DataSet;\r\n        dataSet = new DataSet(\r\n          entry.dataSetID,\r\n          entry.dataSetName,\r\n          entry.generateDate,\r\n          entry.dataRows,\r\n          entry.label\r\n        );\r\n        this.dataSet.push(dataSet);\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Methode die noch nicht benutzt wird aber eventuell das laufgeschehen verbessern\r\n    updateProject(projectID: number, sessionID: number, projectName: string, projectData?: {\r\n      aiModelID?: number[],\r\n      dataSet: {\r\n        dataRowSensors: SensorData[], dataSetID: number, dataSetName: string, generateDate: number,\r\n        dataRows: {\r\n          dataRowID: number,\r\n          dataRow: { value: number[], relativeTime: number; }[];\r\n        }[],\r\n        label: { name: string, labelID: number, start: number, end: number; }[];\r\n      }[];\r\n    }): boolean {\r\n      if (this.id == projectID && sessionID == this.session.getID()) {\r\n        this.name = projectName;\r\n        if (projectData !== undefined) {\r\n          if (projectData.aiModelID !== undefined) {\r\n            for (const id of projectData.aiModelID) {\r\n              for (let i: number = 0; i < this.aiModel.length; i++) {\r\n                if (id == this.aiModel[i].getID()) {\r\n                  break;\r\n                }\r\n                if (i == this.aiModel.length - 1) {\r\n                  this.aiModel.push(new AIModel(id));\r\n                }\r\n              }\r\n            }\r\n          }////////////////////////////////////////////////////////TODO\r\n          /*\r\n          for (const entry of projectData.dataSet) {\r\n            let dataSet = new DataSet(\r\n              entry.dataRowSensors,\r\n              entry.dataSetID,\r\n              entry.dataSetName,\r\n              entry.generateDate,\r\n              entry.dataRows,\r\n              entry.label\r\n            );\r\n            this.dataSet.push(dataSet);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  */\r\n\r\n  /**\r\n   * Gibt den Projektnamen zurück\r\n   */\r\n  getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  /**\r\n   * Löscht den Datensatz mit der DatensatzID\r\n   * @param dataSetID die Datensatz ID\r\n   */\r\n  deleteDataSet(dataSetID: number): boolean {\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() === dataSetID) {\r\n        this.dataSet.splice(i, 1);\r\n        if (this.currentDataSet != null && this.currentDataSet.getID() === dataSetID) {\r\n          delete this.currentDataSet;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Projekt ID zurück.\r\n   */\r\n  getID(): number {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Erstellt einen neuen Datensatz und setzt diesen als aktuellen Datensatz.\r\n   * @param dataRowSensors die Sensoren, von denen die Daten ausgelesen werden\r\n   * @param dataSetID die eindeutige Datensatz ID\r\n   * @param dataSetName der Datensatznamen\r\n   * @param generateDate die Erstellungszeit von dem Datensatz\r\n   */\r\n  createDataSet(dataSetID: number, dataSetName: string, generateDate: number, dataRow: IDataRowSTRID[]): boolean {\r\n    if (dataRow.length <= 0 || dataSetID < 0 || dataSetName.length <= 0 || (generateDate != null && generateDate < 0)) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() === dataSetID) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var dataSet: DataSet = new DataSet(dataSetID, dataSetName, generateDate, dataRow);\r\n    this.dataSet.push(dataSet);\r\n    this.currentDataSet = dataSet;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gibt die aktuelle Datensatz ID zurück, falls diese nicht existiert wird -1 zurück gegeben\r\n   */\r\n  getCurrentDataSetID(): number {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.getID();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Fügt den übergebenen Datenpunkt dem aktuellen Datensatz hinzu\r\n   * @param dataRowID die DatenreihenID\r\n   * @param datapoint der Datenpunkt\r\n   * @returns true, wenn der Datenpunkt zur Datenreihe hinzugefügt werden konnte\r\n   */\r\n  addDatapoint(dataRowID: number, datapoint: IDataPoint): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.addDatapoint(dataRowID, datapoint);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt von allen Datensätzen Informationen zurück\r\n   * @returns dataSetID ist die DatensatzID und dataSetName ist der Datensatzname\r\n   */\r\n  getDataSetMetas(): IDataSetInfo[] {\r\n    let dataSetMetas: { dataSetID: number, dataSetName: string; }[] = [];\r\n    for (const dataSet of this.dataSet) {\r\n      dataSetMetas.push({ \"dataSetID\": dataSet.getID(), \"dataSetName\": dataSet.getName() });\r\n    }\r\n    return dataSetMetas;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datenreihen der Datensatz ID zurück und setzt diesen Datensatz als aktuellen Datensatz\r\n   * @param dataSetID die Datensatz ID von der die Datenreihen gelesen werden sollen\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getDataRows(dataSetID: number): { dataRows: IDataRowST[]; } {\r\n    for (let i = 0; i < this.dataSet.length; i++) {\r\n      if (this.dataSet[i].getID() === dataSetID) {\r\n        this.currentDataSet = this.dataSet[i];\r\n        return { dataRows: this.dataSet[i].getDataRows() };\r\n      }\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datenreihen der aktuellen Datenreihe zurück\r\n   * @returns die Sensordaten von der Datenreihe\r\n   */\r\n  getCurrentDataRows(): { dataRows: IDataRowST[]; } {\r\n    if (this.currentDataSet != null) {\r\n      return { dataRows: this.currentDataSet.getDataRows() };\r\n    }\r\n    return { dataRows: [] };\r\n  }\r\n\r\n  /**\r\n   * Gibt die Session ID zurück\r\n   */\r\n  getSessionID(): number {\r\n    return this.session.getID();\r\n  }\r\n\r\n  /**\r\n   * Setzt dem Label mit der übergebenen ID neue Werte.\r\n   * @param start Ist die neue Startzeit des Labels.\r\n   * @param end Ist die neue Endzeit des Labels.\r\n   * @param labelID Die Label ID, welche überarbeitet werden soll.\r\n   * @param labelName Ist bei Angabe der neue Name des Labels.\r\n   * @returns falls das Label nicht existiert oder es kein aktuellen Datensatz gibt wird false zurück gegeben\r\n   */\r\n  createLabel(labelID: number, span: ISpan, labelName: string): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.createLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Überschreibt ein bestehendes Label \r\n   * @param labelID die LabelID von dem zu überschreibenden Label\r\n   * @param span das neue Zeitfenster\r\n   * @param labelName falls das Label neu benannt werden soll\r\n   * @returns \r\n   */\r\n  setLabel(labelID: number, span: ISpan, labelName?: string): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.setLabel(labelID, span, labelName);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht ein bestehendes Label mit der LabelID\r\n   * @param labelID die LabelID, von dem Label das gelöscht werden soll\r\n   * @returns \r\n   */\r\n  deleteLabel(labelID: number): boolean {\r\n    if (this.currentDataSet != null) {\r\n      return this.currentDataSet.deleteLabel(labelID);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln vom aktuellen Datensatz zurück.\r\n   * @returns leer, falls kein aktueller Datensatz existiert\r\n   */\r\n  getLabels(): { labels: ILabel[]; } {\r\n    if (this.currentDataSet != null) {\r\n      return { labels: this.currentDataSet.getLabels() };\r\n    }\r\n    return { labels: [] };\r\n  }\r\n}\r\nexport interface IDataSetInfo {\r\n  dataSetID: number,\r\n  dataSetName: string;\r\n}\r\nexport interface IProjectData {\r\n  aiModelID?: number[],\r\n  dataSet: IDataSet[];\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DeviceData.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\VisualizationPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\DeliveryPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\StartComponents\\Input\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Countdown\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ConstantsText\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\NewProjectButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoginWindow\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LoadModelButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Diagram\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Input\\Labelling\\index.tsx",["285","286"],"import React, { Component, ChangeEvent } from 'react';\r\nimport { NotificationManager } from 'react-notifications';\r\n\r\nexport default class Labelling extends Component {\r\n    state = {\r\n        labels: [] as { labelID: number, start: number, end: number, name: string; }[],\r\n        newStart: \"\", newEnd: '', newName: \"\"\r\n    };\r\n\r\n    props = {\r\n        //die Funktion für neues Label zu addieren, durch props übermittelt\r\n        newLabel: function (label: {\r\n            labelID: number;\r\n            start: number;\r\n            end: number;\r\n            name: string;\r\n        }) { },\r\n        //die Funktion für Label zu löschen, durch props übermittelt\r\n        pagedeleteLabel: function (label: {\r\n            labelID: number;\r\n            start: number;\r\n            end: number;\r\n            name: string;\r\n        }) { }\r\n    };\r\n    IDcounter: number = 0; //berechnet ID von Label\r\n\r\n    /**\r\n     * aktualisiert den State zu den eingegebenen Label-Namen\r\n     * @param e Eingabeaktion\r\n     */\r\n    handleChangeLabel = (e: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ newName: e.target.value });\r\n    };\r\n\r\n    /**\r\n     * aktualisiert den State zu dem eingegebenen Zeitfenstersanfang\r\n     * @param e Eingabeaktion\r\n     */\r\n    handleChangeStart = (e: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ newStart: e.target.value });\r\n    };\r\n\r\n    /**\r\n     * aktualisiert den State zu dem eingegebenen Zeitfenstersende\r\n     * @param e Eingabeaktion\r\n     */\r\n    handleChangeEnd = (e: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ newEnd: e.target.value });\r\n    };\r\n\r\n    /**\r\n     * anrufe die Addierenmethode und leere die Eingabefelder\r\n     */\r\n    handleClick = () => {\r\n        const { newStart, newEnd, newName } = this.state;\r\n        const labelObj = { start: newStart, end: newEnd, name: newName };\r\n        this.addLabel(labelObj);\r\n        this.setState({ newStart: \"\", newEnd: '', newName: \"\" });\r\n    };\r\n\r\n    /**\r\n     * addiere das eingegebene Label\r\n     */\r\n    addLabel = (labelObj: { start: string, end: string, name: string; }) => {\r\n        if (labelObj.start === \"\" || labelObj.end === \"\") {\r\n            NotificationManager.error(\"Das Labelzeitfenster muss bestimmt werden!\");\r\n            return;\r\n        }\r\n        if (labelObj.name === \"\") {\r\n            NotificationManager.error(\"Das Labelzeitfenster braucht einen Namen!\");\r\n            return;\r\n        }\r\n        labelObj.start = labelObj.start.replace(\",\", \".\");\r\n        labelObj.end = labelObj.end.replace(\",\", \".\");\r\n        let start = this.formatFloatInString(labelObj.start);\r\n        let end = this.formatFloatInString(labelObj.end);\r\n        if (start === NaN && end === NaN) {\r\n            NotificationManager.success(\"Das Labelzeitfenster muss mit einer Start und Endzeit bestimmt werden,\\n die Angabe ist in Sekunden.\");\r\n            return;\r\n        }\r\n        const label: { labelID: number, start: number, end: number, name: string; } = {\r\n            labelID: this.IDcounter,\r\n            start: start,\r\n            end: end,\r\n            name: labelObj.name\r\n        }; //was ist bei fehlerfall?? keine Zahlen\r\n        this.props.newLabel(label);\r\n        const { labels } = this.state;\r\n        const newLabels = [label, ...labels];\r\n        this.setState({ labels: newLabels });\r\n    };\r\n\r\n    /**\r\n     * lösche das entsprechende Label\r\n     * @param e die Klickaktion\r\n     * @param id ID von dem Label, das gelöscht wird\r\n     */\r\n    deleteLabel = (e: React.MouseEvent<HTMLButtonElement>, id: number) => {\r\n\r\n        const { labels } = this.state;\r\n\r\n        let newLabels = labels.filter((label) => {\r\n            if (label.labelID === id) {\r\n                this.props.pagedeleteLabel(label);\r\n            }\r\n            return label.labelID !== id;\r\n        });\r\n        this.setState({ labels: newLabels });\r\n    };\r\n\r\n    /**\r\n     * verwandelt String zur Nummer\r\n     * @param stringNumber das String, das verwandelt wird\r\n     * @returns die entsprechende Nummer\r\n     */\r\n    private formatFloatInString(stringNumber: string): number {\r\n        return (parseInt((parseFloat(stringNumber) * 1000).toString()) / 1000);\r\n    }\r\n\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"label-wrap\">\r\n                {\r\n                    this.state.labels.map((label) => {\r\n                        return (\r\n                            <li >\r\n                                Von {label.start}s bis {label.end}s:  {label.name}\r\n                                <button className='delete' onClick={(e) => this.deleteLabel(e, label.labelID)}>Löschen</button>\r\n                            </li>\r\n                        );\r\n                    })}\r\n                <div>\r\n                    Start:\r\n                        <input type=\"text\" value={this.state.newStart} onChange={this.handleChangeStart} /><br />\r\n\r\n                    End:\r\n                        <input type=\"text\" value={this.state.newEnd} onChange={this.handleChangeEnd} /><br />\r\n\r\n                    Label:\r\n                        <input type=\"text\" value={this.state.newName} onChange={this.handleChangeLabel} />\r\n                    <br />\r\n\r\n                    <button className='add' type=\"button\" onClick={() => this.handleClick()}>Add Label</button>\r\n                </div>\r\n\r\n            </div>\r\n        );\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\FinishComponents\\Title\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DataCollectionComponents\\Diagram\\index.tsx",["287"],"import { Component, CSSProperties } from 'react';\r\nimport './index.css'\r\n\r\nexport default class Diagram extends Component {\r\n\r\n    /**\r\n     * der Datensatz für Linie-Diagramm und die Funktion für Seitewechsel, durch props übermittelt\r\n     */\r\n    props = {\r\n        dataRows: [{ sensorType: 1, datapoint: [{ value: [5], relativeTime: 5 }] }],\r\n        pageChangeToFinish: function () { }\r\n    };\r\n\r\n    /**\r\n     * der Datensatz in chart-js form\r\n     */\r\n    state = {\r\n        diagrammData: {\r\n            lineLabels: [] as any[],\r\n            sensorRow: [] as any[],\r\n            datavalue: [] as any[],\r\n            time: [] as any[],\r\n            showDiagram: false,\r\n            diagram: {},\r\n            diagramLineLabels: {},\r\n            diagramData: {},\r\n            diagramOptions: {},\r\n            color: ['rgba(46,190,87,1)', 'rgba(68,24,232,1)', 'rgba(238,173,14,1)', 'rgba(178,34,34,1)', 'rgba(238, 130, 238,1)', 'rgba(0, 0, 0,1)',\r\n                'rgba(106, 90, 205,1)', 'rgba(238, 118, 0,1)', 'rgba(105, 105, 105,1)'],\r\n            csscolor: ['#2EBE57', '#CC00FF', '#EEAD0E', '#B22222', '#EE82EE', '#000000',\r\n                '#6A5ACD', '#EE7600', '#696969'],\r\n        }\r\n    };\r\n\r\n    /**\r\n     * aktualisiert das Diagramm mit dem neuen Datensatz\r\n     */\r\n    updateDiagramm() {\r\n        let diagrammData = this.state.diagrammData;\r\n        diagrammData.lineLabels = [];\r\n        diagrammData.sensorRow = [];\r\n        diagrammData.datavalue = [];\r\n        diagrammData.time = [];\r\n        diagrammData.showDiagram = true;\r\n\r\n        var datavalues = [];\r\n        for (var z = 0; z < this.props.dataRows.length; z++) {\r\n            this.state.diagrammData.sensorRow.push(this.props.dataRows[z].sensorType);\r\n            for (var dataCoordinate = 0; dataCoordinate < 3; dataCoordinate++) {\r\n                for (var j = 0; j < this.props.dataRows[z].datapoint.length; j++) {\r\n                    datavalues.push(this.props.dataRows[z].datapoint[j].value[dataCoordinate]);\r\n                }\r\n                this.state.diagrammData.datavalue.push(datavalues);\r\n                datavalues = [];\r\n            }\r\n        }\r\n        for (var j = 0; j < this.props.dataRows[0].datapoint.length; j++) {\r\n            this.state.diagrammData.time.push(this.props.dataRows[0].datapoint[j].relativeTime);\r\n        }\r\n\r\n        var newDatasets = [];\r\n        var lineLabels = [];\r\n        for (var i = 0; i < this.state.diagrammData.sensorRow.length * 3; i++) {\r\n            var coordinate = \".X\";\r\n            var sensor = this.state.diagrammData.sensorRow[(i / 3) | 0];\r\n            var sensorName = '';\r\n            /**\r\n                 * unterscheidet, welche Sensor es ist\r\n                 */\r\n            switch (sensor) {\r\n                case 2:\r\n                    sensorName = 'Accelerometer';\r\n                    break;\r\n                case 3:\r\n                    sensorName = 'Gyroscope';\r\n                    break;\r\n                case 4:\r\n                    sensorName = 'Magnetometer';\r\n                    break;\r\n            }\r\n            /**\r\n                 * unterscheidet, von welchem Koordinate dieser Datenpunkt ist\r\n                 */\r\n            if (i % 3 === 1) {\r\n                coordinate = \".Y\";\r\n            }\r\n            if (i % 3 === 2) {\r\n                coordinate = \".Z\";\r\n            }\r\n\r\n            let color: CSSProperties = { \"color\": this.state.diagrammData.csscolor[i] };\r\n            lineLabels.push(<span style={color}>■{sensorName + coordinate}<br /></span>);\r\n            newDatasets.push(\r\n                {\r\n                    label: sensor + coordinate,\r\n                    strokeColor: this.state.diagrammData.color[i],\r\n                    borderWidth: 1,\r\n                    data: this.state.diagrammData.datavalue[i],\r\n                }\r\n            );\r\n        }\r\n        const data = {\r\n            labels: this.state.diagrammData.time,\r\n            datasets: newDatasets\r\n        };\r\n        const options = {\r\n            datasetFill: false,\r\n            pointDotRadius: 2,\r\n            pointHitDetectionRadius: 1,\r\n            offsetGridLines: false,\r\n            pointDot: false,\r\n            title: {\r\n                display: true,\r\n                text: 'Chart.js bar Chart'\r\n            },\r\n            scales: {\r\n                xAxes: [{\r\n                    ticks: {\r\n                        beginAtZero: true,\r\n                        callback: function (value: number) { if (Number.isInteger(value)) { return value; } },\r\n                        stepSize: 1\r\n                    }\r\n                }]\r\n            }\r\n        };\r\n        diagrammData = this.state.diagrammData;\r\n        diagrammData.diagramData = data;\r\n        diagrammData.lineLabels = lineLabels;\r\n        diagrammData.diagramOptions = options;\r\n    }\r\n\r\n    submit = () => {\r\n        this.props.pageChangeToFinish();\r\n    };\r\n\r\n    /**\r\n     * Rendert diese Diagram-Komponente\r\n     * @returns Diagramm-Teil\r\n     */\r\n    render() {\r\n        var LineChart = require(\"react-chartjs\").Line;\r\n        this.updateDiagramm();\r\n        return (\r\n            <div>\r\n                {this.state.diagrammData.lineLabels}\r\n                <LineChart data={this.state.diagrammData.diagramData} options={this.state.diagrammData.diagramOptions} width=\"400\" height=\"200\" redraw />\r\n                <button className = 'button' type=\"button\" onClick={this.submit}>ChangeToFinish</button>\r\n            </div>\r\n        );\r\n    }\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataSet.tsx",["288","289"],"import { IDataPoint } from \"./DataPoint\";\r\nimport { DataRow, IDataRowRID, IDataRowST, IDataRowSTRID } from \"./DataRow\";\r\nimport { ILabel, Label } from \"./Label\";\r\nimport { SensorData } from \"./SensorData\";\r\nimport { ISpan } from \"./TimeSpan\";\r\n\r\n/**\r\n * Die Klasse fasst Datenreihen, welche Sensorwerte und deren relative Zeit besitzen, zu einem Datensatz zusammen.\r\n */\r\nexport class DataSet {\r\n  private generateDate: number; //Dies ist die Erstellungszeit dieses Datensatzes in Millisekunden.\r\n  private id: number; //Dies ist die Datensatz ID.\r\n  private name: string; //Dies ist der Name des Datensatzes.\r\n  private dataRow: DataRow[] = []; //Dies sind die Datenreihen, welche zu dem Datensatz gehören.\r\n  private label: Label[] = []; //Dies sind die existierenden Labels für den Datensatz.\r\n\r\n  /**\r\n   * Eine bereits existierende Datensatz kann wie folgt in das Model geladen werden.\r\n   * @param dataRowSensors die Sensoren, von denen die Daten ausgelesen werden, \r\n   * die Anzahl muss mit der Anzahl der Datenreihen übereinstimmen. Und der i´te Sensor wird zur i´ten Datenreihe hinzugefügt.\r\n   * @param dataSetID die eindeutige Datensatz ID\r\n   * @param dataSetName der Datensatznamen\r\n   * @param generateDate die Erstellungszeit von dem Datensatz\r\n   * @param dataRows die schon existierenden Datenreihen\r\n   * @param label die schon existierenden Labels\r\n   */\r\n  constructor(dataSetID: number, dataSetName: string, generateDate: number, dataRows: IDataRowSTRID[], label?: ILabel[]) {\r\n    if (dataRows != null) {\r\n      for (let i = 0; i < dataRows.length; i++) {\r\n        this.dataRow.push(new DataRow({ SensorTypeID: dataRows[i].sensorType }, dataRows[i].dataRowID, dataRows[i].dataRow));\r\n      }\r\n    }\r\n    if (label != null) {\r\n      for (let i = 0; i < label.length; i++) {\r\n        if (label[i].span !== undefined) {\r\n          this.label.push(new Label(label[i].name, label[i].labelID, label[i].span));\r\n        } else if (label[i].start !== undefined && label[i].end !== undefined) {\r\n          this.label.push(new Label(label[i].name, label[i].labelID, { start: label[i].start!, end: label[i].end! }));\r\n        }\r\n      }\r\n    }\r\n    if (generateDate != null) {\r\n      this.generateDate = generateDate;\r\n    } else {\r\n      this.generateDate = new Date().getTime();\r\n    }\r\n    this.id = dataSetID;\r\n    this.name = dataSetName;\r\n  }\r\n\r\n  /**\r\n   * Gibt die Datensatz ID zurück.\r\n   */\r\n  public getID(): number {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Gibt den Datensatz Namen zurück.\r\n   */\r\n  public getName(): string {\r\n    return this.name;\r\n  }\r\n\r\n  addDatapoint(dataRowID: number, datapoint: IDataPoint): boolean {\r\n    for (let i = 0; i < this.dataRow.length; i++) {\r\n      if (this.dataRow[i].getID() === dataRowID) {\r\n        return this.dataRow[i].addDatapoint(datapoint);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Datenreihen zurück.\r\n   * @returns Ein zwei Dimensionales Array, die Erste Dimension wählt die Datenreihe und die zweite Dimension den Datenpunkt.\r\n   */\r\n  public getDataRows(): IDataRowST[] {\r\n    var dataRows: IDataRowST[] = [];\r\n    for (let i = 0; i < this.dataRow.length; i++) {\r\n      dataRows.push(this.dataRow[i].getDataRow());\r\n    }\r\n    return dataRows;\r\n  }\r\n\r\n  /**\r\n   * Erstellt ein Label\r\n   * @param labelID die eindeutige Label ID\r\n   * @param name der Labelname\r\n   * @param start die Startzeit des Zeitfensters in Millisekunden\r\n   * @param end die Endzeit des Zeitfensters in Millisekunden\r\n   * @returns falls das Label mit der ID schon existiert wird false zurück gegeben\r\n   */\r\n  public createLabel(labelID: number, span: ISpan, labelName: string): boolean {\r\n    if (labelID < 0 || span.start < 0 || span.end < span.start) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() === labelID) {\r\n        return false;\r\n      }\r\n    }\r\n    this.label.push(new Label(labelName, labelID, span));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Setzt dem Label mit der übergebenen ID neue Werte.\r\n   * @param span ist die Start- und Endzeit in Millisekunden.\r\n   * @param labelID Die Label ID, welche überarbeitet werden soll.\r\n   * @param labelName Ist bei Angabe der neue Name des Labels.\r\n   * @returns falls das Label nicht existiert wird false zurück gegeben\r\n   */\r\n  public setLabel(labelID: number, span: ISpan, labelName?: string): boolean {\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() === labelID) {\r\n        return this.label[i].setLabel(span, labelName);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Löscht das Label mit der übergebenen LabelID.\r\n   * @param labelID die LabelID\r\n   */\r\n  public deleteLabel(labelID: number): boolean {\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      if (this.label[i].getID() === labelID) {\r\n        this.label.splice(i, 1);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gibt alle Daten von allen Labeln zurück.\r\n   */\r\n  public getLabels(): ILabel[] {\r\n    var labelList: ILabel[] = [];\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      labelList.push(this.label[i].getLabel());\r\n    }\r\n    return labelList;\r\n  }\r\n}\r\nexport interface IDataSet {\r\n  dataSetID: number,\r\n  dataSetName: string,\r\n  generateDate: number,\r\n  dataRows: IDataRowSTRID[],\r\n  label: ILabel[];\r\n}","C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Session.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\AIModel.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\DownloadButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\DiagramList\\index.tsx",["290","291","292","293"],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\VisualizationComponents\\FinishButton\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\DeliveryComponents\\EmailList\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ModelCreationPage\\State.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataRow.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\Label.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\QRImage\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\LinkText\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ChangeToVisuBtn\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ProjectList\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ModelCreationComponents\\Train\\index.tsx",["294"],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\DataPoint.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\model\\TimeSpan.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\components\\ReferringComponents\\ModelList\\index.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ResultPage\\Result.tsx",[],"C:\\Users\\timi300399\\Documents\\GitHub\\Typescript-Frontend\\ki-app\\src\\view\\pages\\ResultPage\\State.tsx",[],{"ruleId":"295","severity":1,"message":"296","line":7,"column":10,"nodeType":"297","messageId":"298","endLine":7,"endColumn":20},{"ruleId":"295","severity":1,"message":"296","line":7,"column":10,"nodeType":"297","messageId":"298","endLine":7,"endColumn":20},{"ruleId":"295","severity":1,"message":"299","line":3,"column":10,"nodeType":"297","messageId":"298","endLine":3,"endColumn":16},{"ruleId":"295","severity":1,"message":"300","line":3,"column":10,"nodeType":"297","messageId":"298","endLine":3,"endColumn":21},{"ruleId":"301","severity":1,"message":"302","line":78,"column":13,"nodeType":"303","messageId":"304","endLine":78,"endColumn":26},{"ruleId":"301","severity":1,"message":"302","line":78,"column":30,"nodeType":"303","messageId":"304","endLine":78,"endColumn":41},{"ruleId":"305","severity":1,"message":"306","line":57,"column":18,"nodeType":"297","messageId":"307","endLine":57,"endColumn":19},{"ruleId":"295","severity":1,"message":"300","line":2,"column":19,"nodeType":"297","messageId":"298","endLine":2,"endColumn":30},{"ruleId":"295","severity":1,"message":"296","line":4,"column":10,"nodeType":"297","messageId":"298","endLine":4,"endColumn":20},{"ruleId":"295","severity":1,"message":"308","line":1,"column":8,"nodeType":"297","messageId":"298","endLine":1,"endColumn":13},{"ruleId":"309","severity":1,"message":"310","line":64,"column":9,"nodeType":"311","endLine":64,"endColumn":19},{"ruleId":"309","severity":1,"message":"310","line":140,"column":9,"nodeType":"311","endLine":140,"endColumn":19},{"ruleId":"312","severity":1,"message":"313","line":160,"column":104,"nodeType":"303","messageId":"314","endLine":160,"endColumn":106},{"ruleId":"312","severity":1,"message":"315","line":157,"column":26,"nodeType":"303","messageId":"314","endLine":157,"endColumn":28},"@typescript-eslint/no-unused-vars","'SensorData' is defined but never used.","Identifier","unusedVar","'ILabel' is defined but never used.","'IDataRowRID' is defined but never used.","use-isnan","Use the isNaN function to compare with NaN.","BinaryExpression","comparisonWithNaN","@typescript-eslint/no-redeclare","'j' is already defined.","redeclared","'Chart' is defined but never used.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","eqeqeq","Expected '!==' and instead saw '!='.","unexpected","Expected '===' and instead saw '=='."]